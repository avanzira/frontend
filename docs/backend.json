{
    "backend": {
        ".env": "JWT_SECRET_KEY=CHANGE_ME\nTOKEN_EXPIRE_MINUTES=60\nREFRESH_EXPIRE_DAYS=30",
        ".git": {
            "COMMIT_EDITMSG": "README.md V3.0\n",
            "config": "[core]\n\trepositoryformatversion = 0\n\tfilemode = false\n\tbare = false\n\tlogallrefupdates = true\n\tsymlinks = false\n\tignorecase = true\n[branch \"main\"]\n\tgk-last-accessed = 2026-01-20T18:35:12.300Z\n\tremote = origin\n\tmerge = refs/heads/main\n\tgk-last-modified = 2026-01-20T18:35:12.300Z\n[remote \"origin\"]\n\turl = https://github.com/avanzira/backend.git\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n",
            "description": "Unnamed repository; edit this file 'description' to name the repository.\n",
            "FETCH_HEAD": "bd0e81f8294439922fac950254c20daa854bdf39\t\tbranch 'main' of https://github.com/avanzira/backend\n",
            "HEAD": "ref: refs/heads/main\n",
            "hooks": {
                "applypatch-msg.sample": "#!/bin/sh\n#\n# An example hook script to check the commit log message taken by\n# applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n# appropriate message if it wants to stop the commit.  The hook is\n# allowed to edit the commit message file.\n#\n# To enable this hook, rename this file to \"applypatch-msg\".\n\n. git-sh-setup\ncommitmsg=\"$(git rev-parse --git-path hooks/commit-msg)\"\ntest -x \"$commitmsg\" && exec \"$commitmsg\" ${1+\"$@\"}\n:\n",
                "commit-msg.sample": "#!/bin/sh\n#\n# An example hook script to check the commit log message.\n# Called by \"git commit\" with one argument, the name of the file\n# that has the commit message.  The hook should exit with non-zero\n# status after issuing an appropriate message if it wants to stop the\n# commit.  The hook is allowed to edit the commit message file.\n#\n# To enable this hook, rename this file to \"commit-msg\".\n\n# Uncomment the below to add a Signed-off-by line to the message.\n# Doing this in a hook is a bad idea in general, but the prepare-commit-msg\n# hook is more suited to it.\n#\n# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# grep -qs \"^$SOB\" \"$1\" || echo \"$SOB\" >> \"$1\"\n\n# This example catches duplicate Signed-off-by lines.\n\ntest \"\" = \"$(grep '^Signed-off-by: ' \"$1\" |\n\t sort | uniq -c | sed -e '/^[ \t]*1[ \t]/d')\" || {\n\techo >&2 Duplicate Signed-off-by lines.\n\texit 1\n}\n",
                "fsmonitor-watchman.sample": "#!/usr/bin/perl\n\nuse strict;\nuse warnings;\nuse IPC::Open2;\n\n# An example hook script to integrate Watchman\n# (https://facebook.github.io/watchman/) with git to speed up detecting\n# new and modified files.\n#\n# The hook is passed a version (currently 2) and last update token\n# formatted as a string and outputs to stdout a new update token and\n# all files that have been modified since the update token. Paths must\n# be relative to the root of the working tree and separated by a single NUL.\n#\n# To enable this hook, rename this file to \"query-watchman\" and set\n# 'git config core.fsmonitor .git/hooks/query-watchman'\n#\nmy ($version, $last_update_token) = @ARGV;\n\n# Uncomment for debugging\n# print STDERR \"$0 $version $last_update_token\\n\";\n\n# Check the hook interface version\nif ($version ne 2) {\n\tdie \"Unsupported query-fsmonitor hook version '$version'.\\n\" .\n\t    \"Falling back to scanning...\\n\";\n}\n\nmy $git_work_tree = get_working_dir();\n\nmy $retry = 1;\n\nmy $json_pkg;\neval {\n\trequire JSON::XS;\n\t$json_pkg = \"JSON::XS\";\n\t1;\n} or do {\n\trequire JSON::PP;\n\t$json_pkg = \"JSON::PP\";\n};\n\nlaunch_watchman();\n\nsub launch_watchman {\n\tmy $o = watchman_query();\n\tif (is_work_tree_watched($o)) {\n\t\toutput_result($o->{clock}, @{$o->{files}});\n\t}\n}\n\nsub output_result {\n\tmy ($clockid, @files) = @_;\n\n\t# Uncomment for debugging watchman output\n\t# open (my $fh, \">\", \".git/watchman-output.out\");\n\t# binmode $fh, \":utf8\";\n\t# print $fh \"$clockid\\n@files\\n\";\n\t# close $fh;\n\n\tbinmode STDOUT, \":utf8\";\n\tprint $clockid;\n\tprint \"\\0\";\n\tlocal $, = \"\\0\";\n\tprint @files;\n}\n\nsub watchman_clock {\n\tmy $response = qx/watchman clock \"$git_work_tree\"/;\n\tdie \"Failed to get clock id on '$git_work_tree'.\\n\" .\n\t\t\"Falling back to scanning...\\n\" if $? != 0;\n\n\treturn $json_pkg->new->utf8->decode($response);\n}\n\nsub watchman_query {\n\tmy $pid = open2(\\*CHLD_OUT, \\*CHLD_IN, 'watchman -j --no-pretty')\n\tor die \"open2() failed: $!\\n\" .\n\t\"Falling back to scanning...\\n\";\n\n\t# In the query expression below we're asking for names of files that\n\t# changed since $last_update_token but not from the .git folder.\n\t#\n\t# To accomplish this, we're using the \"since\" generator to use the\n\t# recency index to select candidate nodes and \"fields\" to limit the\n\t# output to file names only. Then we're using the \"expression\" term to\n\t# further constrain the results.\n\tmy $last_update_line = \"\";\n\tif (substr($last_update_token, 0, 1) eq \"c\") {\n\t\t$last_update_token = \"\\\"$last_update_token\\\"\";\n\t\t$last_update_line = qq[\\n\"since\": $last_update_token,];\n\t}\n\tmy $query = <<\"\tEND\";\n\t\t[\"query\", \"$git_work_tree\", {$last_update_line\n\t\t\t\"fields\": [\"name\"],\n\t\t\t\"expression\": [\"not\", [\"dirname\", \".git\"]]\n\t\t}]\n\tEND\n\n\t# Uncomment for debugging the watchman query\n\t# open (my $fh, \">\", \".git/watchman-query.json\");\n\t# print $fh $query;\n\t# close $fh;\n\n\tprint CHLD_IN $query;\n\tclose CHLD_IN;\n\tmy $response = do {local $/; <CHLD_OUT>};\n\n\t# Uncomment for debugging the watch response\n\t# open ($fh, \">\", \".git/watchman-response.json\");\n\t# print $fh $response;\n\t# close $fh;\n\n\tdie \"Watchman: command returned no output.\\n\" .\n\t\"Falling back to scanning...\\n\" if $response eq \"\";\n\tdie \"Watchman: command returned invalid output: $response\\n\" .\n\t\"Falling back to scanning...\\n\" unless $response =~ /^\\{/;\n\n\treturn $json_pkg->new->utf8->decode($response);\n}\n\nsub is_work_tree_watched {\n\tmy ($output) = @_;\n\tmy $error = $output->{error};\n\tif ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {\n\t\t$retry--;\n\t\tmy $response = qx/watchman watch \"$git_work_tree\"/;\n\t\tdie \"Failed to make watchman watch '$git_work_tree'.\\n\" .\n\t\t    \"Falling back to scanning...\\n\" if $? != 0;\n\t\t$output = $json_pkg->new->utf8->decode($response);\n\t\t$error = $output->{error};\n\t\tdie \"Watchman: $error.\\n\" .\n\t\t\"Falling back to scanning...\\n\" if $error;\n\n\t\t# Uncomment for debugging watchman output\n\t\t# open (my $fh, \">\", \".git/watchman-output.out\");\n\t\t# close $fh;\n\n\t\t# Watchman will always return all files on the first query so\n\t\t# return the fast \"everything is dirty\" flag to git and do the\n\t\t# Watchman query just to get it over with now so we won't pay\n\t\t# the cost in git to look up each individual file.\n\t\tmy $o = watchman_clock();\n\t\t$error = $output->{error};\n\n\t\tdie \"Watchman: $error.\\n\" .\n\t\t\"Falling back to scanning...\\n\" if $error;\n\n\t\toutput_result($o->{clock}, (\"/\"));\n\t\t$last_update_token = $o->{clock};\n\n\t\teval { launch_watchman() };\n\t\treturn 0;\n\t}\n\n\tdie \"Watchman: $error.\\n\" .\n\t\"Falling back to scanning...\\n\" if $error;\n\n\treturn 1;\n}\n\nsub get_working_dir {\n\tmy $working_dir;\n\tif ($^O =~ 'msys' || $^O =~ 'cygwin') {\n\t\t$working_dir = Win32::GetCwd();\n\t\t$working_dir =~ tr/\\\\/\\//;\n\t} else {\n\t\trequire Cwd;\n\t\t$working_dir = Cwd::cwd();\n\t}\n\n\treturn $working_dir;\n}\n",
                "post-update.sample": "#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n\nexec git update-server-info\n",
                "pre-applypatch.sample": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed\n# by applypatch from an e-mail message.\n#\n# The hook should exit with non-zero status after issuing an\n# appropriate message if it wants to stop the commit.\n#\n# To enable this hook, rename this file to \"pre-applypatch\".\n\n. git-sh-setup\nprecommit=\"$(git rev-parse --git-path hooks/pre-commit)\"\ntest -x \"$precommit\" && exec \"$precommit\" ${1+\"$@\"}\n:\n",
                "pre-commit.sample": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git commit\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message if\n# it wants to stop the commit.\n#\n# To enable this hook, rename this file to \"pre-commit\".\n\nif git rev-parse --verify HEAD >/dev/null 2>&1\nthen\n\tagainst=HEAD\nelse\n\t# Initial commit: diff against an empty tree object\n\tagainst=$(git hash-object -t tree /dev/null)\nfi\n\n# If you want to allow non-ASCII filenames set this variable to true.\nallownonascii=$(git config --type=bool hooks.allownonascii)\n\n# Redirect output to stderr.\nexec 1>&2\n\n# Cross platform projects tend to avoid non-ASCII filenames; prevent\n# them from being added to the repository. We exploit the fact that the\n# printable range starts at the space character and ends with tilde.\nif [ \"$allownonascii\" != \"true\" ] &&\n\t# Note that the use of brackets around a tr range is ok here, (it's\n\t# even required, for portability to Solaris 10's /usr/bin/tr), since\n\t# the square bracket bytes happen to fall in the designated range.\n\ttest $(git diff-index --cached --name-only --diff-filter=A -z $against |\n\t  LC_ALL=C tr -d '[ -~]\\0' | wc -c) != 0\nthen\n\tcat <<\\EOF\nError: Attempt to add a non-ASCII file name.\n\nThis can cause problems if you want to work with people on other platforms.\n\nTo be portable it is advisable to rename the file.\n\nIf you know what you are doing you can disable this check using:\n\n  git config hooks.allownonascii true\nEOF\n\texit 1\nfi\n\n# If there are whitespace errors, print the offending file names and fail.\nexec git diff-index --check --cached $against --\n",
                "pre-merge-commit.sample": "#!/bin/sh\n#\n# An example hook script to verify what is about to be committed.\n# Called by \"git merge\" with no arguments.  The hook should\n# exit with non-zero status after issuing an appropriate message to\n# stderr if it wants to stop the merge commit.\n#\n# To enable this hook, rename this file to \"pre-merge-commit\".\n\n. git-sh-setup\ntest -x \"$GIT_DIR/hooks/pre-commit\" &&\n        exec \"$GIT_DIR/hooks/pre-commit\"\n:\n",
                "pre-push.sample": "#!/bin/sh\n\n# An example hook script to verify what is about to be pushed.  Called by \"git\n# push\" after it has checked the remote status, but before anything has been\n# pushed.  If this script exits with a non-zero status nothing will be pushed.\n#\n# This hook is called with the following parameters:\n#\n# $1 -- Name of the remote to which the push is being done\n# $2 -- URL to which the push is being done\n#\n# If pushing without using a named remote those arguments will be equal.\n#\n# Information about the commits which are being pushed is supplied as lines to\n# the standard input in the form:\n#\n#   <local ref> <local oid> <remote ref> <remote oid>\n#\n# This sample shows how to prevent push of commits where the log message starts\n# with \"WIP\" (work in progress).\n\nremote=\"$1\"\nurl=\"$2\"\n\nzero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')\n\nwhile read local_ref local_oid remote_ref remote_oid\ndo\n\tif test \"$local_oid\" = \"$zero\"\n\tthen\n\t\t# Handle delete\n\t\t:\n\telse\n\t\tif test \"$remote_oid\" = \"$zero\"\n\t\tthen\n\t\t\t# New branch, examine all commits\n\t\t\trange=\"$local_oid\"\n\t\telse\n\t\t\t# Update to existing branch, examine new commits\n\t\t\trange=\"$remote_oid..$local_oid\"\n\t\tfi\n\n\t\t# Check for WIP commit\n\t\tcommit=$(git rev-list -n 1 --grep '^WIP' \"$range\")\n\t\tif test -n \"$commit\"\n\t\tthen\n\t\t\techo >&2 \"Found WIP commit in $local_ref, not pushing\"\n\t\t\texit 1\n\t\tfi\n\tfi\ndone\n\nexit 0\n",
                "pre-rebase.sample": "#!/bin/sh\n#\n# Copyright (c) 2006, 2008 Junio C Hamano\n#\n# The \"pre-rebase\" hook is run just before \"git rebase\" starts doing\n# its job, and can prevent the command from running by exiting with\n# non-zero status.\n#\n# The hook is called with the following parameters:\n#\n# $1 -- the upstream the series was forked from.\n# $2 -- the branch being rebased (or empty when rebasing the current branch).\n#\n# This sample shows how to prevent topic branches that are already\n# merged to 'next' branch from getting rebased, because allowing it\n# would result in rebasing already published history.\n\npublish=next\nbasebranch=\"$1\"\nif test \"$#\" = 2\nthen\n\ttopic=\"refs/heads/$2\"\nelse\n\ttopic=`git symbolic-ref HEAD` ||\n\texit 0 ;# we do not interrupt rebasing detached HEAD\nfi\n\ncase \"$topic\" in\nrefs/heads/??/*)\n\t;;\n*)\n\texit 0 ;# we do not interrupt others.\n\t;;\nesac\n\n# Now we are dealing with a topic branch being rebased\n# on top of master.  Is it OK to rebase it?\n\n# Does the topic really exist?\ngit show-ref -q \"$topic\" || {\n\techo >&2 \"No such branch $topic\"\n\texit 1\n}\n\n# Is topic fully merged to master?\nnot_in_master=`git rev-list --pretty=oneline ^master \"$topic\"`\nif test -z \"$not_in_master\"\nthen\n\techo >&2 \"$topic is fully merged to master; better remove it.\"\n\texit 1 ;# we could allow it, but there is no point.\nfi\n\n# Is topic ever merged to next?  If so you should not be rebasing it.\nonly_next_1=`git rev-list ^master \"^$topic\" ${publish} | sort`\nonly_next_2=`git rev-list ^master           ${publish} | sort`\nif test \"$only_next_1\" = \"$only_next_2\"\nthen\n\tnot_in_topic=`git rev-list \"^$topic\" master`\n\tif test -z \"$not_in_topic\"\n\tthen\n\t\techo >&2 \"$topic is already up to date with master\"\n\t\texit 1 ;# we could allow it, but there is no point.\n\telse\n\t\texit 0\n\tfi\nelse\n\tnot_in_next=`git rev-list --pretty=oneline ^${publish} \"$topic\"`\n\t/usr/bin/perl -e '\n\t\tmy $topic = $ARGV[0];\n\t\tmy $msg = \"* $topic has commits already merged to public branch:\\n\";\n\t\tmy (%not_in_next) = map {\n\t\t\t/^([0-9a-f]+) /;\n\t\t\t($1 => 1);\n\t\t} split(/\\n/, $ARGV[1]);\n\t\tfor my $elem (map {\n\t\t\t\t/^([0-9a-f]+) (.*)$/;\n\t\t\t\t[$1 => $2];\n\t\t\t} split(/\\n/, $ARGV[2])) {\n\t\t\tif (!exists $not_in_next{$elem->[0]}) {\n\t\t\t\tif ($msg) {\n\t\t\t\t\tprint STDERR $msg;\n\t\t\t\t\tundef $msg;\n\t\t\t\t}\n\t\t\t\tprint STDERR \" $elem->[1]\\n\";\n\t\t\t}\n\t\t}\n\t' \"$topic\" \"$not_in_next\" \"$not_in_master\"\n\texit 1\nfi\n\n<<\\DOC_END\n\nThis sample hook safeguards topic branches that have been\npublished from being rewound.\n\nThe workflow assumed here is:\n\n * Once a topic branch forks from \"master\", \"master\" is never\n   merged into it again (either directly or indirectly).\n\n * Once a topic branch is fully cooked and merged into \"master\",\n   it is deleted.  If you need to build on top of it to correct\n   earlier mistakes, a new topic branch is created by forking at\n   the tip of the \"master\".  This is not strictly necessary, but\n   it makes it easier to keep your history simple.\n\n * Whenever you need to test or publish your changes to topic\n   branches, merge them into \"next\" branch.\n\nThe script, being an example, hardcodes the publish branch name\nto be \"next\", but it is trivial to make it configurable via\n$GIT_DIR/config mechanism.\n\nWith this workflow, you would want to know:\n\n(1) ... if a topic branch has ever been merged to \"next\".  Young\n    topic branches can have stupid mistakes you would rather\n    clean up before publishing, and things that have not been\n    merged into other branches can be easily rebased without\n    affecting other people.  But once it is published, you would\n    not want to rewind it.\n\n(2) ... if a topic branch has been fully merged to \"master\".\n    Then you can delete it.  More importantly, you should not\n    build on top of it -- other people may already want to\n    change things related to the topic as patches against your\n    \"master\", so if you need further changes, it is better to\n    fork the topic (perhaps with the same name) afresh from the\n    tip of \"master\".\n\nLet's look at this example:\n\n\t\t   o---o---o---o---o---o---o---o---o---o \"next\"\n\t\t  /       /           /           /\n\t\t /   a---a---b A     /           /\n\t\t/   /               /           /\n\t       /   /   c---c---c---c B         /\n\t      /   /   /             \\         /\n\t     /   /   /   b---b C     \\       /\n\t    /   /   /   /             \\     /\n    ---o---o---o---o---o---o---o---o---o---o---o \"master\"\n\n\nA, B and C are topic branches.\n\n * A has one fix since it was merged up to \"next\".\n\n * B has finished.  It has been fully merged up to \"master\" and \"next\",\n   and is ready to be deleted.\n\n * C has not merged to \"next\" at all.\n\nWe would want to allow C to be rebased, refuse A, and encourage\nB to be deleted.\n\nTo compute (1):\n\n\tgit rev-list ^master ^topic next\n\tgit rev-list ^master        next\n\n\tif these match, topic has not merged in next at all.\n\nTo compute (2):\n\n\tgit rev-list master..topic\n\n\tif this is empty, it is fully merged to \"master\".\n\nDOC_END\n",
                "pre-receive.sample": "#!/bin/sh\n#\n# An example hook script to make use of push options.\n# The example simply echoes all push options that start with 'echoback='\n# and rejects all pushes when the \"reject\" push option is used.\n#\n# To enable this hook, rename this file to \"pre-receive\".\n\nif test -n \"$GIT_PUSH_OPTION_COUNT\"\nthen\n\ti=0\n\twhile test \"$i\" -lt \"$GIT_PUSH_OPTION_COUNT\"\n\tdo\n\t\teval \"value=\\$GIT_PUSH_OPTION_$i\"\n\t\tcase \"$value\" in\n\t\techoback=*)\n\t\t\techo \"echo from the pre-receive-hook: ${value#*=}\" >&2\n\t\t\t;;\n\t\treject)\n\t\t\texit 1\n\t\tesac\n\t\ti=$((i + 1))\n\tdone\nfi\n",
                "prepare-commit-msg.sample": "#!/bin/sh\n#\n# An example hook script to prepare the commit log message.\n# Called by \"git commit\" with the name of the file that has the\n# commit message, followed by the description of the commit\n# message's source.  The hook's purpose is to edit the commit\n# message file.  If the hook fails with a non-zero status,\n# the commit is aborted.\n#\n# To enable this hook, rename this file to \"prepare-commit-msg\".\n\n# This hook includes three examples. The first one removes the\n# \"# Please enter the commit message...\" help message.\n#\n# The second includes the output of \"git diff --name-status -r\"\n# into the message, just before the \"git status\" output.  It is\n# commented because it doesn't cope with --amend or with squashed\n# commits.\n#\n# The third example adds a Signed-off-by line to the message, that can\n# still be edited.  This is rarely a good idea.\n\nCOMMIT_MSG_FILE=$1\nCOMMIT_SOURCE=$2\nSHA1=$3\n\n/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' \"$COMMIT_MSG_FILE\"\n\n# case \"$COMMIT_SOURCE,$SHA1\" in\n#  ,|template,)\n#    /usr/bin/perl -i.bak -pe '\n#       print \"\\n\" . `git diff --cached --name-status -r`\n# \t if /^#/ && $first++ == 0' \"$COMMIT_MSG_FILE\" ;;\n#  *) ;;\n# esac\n\n# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\\(.*>\\).*$/Signed-off-by: \\1/p')\n# git interpret-trailers --in-place --trailer \"$SOB\" \"$COMMIT_MSG_FILE\"\n# if test -z \"$COMMIT_SOURCE\"\n# then\n#   /usr/bin/perl -i.bak -pe 'print \"\\n\" if !$first_line++' \"$COMMIT_MSG_FILE\"\n# fi\n",
                "push-to-checkout.sample": "#!/bin/sh\n\n# An example hook script to update a checked-out tree on a git push.\n#\n# This hook is invoked by git-receive-pack(1) when it reacts to git\n# push and updates reference(s) in its repository, and when the push\n# tries to update the branch that is currently checked out and the\n# receive.denyCurrentBranch configuration variable is set to\n# updateInstead.\n#\n# By default, such a push is refused if the working tree and the index\n# of the remote repository has any difference from the currently\n# checked out commit; when both the working tree and the index match\n# the current commit, they are updated to match the newly pushed tip\n# of the branch. This hook is to be used to override the default\n# behaviour; however the code below reimplements the default behaviour\n# as a starting point for convenient modification.\n#\n# The hook receives the commit with which the tip of the current\n# branch is going to be updated:\ncommit=$1\n\n# It can exit with a non-zero status to refuse the push (when it does\n# so, it must not modify the index or the working tree).\ndie () {\n\techo >&2 \"$*\"\n\texit 1\n}\n\n# Or it can make any necessary changes to the working tree and to the\n# index to bring them to the desired state when the tip of the current\n# branch is updated to the new commit, and exit with a zero status.\n#\n# For example, the hook can simply run git read-tree -u -m HEAD \"$1\"\n# in order to emulate git fetch that is run in the reverse direction\n# with git push, as the two-tree form of git read-tree -u -m is\n# essentially the same as git switch or git checkout that switches\n# branches while keeping the local changes in the working tree that do\n# not interfere with the difference between the branches.\n\n# The below is a more-or-less exact translation to shell of the C code\n# for the default behaviour for git's push-to-checkout hook defined in\n# the push_to_deploy() function in builtin/receive-pack.c.\n#\n# Note that the hook will be executed from the repository directory,\n# not from the working tree, so if you want to perform operations on\n# the working tree, you will have to adapt your code accordingly, e.g.\n# by adding \"cd ..\" or using relative paths.\n\nif ! git update-index -q --ignore-submodules --refresh\nthen\n\tdie \"Up-to-date check failed\"\nfi\n\nif ! git diff-files --quiet --ignore-submodules --\nthen\n\tdie \"Working directory has unstaged changes\"\nfi\n\n# This is a rough translation of:\n#\n#   head_has_history() ? \"HEAD\" : EMPTY_TREE_SHA1_HEX\nif git cat-file -e HEAD 2>/dev/null\nthen\n\thead=HEAD\nelse\n\thead=$(git hash-object -t tree --stdin </dev/null)\nfi\n\nif ! git diff-index --quiet --cached --ignore-submodules $head --\nthen\n\tdie \"Working directory has staged changes\"\nfi\n\nif ! git read-tree -u -m \"$commit\"\nthen\n\tdie \"Could not update working tree to new HEAD\"\nfi\n",
                "sendemail-validate.sample": "#!/bin/sh\n\n# An example hook script to validate a patch (and/or patch series) before\n# sending it via email.\n#\n# The hook should exit with non-zero status after issuing an appropriate\n# message if it wants to prevent the email(s) from being sent.\n#\n# To enable this hook, rename this file to \"sendemail-validate\".\n#\n# By default, it will only check that the patch(es) can be applied on top of\n# the default upstream branch without conflicts in a secondary worktree. After\n# validation (successful or not) of the last patch of a series, the worktree\n# will be deleted.\n#\n# The following config variables can be set to change the default remote and\n# remote ref that are used to apply the patches against:\n#\n#   sendemail.validateRemote (default: origin)\n#   sendemail.validateRemoteRef (default: HEAD)\n#\n# Replace the TODO placeholders with appropriate checks according to your\n# needs.\n\nvalidate_cover_letter () {\n\tfile=\"$1\"\n\t# TODO: Replace with appropriate checks (e.g. spell checking).\n\ttrue\n}\n\nvalidate_patch () {\n\tfile=\"$1\"\n\t# Ensure that the patch applies without conflicts.\n\tgit am -3 \"$file\" || return\n\t# TODO: Replace with appropriate checks for this patch\n\t# (e.g. checkpatch.pl).\n\ttrue\n}\n\nvalidate_series () {\n\t# TODO: Replace with appropriate checks for the whole series\n\t# (e.g. quick build, coding style checks, etc.).\n\ttrue\n}\n\n# main -------------------------------------------------------------------------\n\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = 1\nthen\n\tremote=$(git config --default origin --get sendemail.validateRemote) &&\n\tref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&\n\tworktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&\n\tgit worktree add -fd --checkout \"$worktree\" \"refs/remotes/$remote/$ref\" &&\n\tgit config --replace-all sendemail.validateWorktree \"$worktree\"\nelse\n\tworktree=$(git config --get sendemail.validateWorktree)\nfi || {\n\techo \"sendemail-validate: error: failed to prepare worktree\" >&2\n\texit 1\n}\n\nunset GIT_DIR GIT_WORK_TREE\ncd \"$worktree\" &&\n\nif grep -q \"^diff --git \" \"$1\"\nthen\n\tvalidate_patch \"$1\"\nelse\n\tvalidate_cover_letter \"$1\"\nfi &&\n\nif test \"$GIT_SENDEMAIL_FILE_COUNTER\" = \"$GIT_SENDEMAIL_FILE_TOTAL\"\nthen\n\tgit config --unset-all sendemail.validateWorktree &&\n\ttrap 'git worktree remove -ff \"$worktree\"' EXIT &&\n\tvalidate_series\nfi\n",
                "update.sample": "#!/bin/sh\n#\n# An example hook script to block unannotated tags from entering.\n# Called by \"git receive-pack\" with arguments: refname sha1-old sha1-new\n#\n# To enable this hook, rename this file to \"update\".\n#\n# Config\n# ------\n# hooks.allowunannotated\n#   This boolean sets whether unannotated tags will be allowed into the\n#   repository.  By default they won't be.\n# hooks.allowdeletetag\n#   This boolean sets whether deleting tags will be allowed in the\n#   repository.  By default they won't be.\n# hooks.allowmodifytag\n#   This boolean sets whether a tag may be modified after creation. By default\n#   it won't be.\n# hooks.allowdeletebranch\n#   This boolean sets whether deleting branches will be allowed in the\n#   repository.  By default they won't be.\n# hooks.denycreatebranch\n#   This boolean sets whether remotely creating branches will be denied\n#   in the repository.  By default this is allowed.\n#\n\n# --- Command line\nrefname=\"$1\"\noldrev=\"$2\"\nnewrev=\"$3\"\n\n# --- Safety check\nif [ -z \"$GIT_DIR\" ]; then\n\techo \"Don't run this script from the command line.\" >&2\n\techo \" (if you want, you could supply GIT_DIR then run\" >&2\n\techo \"  $0 <ref> <oldrev> <newrev>)\" >&2\n\texit 1\nfi\n\nif [ -z \"$refname\" -o -z \"$oldrev\" -o -z \"$newrev\" ]; then\n\techo \"usage: $0 <ref> <oldrev> <newrev>\" >&2\n\texit 1\nfi\n\n# --- Config\nallowunannotated=$(git config --type=bool hooks.allowunannotated)\nallowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)\ndenycreatebranch=$(git config --type=bool hooks.denycreatebranch)\nallowdeletetag=$(git config --type=bool hooks.allowdeletetag)\nallowmodifytag=$(git config --type=bool hooks.allowmodifytag)\n\n# check for no description\nprojectdesc=$(sed -e '1q' \"$GIT_DIR/description\")\ncase \"$projectdesc\" in\n\"Unnamed repository\"* | \"\")\n\techo \"*** Project description file hasn't been set\" >&2\n\texit 1\n\t;;\nesac\n\n# --- Check types\n# if $newrev is 0000...0000, it's a commit to delete a ref.\nzero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')\nif [ \"$newrev\" = \"$zero\" ]; then\n\tnewrev_type=delete\nelse\n\tnewrev_type=$(git cat-file -t $newrev)\nfi\n\ncase \"$refname\",\"$newrev_type\" in\n\trefs/tags/*,commit)\n\t\t# un-annotated tag\n\t\tshort_refname=${refname##refs/tags/}\n\t\tif [ \"$allowunannotated\" != \"true\" ]; then\n\t\t\techo \"*** The un-annotated tag, $short_refname, is not allowed in this repository\" >&2\n\t\t\techo \"*** Use 'git tag [ -a | -s ]' for tags you want to propagate.\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/tags/*,delete)\n\t\t# delete tag\n\t\tif [ \"$allowdeletetag\" != \"true\" ]; then\n\t\t\techo \"*** Deleting a tag is not allowed in this repository\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/tags/*,tag)\n\t\t# annotated tag\n\t\tif [ \"$allowmodifytag\" != \"true\" ] && git rev-parse $refname > /dev/null 2>&1\n\t\tthen\n\t\t\techo \"*** Tag '$refname' already exists.\" >&2\n\t\t\techo \"*** Modifying a tag is not allowed in this repository.\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/heads/*,commit)\n\t\t# branch\n\t\tif [ \"$oldrev\" = \"$zero\" -a \"$denycreatebranch\" = \"true\" ]; then\n\t\t\techo \"*** Creating a branch is not allowed in this repository\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/heads/*,delete)\n\t\t# delete branch\n\t\tif [ \"$allowdeletebranch\" != \"true\" ]; then\n\t\t\techo \"*** Deleting a branch is not allowed in this repository\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\trefs/remotes/*,commit)\n\t\t# tracking branch\n\t\t;;\n\trefs/remotes/*,delete)\n\t\t# delete tracking branch\n\t\tif [ \"$allowdeletebranch\" != \"true\" ]; then\n\t\t\techo \"*** Deleting a tracking branch is not allowed in this repository\" >&2\n\t\t\texit 1\n\t\tfi\n\t\t;;\n\t*)\n\t\t# Anything else (is there anything else?)\n\t\techo \"*** Update hook: unknown type of update to ref $refname of type $newrev_type\" >&2\n\t\texit 1\n\t\t;;\nesac\n\n# --- Finished\nexit 0\n"
            },
            "index": "",
            "info": {
                "exclude": "# git ls-files --others --exclude-from=.git/info/exclude\n# Lines that start with '#' are comments.\n# For a project mostly in C, the following would be a good set of\n# exclude patterns (uncomment them if you want to use them):\n# *.[oa]\n# *~\n"
            },
            "logs": {
                "HEAD": "0000000000000000000000000000000000000000 bd0e81f8294439922fac950254c20daa854bdf39 Avanzira <avanzira@outlook.com> 1768933962 +0100\tcommit (initial): backend v3 creado y testado\nbd0e81f8294439922fac950254c20daa854bdf39 f0223a7ed1d88347951c81613cbbfcec484023f7 Avanzira <avanzira@outlook.com> 1768934244 +0100\tcommit: README.md V3.0\n",
                "refs": {
                    "heads": {
                        "main": "0000000000000000000000000000000000000000 bd0e81f8294439922fac950254c20daa854bdf39 Avanzira <avanzira@outlook.com> 1768933962 +0100\tcommit (initial): backend v3 creado y testado\nbd0e81f8294439922fac950254c20daa854bdf39 f0223a7ed1d88347951c81613cbbfcec484023f7 Avanzira <avanzira@outlook.com> 1768934244 +0100\tcommit: README.md V3.0\n"
                    },
                    "remotes": {
                        "origin": {
                            "main": "0000000000000000000000000000000000000000 bd0e81f8294439922fac950254c20daa854bdf39 Avanzira <avanzira@outlook.com> 1768933979 +0100\tupdate by push\nbd0e81f8294439922fac950254c20daa854bdf39 f0223a7ed1d88347951c81613cbbfcec484023f7 Avanzira <avanzira@outlook.com> 1768934246 +0100\tupdate by push\n"
                        }
                    }
                }
            },
            "objects": {
                "03": {
                    "f12fbd3f0f03e34d79c6ae995e6733069e2836": ""
                },
                "09": {
                    "3ee400d6fb17320d75b2530cb382fc87196508": ""
                },
                "0d": {
                    "4054bf5bc738d9ef9ddb9ab06e38d5f6a81d82": "",
                    "c59fc9802c04249d04103c7f347e396477eb35": ""
                },
                "0f": {
                    "a7a23841563a404100e19afe9b464ce07948a4": ""
                },
                "11": {
                    "4da03b923b89aea6ef044ddc7b76b9ae773e42": ""
                },
                "12": {
                    "20ef1c05293d0af390623e28e9460a2e585fa2": "",
                    "7fb1599fec71eb3eac171def657168445bd707": ""
                },
                "16": {
                    "9fca2bbf6ddbf50489b3a9e071b8e4ad21e57d": "",
                    "ad518cfd87560f7981df5a6b63dacdd716da8e": ""
                },
                "17": {
                    "5aefb96e593d6408564f8d8030d8d553581597": ""
                },
                "18": {
                    "188cb3f77a64a009735f875354423ad5a21f6e": "",
                    "65b0546dea57b51072deedc077ca3c2a5b7a67": ""
                },
                "19": {
                    "4a3ee79c0436672c9261448d7c5cfd03911b70": ""
                },
                "1c": {
                    "9a9b72c4ea1e51f13006bf760013c81a4328ca": ""
                },
                "1e": {
                    "11c91f646bace9e4465d95c933512857064ebd": "",
                    "11cde99fec9720baee65b769e837ce6f583a43": "",
                    "47e46c954389e1cf02fd8fe9447cacf0dd18c1": ""
                },
                "20": {
                    "39918bed80306a29fdfb86f89ec79d0dc94366": "",
                    "d524523def2443dbb5e900945df6c58f87e076": "",
                    "daad4f67c9582a65bc635d2c3a8dc91ac71133": ""
                },
                "21": {
                    "54b7ea339d253ed75737925f5aba634cff92fb": ""
                },
                "22": {
                    "11e7f5956048575f8f5e28840be25e453e1f62": "",
                    "c33d9210cc78d25dbeffdafa38b21446722b69": "",
                    "ea2b83a510467f18ba5f254ef5fe1555f2e903": ""
                },
                "2d": {
                    "33af6c3096cff30d2f227b7d4afd972db633cc": ""
                },
                "30": {
                    "abdcb595e54726ad1fdb81c93e6d85ddd1cb99": ""
                },
                "36": {
                    "dbc524705a6f5ed9c1002ff4cad3e42f2c3ac4": ""
                },
                "38": {
                    "1dd8e320e0ac2a171d42fd4791d4179b26d5f4": "",
                    "79d2bc23cd2821201ab9b57c4ba91284eb04f9": "",
                    "8fb9a2614da7ce423e29d85c5b03696496b004": ""
                },
                "3d": {
                    "9b5239d1d9c56059c745ed68753573d2ad77a2": ""
                },
                "3e": {
                    "01cba2b2c4a9bccfac802af66ad63bb735c520": "",
                    "708fb5912febd61892ea150cc12be0400b21c4": "",
                    "7f834342f110bc9af735a4cb47f5c15082a2d8": ""
                },
                "3f": {
                    "84e4701b2aa861294589807b70156af45d740d": ""
                },
                "40": {
                    "e1f1df9555c7572c906bf53c8ece417b6a098d": ""
                },
                "41": {
                    "99912532e5c3f2b4d966507802d385f93cfba5": ""
                },
                "48": {
                    "9b6fd25d005c7d46b630a19886e4a94b0ad38a": "",
                    "fc741ad1caaa20b8ba8a8b5658195a44c7f794": ""
                },
                "53": {
                    "b2b66fa66f0679edd640b92b6fa15ac500bd1b": ""
                },
                "54": {
                    "eaafc0919c03b113a0935cbc5d6bb58c1a014a": ""
                },
                "56": {
                    "7a6c9436d116ef6af85768164d26f6a3d37cf4": ""
                },
                "57": {
                    "f9ba346c59c29fbf43f6e17c23469825c5f7c9": ""
                },
                "5a": {
                    "9eb7027c311964214e0697c0e6686e59519c8e": "",
                    "a932f2ba16a315bd2d165b97ee09b1f66c8fb0": ""
                },
                "5c": {
                    "8a1ce2abb4207adef550fd3caf5f5befa1ba79": ""
                },
                "5e": {
                    "477cf4a1cda0fd0ec03b6be082925514a90688": "",
                    "8456006abb8f4022fd1e25c76e98fe5aa5c3ca": ""
                },
                "60": {
                    "0e2af7e4ddf19b56a9b9a257e862d02ae0e5c7": ""
                },
                "62": {
                    "3a74259ac641f1de53c066fb10414e37986a5c": ""
                },
                "64": {
                    "633c0c03d609aa40af9636c746fba70085fba2": ""
                },
                "65": {
                    "7926ba080127d8722b298257d2547a3a3d9cec": ""
                },
                "6a": {
                    "276e6b7f5f811b5f7109bd3a3df0ab837a9eb4": ""
                },
                "6b": {
                    "5c31b164de07f3c6c1988ca03683d3c03b4890": "",
                    "5f823d1e016ae9680c7384c62362c9843686c4": ""
                },
                "6c": {
                    "96c1559938225b591da8374f300f8ff113c57e": "",
                    "ddc7987df9b190a8490a22e400775681635189": ""
                },
                "71": {
                    "1ea0044293271d3f47129210ddbcab7ec9ca77": ""
                },
                "72": {
                    "06c1b3a2ddafa202bacfe614c9ad2cef6b46e3": ""
                },
                "77": {
                    "215201471bd615c40cee202417679f92c17f53": "",
                    "30a3db657bed3cc48b01bf39fa84a160162ea3": ""
                },
                "78": {
                    "46908a3d0ceb5645ce1448355b0130e4ee0fea": ""
                },
                "79": {
                    "4f3bb10ee7547467b80ad092a4d354b2fb36dd": "",
                    "6470037a8b52ce8c502d73f81c1101da30b2e1": ""
                },
                "7b": {
                    "e854f26cb02b276fe6fdc28cb2bd1ad4a820e6": ""
                },
                "81": {
                    "1478405fc0de3bac2033118f997234ac26efae": ""
                },
                "87": {
                    "b877f86b58d693f1c2df3d4ca8c1695092ec61": ""
                },
                "8a": {
                    "370f06814e109573842c08f2a483b43c21fd8d": ""
                },
                "8b": {
                    "c6450ca0dea119501b96b2f381d030ccc3beae": ""
                },
                "8d": {
                    "93469731cedc1eeee0414b9783ace940ac011f": ""
                },
                "8e": {
                    "569c809b60eceb8ca60d6c2e3a77e03c7be654": ""
                },
                "91": {
                    "2780c439a50ab63f85d059b8aaa19438f50384": ""
                },
                "92": {
                    "7c12fe6afb232a9e2be92c3028a2c6cd89946d": ""
                },
                "93": {
                    "3fd4973c633cb08cff5cd99d0377a5642a8187": ""
                },
                "98": {
                    "7a2201912ff26087a3c604dcfd3136b6124ee0": ""
                },
                "9c": {
                    "9f11effa406e4baa261ff958f238292459c1f6": ""
                },
                "a0": {
                    "76322b1a7eb9a0b0741c07c02ee7a1e6239f4a": "",
                    "bb3526e9e8c51def786895c0df27cfe5c7ae15": ""
                },
                "a1": {
                    "ae5a973332cc58965b9057bc523f731422d40a": ""
                },
                "a3": {
                    "dfd281718c6b2868be08790237a8e61090f86a": ""
                },
                "a5": {
                    "833ba7f30e8c2360736fa17a4d942efc3c1252": "",
                    "8a68b61494c070f39e1531f0e41fe5cf39852f": ""
                },
                "a7": {
                    "9b34ac7fac8b5ced963ca347968c904d3906b8": "",
                    "a1c480681bca03bf8ecb5e2ea56684ddd5811e": ""
                },
                "a8": {
                    "b12254b58bad6e6c392f258406b84b533614bb": ""
                },
                "aa": {
                    "bb601d727438b83b2c246ea0031031bd56d9f6": ""
                },
                "ac": {
                    "4d5ee230fa61edc2e7512abba90516a7d6d2bb": "",
                    "7aaf9f0d06cb9e4bbe048f66c4b55a3ba76d3d": "",
                    "86369cd97172dbc1a9683a882bf03d241217f3": ""
                },
                "ad": {
                    "18a525fb368744b0e818cc3acabaaaec768026": "",
                    "a3cee276ad8dbae0f1600ba966cf2de617e86f": ""
                },
                "b0": {
                    "47242020abba403425bfccf721448d6944316a": ""
                },
                "b3": {
                    "6de1de93bcf6286be14b5472394954f0d2f67c": ""
                },
                "b5": {
                    "9e9d9e75d47d06a0b545fcb8ade1c622b95ae2": ""
                },
                "b6": {
                    "6977c72fa731c486dbc43e4fa534699bf2c6d7": "",
                    "85ea5202c1c402e6fbddd15b45e0a3e9827715": "",
                    "aa1ab999b695fb6cee65701fd962081f2135cd": "",
                    "d1217de421e663b511724474d8ec67bbfaea4c": ""
                },
                "b8": {
                    "1bddeb4cf7d82b5a0c365d0616e7c95d2b01ff": ""
                },
                "ba": {
                    "3029b81e430c8a8c51a07aae53bdbfd4769a5f": ""
                },
                "bb": {
                    "b280070833b78ee2c56711dd983b0dd6ee7db3": ""
                },
                "bc": {
                    "b8386df3e92c4ab4a286db9f07b2b33337f02a": ""
                },
                "bd": {
                    "0e81f8294439922fac950254c20daa854bdf39": ""
                },
                "be": {
                    "dd58b1581067e2c9262e3808ed169ac4c085c6": ""
                },
                "bf": {
                    "655b2ff8e08444d5381a3adef54e16884274a5": ""
                },
                "c2": {
                    "3e196e6c7a30f73c0d2cbedafb30b5e70e67fa": "",
                    "65963490f0baeb8a5159b06a4cbc434622dfe0": ""
                },
                "c3": {
                    "71ab9dfd1046f8b55d80cdd9b60b9876b700dc": "",
                    "ae8152f6327d13d0d983bd80fde6c7fb8e846d": ""
                },
                "c4": {
                    "1be16cac83dfe5a699df33aa50f4457898edb5": "",
                    "4cdf21e9fceb7aad4901c90074c0313027c9af": "",
                    "73c77fec3cff24a08ef5d0a2b1e2d4f48c063a": ""
                },
                "c5": {
                    "e209499d69c31a5b0c5c4ff081ea918f550dd5": ""
                },
                "ca": {
                    "19c61145c72957e5e042904a8017ca46ead9af": ""
                },
                "cb": {
                    "379a4a0012b6786f9bd5017d77540cec9859c1": ""
                },
                "cc": {
                    "09f0b4b881a98a2e7f7ef710d535cfc9ddfb97": "",
                    "5e42c551308bbecd944aaa3b5ffc8cdbc08026": ""
                },
                "cd": {
                    "36200b12e5e026815963e76049ee7042c678fd": ""
                },
                "ce": {
                    "7c03b289334cc8bb3137e4648abdea487bd712": ""
                },
                "d2": {
                    "f70b2d8557aa23c7a12643ada6bec7d74064cd": ""
                },
                "d4": {
                    "7c1995ad840cb0427ad14372d39f535900409d": ""
                },
                "d5": {
                    "616a96d05ab527a84da42a1ad2e69785d9e4a1": "",
                    "9727c049d47002d17866c076ab29811d37ccfd": ""
                },
                "d9": {
                    "623c3fdbe066d5f6a79f89e2baab9540f9e828": ""
                },
                "df": {
                    "3e0490073769d3a896566551cdfc48bc189cfe": "",
                    "3e1471873f0e297aa811ac3e4a7c7fb2850db9": "",
                    "557db8c1cb96b7bf31ae5e680abdc070f2565c": ""
                },
                "e1": {
                    "a8f9eda3fc54ab85a7107ef799d718aaf92a2d": ""
                },
                "e2": {
                    "275ec35b12960a06e73e28036ed3c558f74079": "",
                    "56afc70ae8c037747efc95f6386cd7302379ca": ""
                },
                "e4": {
                    "5a630c3721008b3c3a257590cb2cac9706d4db": "",
                    "7400f91c3160201184cb290da392537c4d23ee": ""
                },
                "e6": {
                    "9de29bb2d1d6434b8b29ae775ad8c2e48c5391": ""
                },
                "e7": {
                    "0ea81fcecf779b5e47428ce1c491b2d55ad752": ""
                },
                "ea": {
                    "3ffe81190b6158b1fc628a259504d508ccc305": "",
                    "c00620f41e6872466a80eb46f5a14c128f2420": ""
                },
                "ec": {
                    "92ca3ddf1332526682f918ae322265e5270e19": ""
                },
                "ed": {
                    "6eab8a7e3f0362b7df2431318aa31fe3e8598b": ""
                },
                "ef": {
                    "79c92c1e5f81d1d4276625ebacc5e70a738045": ""
                },
                "f0": {
                    "223a7ed1d88347951c81613cbbfcec484023f7": ""
                },
                "f1": {
                    "35214dfbdc471e926ba557452b28f0d417f499": "",
                    "c34bf9fe3cd84430d5a2b1052add04801c8fe2": ""
                },
                "f4": {
                    "31949cf6d5e6302c14f9dc4b2ca9eb0c91cc6f": ""
                },
                "f6": {
                    "e51a2fa16e338426b5bfd620044ba6bd1a2007": ""
                },
                "f7": {
                    "66e10dcfde7aa5489e76e1673ff3181e7f81e3": "",
                    "cffac209fcd8c5e02b9282d3bae6c9887f3e86": ""
                },
                "fa": {
                    "7e9b9843fcf0397f35f091cf713960402ea886": "",
                    "9181cf12bbd3fd0d124e68727445ffb764fc7d": ""
                },
                "info": {},
                "pack": {}
            },
            "ORIG_HEAD": "f0223a7ed1d88347951c81613cbbfcec484023f7\n",
            "refs": {
                "heads": {
                    "main": "f0223a7ed1d88347951c81613cbbfcec484023f7\n"
                },
                "remotes": {
                    "origin": {
                        "main": "f0223a7ed1d88347951c81613cbbfcec484023f7\n"
                    }
                },
                "tags": {}
            }
        },
        ".gitignore": ".env\n__pycache__/\n*.pyc\ninstance/\nbackups/*\n.env.local\n",
        ".vscode": {
            "settings.json": "{\n  \"python.testing.unittestArgs\": [\"-v\", \"-s\", \"./tests\", \"-p\", \"test_*.py\"],\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.unittestEnabled\": false,\n  \"python.testing.pytestArgs\": [\"tests\"]\n}\n"
        },
        "docs": {
            "ai_rules_v3.0.md": "<!-- /docs/ai_rules_v3.0.md -->\n\n# AI RULES ‚Äî v3.0\n\n**Reglas oficiales y obligatorias para la IA en el proyecto DemeArizOil**\n\nEste documento define **c√≥mo debe trabajar la IA** en este proyecto.\nNo describe arquitectura ni negocio: **describe el contrato operativo entre t√∫ y la IA**.\n\nSu objetivo es **eliminar invenciones, simplificaciones impl√≠citas y desviaciones**.\n\n---\n\n## 0. Principio rector\n\n> **La IA no es aut√≥noma en este proyecto.**\n> La IA **ejecuta instrucciones bajo contrato**, no interpreta intenciones.\n\nSi algo no est√°:\n\n* documentado\n* autorizado\n* o expl√≠citamente pedido\n\nüëâ **la IA debe parar y preguntar**.\n\n---\n\n## 1. Documentos fuente obligatorios\n\nLa IA **debe cumplir estrictamente**:\n\n1. `architecture_v3.0.md`\n2. `ai_rules_v3.0.md`\n\nCuando exista conflicto:\n\n* **architecture_v3.0.md tiene prioridad t√©cnica**\n* **ai_rules_v3.0.md tiene prioridad operativa**\n\nLa IA **no puede**:\n\n* contradecirlos\n* reinterpretarlos\n* ‚Äúmejorarlos‚Äù sin permiso\n\n---\n\n## 2. Modos de trabajo (OBLIGATORIOS)\n\nLa IA **solo puede trabajar** si uno de estos modos est√° activo.\nSi el usuario no lo indica expl√≠citamente ‚Üí **la IA debe parar y pedirlo**.\n\n---\n\n### üîí MODO 1 ‚Äî DOCUMENTACI√ìN COMO LEY\n\n**Uso**\nRevisi√≥n, alineaci√≥n o verificaci√≥n de documentos existentes.\n\n**Reglas absolutas**\n\n1. ‚ùå No crear nada nuevo.\n2. ‚ùå No eliminar nada existente.\n3. ‚ùå No renombrar nada.\n4. ‚ùå No simplificar nada.\n5. ‚úÖ Solo:\n\n   * detectar incoherencias\n   * se√±alar contradicciones\n   * proponer **correcciones documentales**, no de c√≥digo\n6. Si algo no est√° documentado ‚Üí **se marca como hueco**, no se inventa.\n\n**Frase de activaci√≥n obligatoria**\n\n> ‚ÄúModo documentaci√≥n como ley. No inventes nada.‚Äù\n\n---\n\n### üß© MODO 2 ‚Äî ADAPTAR A MODELOS EXISTENTES\n\n**Uso**\nCuando los models ya existen y hay que alinear documentaci√≥n o l√≥gica auxiliar.\n\n**Reglas**\n\n1. Los **models actuales mandan**.\n2. ‚ùå No crear campos nuevos.\n3. ‚ùå No cambiar reglas de negocio.\n4. ‚ùå No introducir nuevas entidades.\n5. ‚úÖ Solo se puede modificar:\n\n   * documentaci√≥n\n   * helpers (utils)\n6. Si una regla no puede cumplirse con los models actuales ‚Üí **se se√±ala el conflicto**.\n\n**Frase de activaci√≥n**\n\n> ‚ÄúModo adaptar a modelos existentes. No inventes campos ni reglas.‚Äù\n\n---\n\n### üõ†Ô∏è MODO 3 ‚Äî CAMBIO CONTROLADO\n\n**Uso**\nCuando **s√≠** se quiere cambiar comportamiento, estructura o reglas.\n\n**Reglas**\n\n1. **Todo cambio debe enumerarse**.\n2. Cada cambio debe indicar:\n\n   * documento afectado\n   * punto exacto\n   * motivo\n3. ‚ùå Nada impl√≠cito.\n4. ‚ùå Nada autom√°tico.\n5. La IA **no puede aplicar cambios no enumerados**.\n\n**Frase de activaci√≥n**\n\n> ‚ÄúModo cambio controlado. Enumera cada modificaci√≥n.‚Äù\n\n---\n\n## 3. Regla cr√≠tica de parada\n\nSi la IA detecta **cualquiera** de los siguientes casos:\n\n* Falta de contexto\n* Ambig√ºedad sem√°ntica\n* Posible invenci√≥n\n* Conflicto entre documentos\n* Inconsistencia con `architecture_v3.0.md`\n\nüëâ **DEBE PARAR Y PREGUNTAR**.\nContinuar ser√≠a una violaci√≥n del contrato.\n\n---\n\n## 4. Prohibiciones absolutas\n\nLa IA **NO PUEDE**:\n\n1. Inventar modelos, campos o relaciones.\n2. Simplificar capas (‚Äúesto se puede quitar‚Äù).\n3. Fusionar services, controllers o routers.\n4. Persistir movimientos.\n5. Introducir repositorios, schemas o migraciones.\n6. Reordenar carpetas por criterio propio.\n7. Cambiar naming rules.\n8. Proponer alternativas tecnol√≥gicas.\n9. Ejecutar l√≥gica de negocio fuera de services.\n10. ‚ÄúArreglar‚Äù arquitectura sin modo activo.\n\n---\n\n## 5. Arquitectura (recordatorio obligatorio)\n\nLa IA debe respetar siempre:\n\n* Entidades / Aggregates / Documentos ‚Üí persistentes\n* Movimientos ‚Üí **NO persistentes**\n* CRUD obligatorio para Entidades, Aggregates y Documentos\n* Stack obligatorio:\n\n  * model\n  * service\n  * controller\n  * router\n* Plantillas:\n\n  * Base + Extensi√≥n obligatorias\n  * Especial solo cuando aplica\n\nCualquier desviaci√≥n ‚Üí **parar**.\n\n---\n\n## 6. Generaci√≥n de archivos (FORMATO OBLIGATORIO)\n\nSiempre que la IA entregue:\n\n- un documento\n- un archivo de c√≥digo\n- una especificaci√≥n t√©cnica\n\nDebe **envolver el contenido completo** con comentarios que indiquen\n**ruta completa y nombre del archivo**, **adaptados al lenguaje del archivo**.\n\n### Formato general\n\nLa primera y la √∫ltima l√≠nea **deben indicar exactamente la misma ruta**.\n\nNo puede haber contenido fuera de esos comentarios.\n\n---\n\n### Ejemplos v√°lidos\n\n#### Markdown / HTML\n\n```\n\n<!-- /docs/architecture_v3.0.md -->\n\n[contenido completo]\n\n<!-- /docs/architecture_v3.0.md -->\n\n```\n\n---\n\n#### Python\n\n```\n\n# /src/app/services/products_service.py\n\n[contenido completo]\n\n# /src/app/services/products_service.py\n\n```\n\n---\n\n#### JavaScript / TypeScript\n\n```\n\n// /src/app/frontend/store/products.ts\n[contenido completo]\n// /src/app/frontend/store/products.ts\n\n```\n\n---\n\n#### YAML / Docker / Configuraci√≥n\n\n```\n\n# /docker-compose.yml\n\n[contenido completo]\n\n# /docker-compose.yml\n\n```\n\n---\n\n### Reglas estrictas\n\n1. El comentario superior y el inferior **deben coincidir exactamente**.\n2. El comentario superior debe ser **la primera l√≠nea** del archivo.\n3. El comentario inferior debe ser **la √∫ltima l√≠nea** del archivo.\n4. No puede haber **ning√∫n contenido fuera** de esos dos comentarios.\n5. Si el usuario no indica ruta:\n   - la IA **debe pedirla**\n   - o inferirla solo si la arquitectura lo hace inequ√≠voco.\n6. Entregar c√≥digo o documentos sin este encapsulado **est√° prohibido**.\n\n---\n\n## 7. Plantillas y contratos\n\nSi existe:\n\n* plantilla base\n* plantilla extensi√≥n\n* plantilla especial\n\nLa IA:\n\n* **debe usarlas**\n* **no puede desviarse**\n* **no puede simplificarlas**\n\nSi una plantilla no cubre un caso:\nüëâ **parar y pedir definici√≥n**, no improvisar.\n\n---\n\n## 8. Testing\n\nLa IA debe respetar el est√°ndar definido en arquitectura:\n\n* Tests de services\n* Tests de endpoints\n* Tests de flujos\n\nNo exigir m√°s.\nNo proponer menos.\n\n---\n\n## 9. Versiones y tipado\n\nLa IA debe asumir siempre:\n\n* Python tipado\n* Librer√≠as estables o LTS\n* Nada experimental\n\nSi una versi√≥n no est√° definida:\nüëâ **no asumir**, preguntar.\n\n---\n\n## 10. Objetivo final de estas reglas\n\nEstas reglas existen para:\n\n1. Evitar invenciones.\n2. Evitar simplificaciones destructivas.\n3. Evitar reprocesos.\n4. Convertir a la IA en una **herramienta predecible**.\n5. Permitir trabajar de forma iterativa **sin romper el sistema**.\n\n---\n\n## 11. Regla final (inapelable)\n\n> **Si no est√° claro, no contin√∫es. Pregunta.**\n\n---\n\n**FIN DEL DOCUMENTO**\n\n<!-- /docs/ai_rules_v3.0.md -->",
            "API_ENDPOINTS.md": "# API Endpoints ‚Äî Frontend Guide\n\nPrefijo base: `settings.API_PREFIX` (por defecto `/api`).\n\nTodas las rutas requieren JWT (`Authorization: Bearer <access_token>`) salvo:\n\n- `GET /`\n- `POST /api/auth/login`\n- `POST /api/auth/refresh`\n\nFormato de error:\n\n```json\n{\n  \"error\": \"ErrorName\",\n  \"message\": \"Detalle legible\"\n}\n```\n\n## Convenciones CRUD\n\nPara recursos CRUD est√°ndar:\n\n- `GET /resource/` ‚Üí lista de activos\n- `GET /resource/<id>` ‚Üí detalle\n- `POST /resource/` ‚Üí create (201)\n- `PUT /resource/<id>` ‚Üí update (200)\n- `DELETE /resource/<id>` ‚Üí soft delete (200)\n- `POST /resource/<id>/restore` ‚Üí restore (200)\n\nLas respuestas de √©xito devuelven el objeto serializado.\n\n## Auth\n\n### POST `/api/auth/login`\n\nBody:\n\n```json\n{ \"username\": \"admin\", \"password\": \"admin123\" }\n```\n\nRespuesta (200):\n\n```json\n{ \"access_token\": \"...\", \"refresh_token\": \"...\" }\n```\n\n### POST `/api/auth/refresh`\n\nHeader:\n`Authorization: Bearer <refresh_token>`\nRespuesta (200):\n\n```json\n{ \"access_token\": \"...\", \"refresh_token\": \"...\" }\n```\n\n### GET `/api/auth/me`\n\nRespuesta (200): datos del usuario autenticado.\n\n## Users\n\nCreate (`POST /api/users/`) requiere:\n\n```json\n{ \"username\": \"...\", \"password\": \"...\", \"rol\": \"ADMIN\", \"email\": \"...\" }\n```\n\nSalida incluye campos base + `username`, `email`, `rol`, `user_language`, `user_theme`, `last_login`, `password_changed_at`.\n\n## Products\n\nCreate (`POST /api/products/`) requiere:\n\n```json\n{ \"name\": \"...\", \"unit_measure\": \"ud\", \"is_inventory\": true }\n```\n\nSalida incluye `name`, `unit_measure`, `is_inventory`, `cost_average`.\n\n## Customers\n\nCreate (`POST /api/customers/`) requiere:\n\n```json\n{ \"name\": \"...\", \"phone\": \"...\", \"email\": \"...\", \"address\": \"...\" }\n```\n\nSalida incluye datos del cliente. Crea autom√°ticamente su `StockLocation` con nombre `customer_{id}_stock`.\n\n## Suppliers\n\nCreate (`POST /api/suppliers/`) requiere:\n\n```json\n{ \"name\": \"...\", \"phone\": \"...\", \"email\": \"...\", \"address\": \"...\" }\n```\n\nSalida incluye datos del proveedor. Crea autom√°ticamente su `CashAccount` con nombre `supplier_{id}_cash`.\n\n## Purchase Notes (albaranes de compra)\n\nCreate DRAFT (`POST /api/purchase_notes/`) requiere:\n\n```json\n{ \"supplier_id\": 1, \"date\": \"YYYY-MM-DD\", \"paid_amount\": 0 }\n```\n\nL√≠neas (`POST /api/purchase_notes/<id>/lines`) requiere:\n\n```json\n{ \"product_id\": 1, \"quantity\": 10, \"unit_price\": 100, \"total_price\": 1000 }\n```\n\nConfirmar (`POST /api/purchase_notes/<id>/confirm`): sin body.\n\nSalida incluye `supplier_id`, `date`, `status`, `total_amount`, `paid_amount`.\n\n## Sales Notes (albaranes de venta)\n\nCreate DRAFT (`POST /api/sales_notes/`) requiere:\n\n```json\n{ \"customer_id\": 1, \"date\": \"YYYY-MM-DD\", \"paid_amount\": 0 }\n```\n\nL√≠neas (`POST /api/sales_notes/<id>/lines`) requiere:\n\n```json\n{ \"product_id\": 1, \"quantity\": 7, \"unit_price\": 300, \"total_price\": 2100 }\n```\n\nConfirmar (`POST /api/sales_notes/<id>/confirm`): sin body.\n\nSalida incluye `customer_id`, `date`, `status`, `total_amount`, `paid_amount`.\n\n## Stock Locations\n\nCreate (`POST /api/stock_locations/`) requiere:\n\n```json\n{ \"name\": \"custom_location\" }\n```\n\nNo se permite crear manualmente `DEME_STOCK`.\n\n## Stock Product Locations\n\nCreate (`POST /api/stock_product_locations/`) requiere:\n\n```json\n{ \"product_id\": 1, \"stock_location_id\": 1, \"quantity\": 0 }\n```\n\nSalida incluye `product_id`, `stock_location_id`, `quantity`.\n\n## Stock Deposit Notes\n\nCreate (`POST /api/stock_deposit_notes/`) requiere:\n\n```json\n{\n  \"from_stock_location_id\": 1,\n  \"to_stock_location_id\": 2,\n  \"product_id\": 1,\n  \"quantity\": 5,\n  \"date\": \"YYYY-MM-DD\",\n  \"notes\": \"...\"\n}\n```\n\nConfirmar (`POST /api/stock_deposit_notes/<id>/confirm`): sin body.\n\nSalida incluye `from_stock_location_id`, `to_stock_location_id`, `product_id`, `quantity`, `date`, `status`, `notes`.\n\n## Cash Accounts\n\nCreate (`POST /api/cash_accounts/`) requiere:\n\n```json\n{ \"name\": \"custom_cash\", \"balance\": 0 }\n```\n\nSalida incluye `name`, `balance`.\n\n## Cash Transfer Notes\n\nCreate (`POST /api/cash_transfer_notes/`) requiere:\n\n```json\n{\n  \"from_cash_account_id\": 1,\n  \"to_cash_account_id\": 2,\n  \"amount\": 500,\n  \"date\": \"YYYY-MM-DD\",\n  \"notes\": \"...\"\n}\n```\n\nConfirmar (`POST /api/cash_transfer_notes/<id>/confirm`): sin body.\n\nSalida incluye `from_cash_account_id`, `to_cash_account_id`, `amount`, `date`, `status`, `notes`.\n\n## Backup\n\n### GET `/api/backup`\n\nDescarga un archivo `backup.sqlite3`.\n\n### POST `/api/backup`\n\nMultipart form con campo `file`. Restaura la base de datos.\n\n### Deployment https://demeoil.pythonanywhere.com\n",
            "architecture_v3.0.md": "<!-- /docs/architecture_v3.0.md -->\n\n# ARCHITECTURE ‚Äî v3.0\n\n**DemeArizOil Backend (Flask + SQLite)**\n\nDocumento **interno, normativo y ejecutable**.\nDefine **organizaci√≥n t√©cnica**, **contratos por capa**, **m√©todos/funciones obligatorias** y **estructura de m√≥dulos**, sin describir reglas de negocio.\n\n- **Schema** ‚Üí `models_schema_v3.0.md`\n- **Business logic** ‚Üí `business_logic_v3.0.md`\n- **Reglas IA** ‚Üí `ai_rules_v3.0.md`\n\n---\n\n## 0. Convenciones obligatorias\n\n### 0.1 Naming (ley)\n\n- **Models**: archivo y clase en **singular**; tablas en **plural**.\n- **Services / Controllers / Routers**: archivo e instancia en **plural**.\n- L√≠neas: `{document}_line` (ej.: `purchase_notes_line`, `sales_notes_line`).\n\n### 0.2 Capas (ley)\n\n```\nRouter (Blueprint / HTTP)\n        ‚Üì\nController (orquestaci√≥n HTTP)\n        ‚Üì\nService (l√≥gica de negocio)\n        ‚Üì\nModel (persistencia / estado)\n```\n\n---\n\n## 1. Estructura de carpetas oficial (v3.0)\n\n```\nsrc/app/\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îú‚îÄ‚îÄ api_router.py\n‚îÇ   ‚îî‚îÄ‚îÄ routers/\n‚îÇ       ‚îú‚îÄ‚îÄ base_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ auth_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ users_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ products_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ customers_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ suppliers_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ stock_locations_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ stock_product_locations_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ cash_accounts_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ purchase_notes_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ purchase_notes_line_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ sales_notes_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ sales_notes_line_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ stock_deposits_router.py\n‚îÇ       ‚îú‚îÄ‚îÄ cash_transfers_router.py\n‚îÇ       ‚îî‚îÄ‚îÄ backup_router.py\n‚îÇ\n‚îú‚îÄ‚îÄ controllers/\n‚îÇ   ‚îú‚îÄ‚îÄ base_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ auth_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ users_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ products_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ customers_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ suppliers_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_locations_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_product_locations_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ cash_accounts_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ purchase_notes_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ purchase_notes_line_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ sales_notes_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ sales_notes_line_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_deposits_controller.py\n‚îÇ   ‚îú‚îÄ‚îÄ cash_transfers_controller.py\n‚îÇ   ‚îî‚îÄ‚îÄ backup_controller.py\n‚îÇ\n‚îú‚îÄ‚îÄ services/\n‚îÇ   ‚îú‚îÄ‚îÄ base_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ auth_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ users_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ products_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ customers_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ suppliers_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_locations_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_product_locations_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ cash_accounts_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ purchase_notes_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ purchase_notes_line_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ sales_notes_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ sales_notes_line_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_deposits_service.py\n‚îÇ   ‚îú‚îÄ‚îÄ cash_transfers_service.py\n‚îÇ   ‚îî‚îÄ‚îÄ backup_service.py\n‚îÇ\n‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îú‚îÄ‚îÄ base_model.py\n‚îÇ   ‚îú‚îÄ‚îÄ user.py\n‚îÇ   ‚îú‚îÄ‚îÄ product.py\n‚îÇ   ‚îú‚îÄ‚îÄ customer.py\n‚îÇ   ‚îú‚îÄ‚îÄ supplier.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_location.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_product_location.py\n‚îÇ   ‚îú‚îÄ‚îÄ cash_account.py\n‚îÇ   ‚îú‚îÄ‚îÄ purchase_note.py\n‚îÇ   ‚îú‚îÄ‚îÄ purchase_note_line.py\n‚îÇ   ‚îú‚îÄ‚îÄ sales_note.py\n‚îÇ   ‚îú‚îÄ‚îÄ sales_note_line.py\n‚îÇ   ‚îú‚îÄ‚îÄ stock_deposit_note.py\n‚îÇ   ‚îî‚îÄ‚îÄ cash_transfer_note.py\n‚îÇ\n‚îú‚îÄ‚îÄ core/\n‚îÇ   ‚îú‚îÄ‚îÄ config/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ settings.py\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database.py\n‚îÇ   ‚îú‚îÄ‚îÄ enum.py\n‚îÇ   ‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ datetime_utils.py\n‚îÇ   ‚îú‚îÄ‚îÄ exceptions/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ handlers.py\n‚îÇ   ‚îî‚îÄ‚îÄ logging/\n‚îÇ       ‚îî‚îÄ‚îÄ logger.py\n‚îÇ\n‚îú‚îÄ‚îÄ security/\n‚îÇ   ‚îú‚îÄ‚îÄ jwt.py\n‚îÇ   ‚îú‚îÄ‚îÄ middleware.py\n‚îÇ   ‚îú‚îÄ‚îÄ password.py\n‚îÇ   ‚îú‚îÄ‚îÄ cors.py\n‚îÇ   ‚îî‚îÄ‚îÄ email.py\n‚îÇ\n‚îú‚îÄ‚îÄ db/\n‚îÇ   ‚îî‚îÄ‚îÄ database.db\n‚îÇ\n‚îî‚îÄ‚îÄ tests/\n    ‚îú‚îÄ‚îÄ test_users.py\n    ‚îú‚îÄ‚îÄ test_products.py\n    ‚îú‚îÄ‚îÄ test_customers.py\n    ‚îú‚îÄ‚îÄ test_suppliers.py\n    ‚îú‚îÄ‚îÄ test_stock_locations.py\n    ‚îú‚îÄ‚îÄ test_stock_product_locations.py\n    ‚îú‚îÄ‚îÄ test_cash_accounts.py\n    ‚îú‚îÄ‚îÄ test_purchase_notes.py\n    ‚îú‚îÄ‚îÄ test_sales_notes.py\n    ‚îú‚îÄ‚îÄ test_stock_deposits.py\n    ‚îú‚îÄ‚îÄ test_cash_transfers.py\n    ‚îî‚îÄ‚îÄ test_full_flow.py\n```\n\n---\n\n## 2. Contratos por capa\n\n### 2.1 Models\n\n- Contienen: estructura de datos, ORM, `to_dict()`.\n- No contienen: l√≥gica de negocio, decisiones, transacciones.\n\n### 2.2 Services\n\n- Contienen: **toda** la l√≥gica de negocio, validaciones, transacciones, efectos (stock/cash).\n- No contienen: HTTP, Blueprints, serializaci√≥n de respuesta final.\n\n### 2.3 Controllers\n\n- Contienen: lectura de request, llamada a service, serializaci√≥n v√≠a `to_dict()`, c√≥digos de estado, errores.\n- No contienen: decisiones de negocio, ORM directo.\n\n### 2.4 Routers / API\n\n- Contienen: definici√≥n de endpoints (paths + verbs) y binding a controller.\n- No contienen: l√≥gica de negocio, validaciones de negocio.\n\n---\n\ncomo te he pasado en el controller\n\n## 4. Routers ‚Äî cat√°logo por categor√≠as\n\n### 4.0 Categor√≠a 0 ‚Äî Base\n\n#### `BaseRouter`\n\n**Responsabilidad:** registrar rutas CRUD est√°ndar para un controller CRUD.\n\n**Convenci√≥n de Blueprint:**\n\n- `bp = Blueprint(\"<resource>\", __name__, url_prefix=\"/<resource>\")`\n\n**Rutas CRUD est√°ndar:**\n\n- `GET    /` ‚Üí `controller.get_all`\n- `GET    /<int:id>` ‚Üí `controller.get_by_id`\n- `POST   /` ‚Üí `controller.create`\n- `PUT    /<int:id>` ‚Üí `controller.update`\n- `DELETE /<int:id>` ‚Üí `controller.delete`\n- `POST   /<int:id>/restore` ‚Üí `controller.restore`\n\n---\n\n### 4.1 Categor√≠a 1 ‚Äî Extienden Base (solo CRUD)\n\nRouters que se limitan al CRUD est√°ndar:\n\n- `users_router`\n- `products_router`\n- `customers_router`\n- `suppliers_router`\n- `stock_locations_router`\n- `stock_product_locations_router`\n- `cash_accounts_router`\n- `stock_deposits_router`\n- `cash_transfers_router`\n\n---\n\n### 4.2 Categor√≠a 2 ‚Äî Extienden Base y a√±aden rutas\n\nRouters CRUD que a√±aden endpoints extra adem√°s del CRUD:\n\n- `purchase_notes_router`\n  - `POST /confirm` ‚Üí `PurchaseNotesController.confirm`\n\n- `sales_notes_router`\n  - `POST /confirm` ‚Üí `SalesNotesController.confirm`\n\n- `purchase_notes_line_router`\n  - `POST   /<int:purchase_note_id>/lines` ‚Üí `create_line`\n  - `GET    /<int:purchase_note_id>/lines` ‚Üí `get_lines`\n  - `DELETE /lines/<int:line_id>` ‚Üí `delete_line`\n\n- `sales_notes_line_router`\n  - `POST   /<int:sales_note_id>/lines` ‚Üí `create_line`\n  - `GET    /<int:sales_note_id>/lines` ‚Üí `get_lines`\n  - `DELETE /lines/<int:line_id>` ‚Üí `delete_line`\n\n---\n\n### 4.3 Categor√≠a 3 ‚Äî No siguen Base\n\nRouters especiales que no usan `BaseRouter`:\n\n- `auth_router`\n  - `POST /auth/login`\n  - `POST /auth/refresh`\n  - `GET  /auth/me`\n\n- `stock_movements_router`\n  - `POST /stock_movements/transfer`\n  - `POST /stock_movements/adjust`\n\n- `cash_movements_router`\n  - `POST /cash_movements/transfer` _(o la lista exacta de endpoints que defin√°is en plantilla)_\n\n- `backup_router`\n  - `GET  /backup` ‚Üí export\n  - `POST /backup` ‚Üí restore\n\n---\n\n## 5. `api_router.py` (ensamblaje HTTP)\n\n**Responsabilidad √∫nica:**\n\n- Registrar todos los Blueprints\n- Aplicar prefijo com√∫n (por ejemplo `/api`)\n\n**Reglas:**\n\n- No contiene l√≥gica\n- No contiene validaciones\n- No instancia services\n- Solo importa routers y registra blueprints\n\n---\n\n## 6. Core ‚Äî detalle por subm√≥dulo\n\n### 6.1 `core/config`\n\n**Contiene:**\n\n- `settings.py`: configuraci√≥n no secreta (constantes y defaults seguros).\n- `database.py`: configuraci√≥n y helpers de sesi√≥n/engine (si est√° centralizado aqu√≠).\n\n**No contiene:**\n\n- secretos (van en `.env`)\n- l√≥gica de negocio\n\n### 6.2 `core/enum.py`\n\n**Contiene:**\n\n- Un √∫nico archivo con los enum can√≥nicos del dominio usados por models y services.\n- Incluye (m√≠nimo):\n  - `UserRole`\n  - `DocumentStatus`\n  - `StockMovementType`\n\n**Reglas:**\n\n- Prohibido usar strings m√°gicos fuera de enum.\n- enum se importan desde `core/enum.py`, no desde `models`.\n\n### 6.3 `core/utils`\n\n**Contiene:**\n\n- utilidades puras sin estado ni efectos colaterales.\n- `datetime_utils` (formato can√≥nico de fechas, conversiones, helpers).\n\n**Reglas:**\n\n- No acceso a BD\n- No dependencias de Flask request context\n- Se puede usar desde cualquier capa\n\n### 6.4 `core/exceptions`\n\n**Contiene:**\n\n- excepciones base (BadRequest, Forbidden, NotFound, etc.)\n- handlers para convertir excepciones a respuestas HTTP (si aplica)\n\n**Reglas:**\n\n- Las excepciones de negocio se disparan desde services\n- Los controllers las capturan o delegan en handlers\n\n### 6.5 `core/logging` ‚úÖ\n\n**Contiene:**\n\n- `logger.py` con configuraci√≥n est√°ndar:\n  - formatter\n  - handlers (console, opcional file)\n  - niveles por entorno\n  - helper `get_logger(__name__)`\n\n**Reglas:**\n\n- Logging usable desde cualquier capa\n- No contiene l√≥gica de negocio\n- No accede a BD\n\n---\n\n## 7. DB ‚Äî detalle\n\n### `db/`\n\n**Contiene:**\n\n- archivo SQLite (`database.db`) en dev\n- (opcional) utilidades m√≠nimas de inicializaci√≥n si el proyecto las mantiene aqu√≠\n\n**Reglas:**\n\n- No contiene models\n- No contiene l√≥gica de negocio\n- La sesi√≥n/engine se exponen desde `core/config/database.py` (si ese es el punto √∫nico)\n\n---\n\n## 8. Security ‚Äî detalle\n\n### 8.1 `security/jwt.py`\n\n**Contiene:**\n\n- creaci√≥n/validaci√≥n de tokens\n- claims est√°ndar del proyecto\n- invalidaci√≥n por `password_changed_at` (si el sistema lo usa)\n\n### 8.2 `security/password.py`\n\n**Contiene:**\n\n- hashing\n- verify\n- par√°metros de seguridad (cost, salt, etc.)\n\n### 8.3 `security/middleware.py`\n\n**Contiene:**\n\n- verificaci√≥n de JWT para rutas protegidas\n- inyecci√≥n de usuario en contexto (por ejemplo `g.user`)\n\n### 8.4 `security/cors.py`\n\n**Contiene:**\n\n- configuraci√≥n CORS del backend\n\n### 8.5 `security/email.py`\n\n**Contiene:**\n\n- helpers relacionados con email (si aplica)\n- nunca secretos hardcodeados\n\n**Reglas globales de security:**\n\n- No contiene reglas de negocio (compras/ventas/deudas)\n- Solo autenticaci√≥n, autorizaci√≥n y utilidades de seguridad\n\n---\n\n## 9. Testing (m√≠nimo obligatorio)\n\n- Tests de services\n- Tests de endpoints\n- Tests de flujos\n\n---\n\n## 10. L√≠mites expl√≠citos\n\nEl sistema **NO**:\n\n- persiste movimientos\n- duplica estado\n- ejecuta negocio fuera de services\n- define endpoints impl√≠citos\n- rompe naming rules\n\n---\n\n## 11. Cierre\n\nEste documento deja cerrado:\n\n- responsabilidades por capa\n- contratos de controllers/routers\n- categor√≠as (Base / Extiende / Extiende+extra / Especiales)\n- detalle de `core`, `db`, `security`\n\nLas reglas de negocio viven en `business_logic_v3.0.md`.\n\n---\n\n**FIN DEL DOCUMENTO**\n\n<!-- /docs/architecture_v3.0.md -->\n",
            "business_logic_v3.0.md": "<!-- /docs/business_logic_v3.0.md -->\n\n# BUSINESS LOGIC ‚Äî v3.0\n\n**DemeArizOil Backend**\n\nDocumento **normativo** que define **el comportamiento del sistema** ante cada acci√≥n de negocio.\nDescribe **qu√© ocurre** cuando se ejecutan operaciones, no c√≥mo se implementan.\n\nEst√° alineado estrictamente con:\n\n- `architecture_v3.0.md`\n- `models_schema_v3.0.md`\n\nCualquier cambio requiere **Modo cambio controlado**.\n\n---\n\n## 1. Principios generales\n\n1. El **estado actual** vive en Aggregates.\n2. La **trazabilidad hist√≥rica** vive en Documentos.\n3. Los **Movimientos**:\n\n   - ejecutan cambios\n   - **no se persisten**\n\n4. No existe deuda fuera de `CashAccount`.\n5. Todo Documento confirmado es **idempotente**.\n6. Los Documentos son **flexibles**; la sem√°ntica se define por su uso, no por su tipo t√©cnico.\n\n---\n\n## 2. Compra ‚Äî PurchaseNote\n\n### 2.1 Alcance del documento\n\n`PurchaseNote` representa **exclusivamente**:\n\n- La entrada de stock\n- El **pago inicial**, si existe\n- La generaci√≥n de deuda, si existe\n\nLa `PurchaseNote` **no gestiona pagos posteriores**.\n\n---\n\n### 2.2 Confirmaci√≥n de PurchaseNote\n\nAl confirmar una `PurchaseNote` se ejecutan, en una **√∫nica transacci√≥n**, las siguientes acciones:\n\n---\n\n### Stock\n\n- Entra stock en el `StockLocation` correspondiente.\n- Se actualizan las filas `StockProductLocation`.\n\n---\n\n### Cash y deuda con proveedor\n\nDefiniciones:\n\n```\npending = total_amount - paid_amount\n```\n\nAcciones:\n\n1. Si `paid_amount > 0`:\n\n   - Sale cash de la cuenta de la empresa por `paid_amount`.\n\n2. Si `pending > 0`:\n\n   - Se **incrementa la deuda** con el proveedor:\n\n     ```\n     supplier.cash_account.balance -= pending\n     ```\n\nNotas importantes:\n\n- El balance del supplier:\n\n  - es acumulativo\n  - puede ser negativo\n  - nunca se sobreescribe\n\n- La deuda **no se persiste en el documento**.\n- La PurchaseNote **termina aqu√≠**: stock + pago inicial + deuda.\n\n---\n\n## 3. Movimientos de cash ‚Äî CashTransferNotes\n\n### 3.1 Naturaleza del documento\n\n`CashTransferNotes` es un **documento gen√©rico y flexible** de movimiento de efectivo.\n\nSe utiliza para:\n\n- Pago de deudas a proveedores\n- Transferencias internas entre cuentas\n- Otros pagos no ligados a producto\n- Ajustes de efectivo\n\nEl backend **no distingue tipos funcionales** de `CashTransferNotes`.\nLa sem√°ntica concreta se define por:\n\n- las cuentas origen/destino\n- el importe\n- la nota descriptiva (`notes`)\n\n---\n\n### 3.2 Confirmaci√≥n de CashTransferNotes\n\nAl confirmar un `CashTransferNotes`:\n\n- from: `CashAccount` origen\n- to: `CashAccount` destino\n- amount > 0\n\nAcciones:\n\n```\nfrom.balance -= amount\nto.balance   += amount\n```\n\nNotas:\n\n- Si el destino es un supplier:\n\n  - el pago **reduce deuda**\n\n- Si el destino no es un supplier:\n\n  - se trata de un pago o transferencia normal\n\n- El documento es **independiente** de cualquier `PurchaseNote`.\n\n---\n\n### 3.3 Pago de deudas a proveedores (uso habitual)\n\nConvenci√≥n de uso (no t√©cnica):\n\n- En frontend existir√° una pantalla espec√≠fica para pagar deudas.\n- En backend:\n\n  - se usa el mismo `CashTransferNotes`\n  - se a√±ade una nota, por ejemplo:\n\n    > ‚ÄúLiquidaci√≥n de deudas a fecha DD/MM/YYYY‚Äù\n\nNo existe relaci√≥n estructural entre:\n\n- `CashTransferNotes`\n- `PurchaseNote`\n\nLa relaci√≥n es **contable**, no documental.\n\n---\n\n## 4. Venta ‚Äî SalesNote\n\n### 4.1 Principio clave\n\n> **Solo se vende lo que se paga.**\n\nPor tanto:\n\n- `SalesNote.total_amount == SalesNote.paid_amount`\n- El stock no pagado **no forma parte de la venta**.\n\n---\n\n### 4.2 Confirmaci√≥n de SalesNote\n\nAl confirmar una `SalesNote`:\n\n---\n\n### Stock\n\n1. Se intenta cubrir la venta desde el **stock depositado del cliente**.\n\n2. Si no es suficiente:\n\n   - se realiza un movimiento adicional desde `DEME_STOCK`.\n\n3. Si la cantidad solicitada **excede la cantidad pagada**:\n\n   - la parte no pagada:\n\n     - **no se vende**\n     - queda como **stock en dep√≥sito**\n     - no genera cash\n     - no forma parte del documento de venta\n\n---\n\n### Cash\n\n- Entra cash en la cuenta de la empresa por `paid_amount`.\n- No se generan deudas al cliente.\n\n---\n\n## 5. Dep√≥sito de stock ‚Äî StockDepositNotes\n\n### 5.1 Confirmaci√≥n de StockDepositNotes\n\n- Mueve stock entre ubicaciones:\n\n  - de empresa ‚Üí cliente\n\n- No cambia la propiedad del stock.\n- No genera cash.\n- Solo ejecuta movimientos de stock.\n\n---\n\n## 6. Reglas expl√≠citas (ley)\n\n1. Nunca se adelanta dinero a suppliers.\n2. Las deudas:\n\n   - viven **solo** en `CashAccount`\n   - nunca se persisten en documentos\n\n3. `PurchaseNote`:\n\n   - genera deuda\n   - **no** la liquida\n\n4. `CashTransferNotes`:\n\n   - es independiente\n   - puede usarse para m√∫ltiples finalidades\n\n5. No se recalcula estado desde hist√≥ricos.\n6. Los movimientos:\n\n   - no se persisten\n   - no se auditan\n\n7. Todo Documento confirmado:\n\n   - se ejecuta una sola vez\n   - no puede volver a ejecutarse\n\n---\n\n## 7. Cierre\n\nEste documento define **el comportamiento completo del sistema**, sin ambig√ºedades.\n\nEl siguiente paso del flujo es:\n\nüëâ **Plantillas Base / Extensi√≥n de models, services, controllers y routers**\n\n---\n\n**FIN DEL DOCUMENTO**\n\n<!-- /docs/business_logic_v3.0.md -->\n",
            "models_schema_v3.0.md": "<!-- /docs/models_schema_v3.0.md -->\n\n# MODELS & DATABASE SCHEMA ‚Äî v3.0\n\n**DemeArizOil Backend**\n\nDocumento **normativo y exhaustivo** que define **la estructura real de la base de datos** del proyecto, alineado con:\n\n- `architecture_v3.0.md`\n- `business_logic_v3.0.md`\n- decisiones cerradas de dominio (deudas v√≠a CashAccount, simplicidad estructural)\n\nNo introduce reglas nuevas.\nCualquier modificaci√≥n requiere **Modo cambio controlado**.\n\n---\n\n## 0. BaseModel (heredado por TODOS los models persistentes)\n\nTodos los models heredan de `BaseModel`.\n\n### Campos comunes\n\n- `id`: int, PK\n- `created_at`: datetime, not null\n- `updated_at`: datetime, not null\n- `deleted_at`: datetime | null\n- `is_active`: bool, default true\n- `created_by`: int | null (FK `users.id`)\n- `updated_by`: int | null (FK `users.id`)\n\n### M√©todos\n\n- `to_dict()`:\n  Devuelve exclusivamente:\n\n  - `id`\n  - campos de auditor√≠a\n  - `is_active`\n\nCada model **extiende** este m√©todo para la serializaci√≥n usada por los controllers.\n\n---\n\n## 1. enum DE DOMINIO (fuente √∫nica de verdad)\n\nLos enum **NO viven en models**.\nViven en `src/app/core/enum/` y son usados por models y services.\n\nenum definidos:\n\n- `UserRole`: `ADMIN | USER`\n- `DocumentStatus`: `DRAFT | CONFIRMED`\n- `StockMovementType`: `PURCHASE | SALE | TRANSFER | ADJUSTMENT`\n\n> Nota: `StockMovementType` **no forma parte del schema**, ya que los movimientos no se persisten.\n\n---\n\n## 2. ENTIDADES (persistentes)\n\n### 2.1 User\n\n**Tabla:** `users`\n\n**Campos propios:**\n\n- `username`: str, unique, not null\n- `email`: str | null\n- `rol`: enum(UserRole), not null\n\n**Preferencias:**\n\n- `user_language`: str | null\n- `user_theme`: str | null\n\n**Seguridad:**\n\n- `hash_password`: str, not null\n- `last_login`: datetime | null\n- `password_changed_at`: datetime | null\n\n**Notas:**\n\n- `hash_password` nunca se serializa\n- Todas las fechas se devuelven en formato can√≥nico\n\n---\n\n### 2.2 Product\n\n**Tabla:** `products`\n\n**Campos propios:**\n\n- `name`: str(150), unique, not null\n- `unit_measure`: str(50), not null\n- `is_inventory`: bool, not null, default true\n- `cost_average`: decimal(18,6), not null, default 0\n\n---\n\n### 2.3 Customer\n\n**Tabla:** `customers`\n\n**Campos propios:**\n\n- `name`: str(100), unique, not null\n- `phone`: str | null\n- `email`: str | null\n- `address`: str | null\n\n---\n\n### 2.4 Supplier\n\n**Tabla:** `suppliers`\n\n**Campos propios:**\n\n- `name`: str(100), unique, not null\n- `phone`: str | null\n- `email`: str | null\n- `address`: str | null\n\n**Regla de dominio:**\n\n- Cada Supplier tiene **exactamente un CashAccount asociado**.\n\n---\n\n## 3. AGGREGATES (estado persistente)\n\n### 3.1 StockLocation\n\n**Tabla:** `stock_locations`\n\n**Campos propios:**\n\n- `name`: str(100), unique, not null\n\n**Notas:**\n\n- No existe campo `type`\n- El rol de la ubicaci√≥n se infiere por:\n\n  - naming\n  - contexto de uso\n  - relaci√≥n con Customer (a nivel de service)\n\n---\n\n### 3.2 StockProductLocation\n\n**Tabla:** `stock_product_locations`\n\n**Campos propios:**\n\n- `stock_location_id`: int, FK `stock_locations.id`, not null\n- `product_id`: int, FK `products.id`, not null\n- `quantity`: decimal(12,3), not null, default 0\n\n**Restricciones duras:**\n\n- unique(`stock_location_id`, `product_id`)\n- `quantity >= 0`\n\n---\n\n### 3.3 CashAccount\n\n**Tabla:** `cash_accounts`\n\n**Campos propios:**\n\n- `name`: str(100), unique, not null\n- `balance`: decimal(14,2), not null, default 0\n\n**Reglas de dominio:**\n\n- CashAccount de empresa / banco ‚Üí `balance >= 0`\n- CashAccount de supplier ‚Üí `balance <= 0`\n- Las **deudas viven exclusivamente aqu√≠**\n- No existe deuda persistida en documentos\n\n---\n\n## 4. DOCUMENTOS (auditables)\n\n### 4.1 PurchaseNote\n\n**Tabla:** `purchase_notes`\n\n**Campos propios:**\n\n- `supplier_id`: int, FK `suppliers.id`, not null\n- `date`: date, not null (fecha del acto de negocio)\n- `status`: enum(DocumentStatus), not null\n- `total_amount`: decimal(14,2), not null\n- `paid_amount`: decimal(14,2), not null, default 0\n\n**Reglas de dominio:**\n\n- `total_amount >= paid_amount`\n- La deuda generada impacta en `supplier.cash_account.balance`\n- No existe campo `pending` persistido\n\n---\n\n### 4.2 PurchaseNoteLine\n\n**Tabla:** `purchase_note_lines`\n\n**Campos propios:**\n\n- `purchase_note_id`: int, FK `purchase_notes.id`, not null\n- `product_id`: int, FK `products.id`, not null\n- `quantity`: decimal(12,3), not null\n- `unit_price`: decimal(14,4), not null\n- `total_price`: decimal(14,2), not null\n\n---\n\n### 4.3 SalesNote\n\n**Tabla:** `sales_notes`\n\n**Campos propios:**\n\n- `customer_id`: int, FK `customers.id`, not null\n- `date`: date, not null\n- `status`: enum(DocumentStatus), not null\n- `total_amount`: decimal(14,2), not null\n- `paid_amount`: decimal(14,2), not null\n\n**Regla clave:**\n\n- `total_amount == paid_amount`\n- El stock no pagado **NO forma parte de la venta**\n\n---\n\n### 4.4 SalesNoteLine\n\n**Tabla:** `sales_note_lines`\n\n**Campos propios:**\n\n- `sales_note_id`: int, FK `sales_notes.id`, not null\n- `product_id`: int, FK `products.id`, not null\n- `quantity`: decimal(12,3), not null\n- `unit_price`: decimal(14,4), not null\n- `total_price`: decimal(14,2), not null\n\n---\n\n### 4.5 StockDepositNote\n\n**Tabla:** `stock_deposit_notes`\n\n**Campos propios:**\n\n- `from_stock_location_id`: int, FK `stock_locations.id`, not null\n- `to_stock_location_id`: int, FK `stock_locations.id`, not null\n- `date`: date, not null\n- `product_id`: int, FK `products.id`, not null\n- `quantity`: decimal(12,3), not null\n- `status`: enum(DocumentStatus), not null\n- `notes`: str | null\n\n**Notas:**\n\n- No cambia la propiedad econ√≥mica del stock (solo la ubicaci√≥n)\n- No genera cash\n\n---\n\n### 4.6 CashTransferNote\n\n**Tabla:** `cash_transfer_notes`\n\n**Campos propios:**\n\n- `from_cash_account_id`: int, FK `cash_accounts.id`, not null\n- `to_cash_account_id`: int, FK `cash_accounts.id`, not null\n- `amount`: decimal(14,2), not null\n- `date`: date, not null\n- `status`: enum(DocumentStatus), not null\n- `notes`: str | null\n\n**Reglas:**\n\n- `amount > 0`\n- Nunca genera balance positivo en suppliers\n- Se usa para liquidar deudas y transferencias internas\n\n---\n\n## 5. EXCLUSIONES EXPL√çCITAS\n\n### Movimientos\n\n- `StockMovement`\n- `CashMovement`\n\n‚ùå No tienen model\n‚ùå No tienen tabla\n‚úî Se ejecutan en services\n\n---\n\n### Auth / Backup\n\n‚ùå No tienen model\n‚ùå No forman parte del schema\n\n---\n\n## 6. Cierre\n\n- Este documento **define la base de datos**\n- El estado vive en Aggregates\n- La deuda vive en CashAccount\n- El siguiente paso del flujo es:\n\nüëâ **Plantillas Base / Extensi√≥n**\n\n---\n\n**FIN DEL DOCUMENTO**\n\n<!-- /docs/models_schema_v3.0.md -->\n",
            "security_v3.0.md": "<!-- /docs/security_v3.0.md -->\n\n# SECURITY ‚Äî v3.0\n\n**DemeArizOil Backend (Flask + SQLite)**\n\nDocumento **normativo y obligatorio** de seguridad del backend DemeArizOil v3.0.\nDefine **reglas t√©cnicas, operativas y de uso** para autenticaci√≥n, autorizaci√≥n, tokens, auditor√≠a y protecci√≥n del sistema.\n\nEste documento **no define arquitectura ni l√≥gica de negocio**.\nEst√° alineado estrictamente con:\n\n* `architecture_v3.0.md`\n* `business_logic_v3.0.md`\n* `models_schema_v3.0.md`\n* `ai_rules_v3.0.md`\n\nCualquier desviaci√≥n requiere **MODO CAMBIO CONTROLADO**.\n\n---\n\n## 1. Objetivos de seguridad\n\nEl sistema debe garantizar, como m√≠nimo:\n\n1. Autenticaci√≥n robusta mediante credenciales + JWT.\n2. Autorizaci√≥n estricta basada en roles.\n3. Invalidaci√≥n autom√°tica de tokens comprometidos.\n4. Revocaci√≥n total de sesiones al cambiar contrase√±a.\n5. Separaci√≥n clara entre autenticaci√≥n, autorizaci√≥n y negocio.\n6. Auditor√≠a completa y consistente.\n7. Uso obligatorio de JWT en toda la API.\n8. Cumplimiento estricto de la arquitectura v3.0.\n9. Comportamiento **predecible y verificable** del sistema.\n\n> MFA, Captcha y Rate-Limit **NO forman parte** de v3.0 (decisi√≥n expl√≠cita).\n\n---\n\n## 2. Modelo de usuario (seguridad)\n\nEl modelo `User` incluye los siguientes campos relevantes para seguridad:\n\n```\nid\nusername\nemail\nhash_password\nrol            (admin | user)\npassword_changed_at\nlast_login\nis_active\ncreated_at\nupdated_at\ndeleted_at\n```\n\n### Reglas\n\n1. Solo un **admin** puede:\n\n   * crear usuarios\n   * desactivar usuarios\n   * restaurar usuarios\n   * cambiar roles\n2. Un usuario con `is_active = False`:\n\n   * no puede autenticarse\n   * invalida **todos** sus tokens\n3. El rol efectivo se define como:\n\n   ```\n   is_admin = (rol == \"admin\")\n   ```\n\n---\n\n## 3. Autenticaci√≥n (login)\n\n### Endpoint\n\n```\nPOST /auth/login\nbody = {\n  username,\n  password\n}\n```\n\n### Flujo obligatorio\n\n1. Validar existencia de usuario.\n2. Verificar `is_active = True`.\n3. Comparar `hash_password`.\n4. Actualizar `last_login`.\n5. Emitir:\n\n   * `access_token`\n   * `refresh_token`\n\n---\n\n## 4. Tokens JWT\n\n### Tipos de token\n\n#### Access Token\n\n* Vida corta (minutos).\n* Usado para todas las peticiones protegidas.\n\n#### Refresh Token\n\n* Vida m√°s larga.\n* Usado solo para renovar sesi√≥n.\n\n---\n\n### Payload obligatorio (ambos tokens)\n\n```\n{\n  \"sub\": user.id,\n  \"username\": user.username,\n  \"rol\": user.rol,\n  \"password_changed_at\": user.password_changed_at,\n  \"iat\": ...,\n  \"exp\": ...\n}\n```\n\n---\n\n## 5. Invalidaci√≥n autom√°tica de tokens\n\nTodo token debe ser invalidado autom√°ticamente si:\n\n```\ntoken.password_changed_at != user.password_changed_at\n```\n\nEsto invalida:\n\n* Tokens robados\n* Tokens antiguos\n* Refresh tokens hist√≥ricos\n* Sesiones abiertas antes de un cambio de contrase√±a\n\nüëâ **Regla cr√≠tica**:\nLa verificaci√≥n de `password_changed_at` es **obligatoria en cada request protegida**.\n\n---\n\n## 6. Autorizaci√≥n (roles y permisos)\n\n### Rol Admin\n\nPuede realizar **todas las operaciones** del sistema, incluyendo:\n\n* Gesti√≥n de usuarios\n* Backups\n* Restore\n* Operaciones cr√≠ticas\n* Auditor√≠a completa\n\n---\n\n### Rol User\n\nPuede:\n\n* CRUD de:\n\n  * products\n  * customers\n  * suppliers\n* Registrar:\n\n  * compras\n  * ventas\n  * dep√≥sitos\n  * transferencias\n* Pagar deudas\n\nNo puede:\n\n* Crear o modificar usuarios\n* Cambiar roles\n* Ajustes manuales\n* Restore\n* Acceder a auditor√≠a completa\n\n---\n\n## 7. Middleware de seguridad\n\nToda ruta protegida **debe ejecutar** el middleware de seguridad.\n\n### Flujo del middleware\n\n1. Extraer token JWT.\n2. Decodificar sin confiar.\n3. Verificar firma.\n4. Verificar expiraci√≥n.\n5. Cargar usuario desde BD.\n6. Verificar `is_active`.\n7. Comparar `password_changed_at`.\n8. Verificar permisos seg√∫n rol.\n\n### Respuestas est√°ndar\n\n* `401 Unauthorized` ‚Üí token inv√°lido o expirado\n* `403 Forbidden` ‚Üí sin permisos suficientes\n\n---\n\n## 8. Rutas p√∫blicas\n\nLas **√∫nicas rutas p√∫blicas** permitidas son:\n\n* `/`\n* `/auth/login`\n\nTodas las dem√°s rutas requieren JWT v√°lido.\n\n---\n\n## 9. Almacenamiento de tokens (frontend)\n\n### Prohibido\n\n* `localStorage`\n* `indexedDB`\n* Archivos planos\n* Persistencia insegura\n\n### Permitido\n\n1. Memoria (Pinia / store)\n2. Cookies `HttpOnly`\n3. `sessionStorage` (solo si no hay datos cr√≠ticos)\n\n---\n\n## 10. CORS y seguridad HTTP\n\n### Recomendado\n\n* HTTPS obligatorio en producci√≥n\n* CORS restrictivo\n* `SameSite = Lax` o `Strict`\n* Cabeceras:\n\n  * `X-Frame-Options`\n  * `X-Content-Type-Options`\n  * `Content-Security-Policy`\n\n---\n\n## 11. Auditor√≠a (obligatoria)\n\nEl sistema debe registrar, como m√≠nimo:\n\n* `created_by`\n* `updated_by`\n* `created_at`\n* `updated_at`\n* `deleted_at`\n* IP\n* User-Agent\n\n### Acciones auditadas\n\n* Login / logout\n* Cambio de contrase√±a\n* Cambio de rol\n* Creaci√≥n / confirmaci√≥n de documentos\n* Movimientos de stock\n* Movimientos de cash\n* Soft delete / restore\n* Accesos cr√≠ticos\n\n> La auditor√≠a **no sustituye** a la l√≥gica de negocio ni a los documentos.\n\n---\n\n## 12. Integraci√≥n con arquitectura\n\n1. Solo el m√≥dulo `security/` puede:\n\n   * generar JWT\n   * validar JWT\n   * definir middleware\n2. Ning√∫n service, controller o router:\n\n   * puede generar tokens\n   * puede validar tokens manualmente\n3. La seguridad **no puede contradecir**:\n\n   * `architecture_v3.0.md`\n   * `business_logic_v3.0.md`\n4. Si existe una best practice clara y compatible:\n\n   * se puede aplicar\n   * debe documentarse\n5. Prohibido proponer:\n\n   * MFA\n   * Captcha\n   * Rate-Limit\n   * frameworks alternativos\n   * cambios de stack\n\n---\n\n## 13. Funcionalidades expl√≠citamente fuera de v3.0\n\nQuedan **registradas pero NO activas**:\n\n1. Rate limit real\n2. Captcha\n3. MFA (email / TOTP)\n4. HSTS estricto\n5. Rotaci√≥n autom√°tica de secretos\n6. WebAuthn / Passkeys\n7. Bloqueo por intentos fallidos\n8. Integraci√≥n SIEM\n\n---\n\n## 14. Regla final (ley)\n\n> **Si una decisi√≥n de seguridad no est√° documentada aqu√≠, no existe.**\n\n---\n\n**FIN DEL DOCUMENTO**\n\n<!-- /docs/security_v3.0.md -->",
            "templates": {
                "base_controller.py": "# /src/app/controllers/base_controller.py\n\"\"\"\nBaseController ‚Äî v3.0\n\nController base del sistema DemeArizOil.\n\nResponsabilidad:\n- Orquestar peticiones HTTP\n- Construir payloads (data: dict)\n- Delegar l√≥gica en services\n- Lanzar excepciones de orquestaci√≥n\n\nIMPORTANTE:\n- Este controller SOLO devuelve respuestas HTTP de √©xito (200 / 201).\n- Las respuestas HTTP de error (400 / 401 / 403 / 404 / 409 / 500)\n  se gestionan EXCLUSIVAMENTE en core.exceptions.handlers.\n- Los controllers lanzan excepciones, nunca construyen errores HTTP.\n\"\"\"\n\nfrom flask import request, jsonify\nfrom src.app.core.logging import get_logger\nfrom src.app.services.base_service import BaseService\nfrom src.app.core.exceptions import BadRequestException\n\nlogger = get_logger(__name__)\n\n\nclass BaseController:\n    \"\"\"\n    Controller base para recursos CRUD.\n\n    Todo controller concreto DEBE asignar:\n    - service: instancia de un Service que herede de BaseService\n    \"\"\"\n\n    service: BaseService\n\n    # ------------------------------------------------------------\n    # HELPERS DE INPUT\n    # ------------------------------------------------------------\n    def parse_json(self, req=None, required: bool = False) -> dict:\n        \"\"\"\n        Extrae el cuerpo JSON del request.\n\n        :param req: request opcional (por defecto flask.request)\n        :param required: si True, lanza excepci√≥n si no hay body\n        :raises BadRequestException: si required=True y body vac√≠o\n        \"\"\"\n        data = (req or request).get_json(silent=True)\n\n        if required and not data:\n            raise BadRequestException(\"Request body is required\")\n\n        return data or {}\n\n    # ------------------------------------------------------------\n    # HELPERS DE RESPUESTA (SOLO √âXITO)\n    # ------------------------------------------------------------\n    def response_ok(self, data):\n        \"\"\"\n        Respuesta HTTP 200 OK.\n        \"\"\"\n        return jsonify(data), 200\n\n    def response_created(self, data):\n        \"\"\"\n        Respuesta HTTP 201 Created.\n        \"\"\"\n        return jsonify(data), 201\n\n    # ------------------------------------------------------------\n    # CRUD (usados por BaseRouter)\n    # ------------------------------------------------------------\n    def get_all(self):\n        \"\"\"\n        Devuelve todos los registros activos.\n        \"\"\"\n        items = self.service.get_all()\n        return self.response_ok([i.to_dict() for i in items])\n\n    def get_by_id(self, id: int):\n        \"\"\"\n        Devuelve un registro por ID.\n        \"\"\"\n        obj = self.service.get_by_id(id)\n        return self.response_ok(obj.to_dict())\n\n    def create(self):\n        \"\"\"\n        Crea un nuevo registro.\n        \"\"\"\n        data = self.parse_json(required=True)\n        obj = self.service.create(data)\n        return self.response_created(obj.to_dict())\n\n    def update(self, id: int):\n        \"\"\"\n        Actualiza un registro existente.\n        \"\"\"\n        data = self.parse_json(required=True)\n        obj = self.service.update(id, data)\n        return self.response_ok(obj.to_dict())\n\n    def delete(self, id: int):\n        \"\"\"\n        Soft delete de un registro.\n        \"\"\"\n        obj = self.service.delete(id)\n        return self.response_ok(obj.to_dict())\n\n    def restore(self, id: int):\n        \"\"\"\n        Restaura un registro eliminado l√≥gicamente.\n        \"\"\"\n        obj = self.service.restore(id)\n        return self.response_ok(obj.to_dict())\n\n\n# /src/app/controllers/base_controller.py",
                "base_model.py": "# /src/app/models/base_model.py\n\n\"\"\"\nBaseModel ‚Äî v3.0\n\nModelo base del sistema DemeArizOil.\n\nDefine:\n- Identidad\n- Auditor√≠a\n- Soft delete\n- Serializaci√≥n base\n\nTODOS los modelos persistentes heredan de esta clase.\n\"\"\"\n\nfrom datetime import datetime\nfrom sqlalchemy import Integer, DateTime, Boolean\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\n\n\nclass BaseModel:\n    \"\"\"\n    Clase base para todos los modelos ORM persistentes.\n    \"\"\"\n\n    # ------------------------------------------------------------\n    # CAMPOS BASE\n    # ------------------------------------------------------------\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)\n    updated_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)\n\n    deleted_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)\n\n    created_by: Mapped[int | None] = mapped_column(Integer, nullable=True)\n    updated_by: Mapped[int | None] = mapped_column(Integer, nullable=True)\n\n    # ------------------------------------------------------------\n    # SERIALIZACI√ìN\n    # ------------------------------------------------------------\n    def to_dict(self) -> dict:\n        \"\"\"\n        Serializa los campos base del modelo.\n\n        Este m√©todo:\n        - DEBE ser extendido por los modelos hijos\n        - NUNCA debe ser eliminado\n        \"\"\"\n\n        return {\n            \"id\": self.id,\n            \"is_active\": self.is_active,\n            \"created_at\": dt_to_iso_z(self.created_at),\n            \"updated_at\": dt_to_iso_z(self.updated_at),\n            \"deleted_at\": dt_to_iso_z(self.deleted_at),\n            \"created_by\": self.created_by,\n            \"updated_by\": self.updated_by,\n        }\n\n# /src/app/models/base_model.py",
                "base_router.py": "# /src/app/api/routers/base_router.py\n\"\"\"\nBaseRouter ‚Äî v3.0\n\nRouter base del sistema DemeArizOil.\n\nResponsabilidad:\n- Definir endpoints CRUD est√°ndar\n- Conectar HTTP con controllers\n\nIMPORTANTE:\n- DELETE realiza un *soft delete* (no elimina registros de la base de datos).\n- RESTORE reactiva un registro previamente eliminado l√≥gicamente.\n\"\"\"\n\nfrom flask import Blueprint\n\n\nclass BaseRouter:\n    \"\"\"\n    Router CRUD gen√©rico basado en un controller.\n\n    Sem√°ntica de endpoints:\n    - DELETE /<resource>/<id>\n        Realiza un borrado l√≥gico (soft delete).\n        Internamente:\n            - is_active = False\n            - deleted_at = datetime.now(timezone.utc)\n        El registro NO se elimina de la base de datos.\n\n    - POST /<resource>/<id>/restore\n        Restaura un registro eliminado l√≥gicamente.\n        Internamente:\n            - is_active = True\n            - deleted_at = None\n        NO crea un nuevo registro en la base de datos.\n    \"\"\"\n\n    def __init__(self, resource: str, controller):\n        \"\"\"\n        Inicializa el router base.\n\n        :param resource: nombre del recurso (plural)\n        :param controller: instancia del controller\n        \"\"\"\n        self.resource = resource\n        self.controller = controller\n        self.router = Blueprint(resource, __name__, url_prefix=f\"/{resource}\")\n        self._register_routes()\n\n    # ------------------------------------------------------------\n    # ROUTES CRUD\n    # ------------------------------------------------------------\n    def _register_routes(self):\n        \"\"\"\n        Registra las rutas CRUD est√°ndar.\n\n        Nota:\n        - Los endpoints DELETE y RESTORE delegan en el controller,\n          que a su vez delega en el service.\n        - La l√≥gica de soft delete y restore vive en el service,\n          NO en el router.\n        \"\"\"\n        self.router.add_url_rule(\"/\", methods=[\"GET\"], view_func=self.controller.get_all)\n        self.router.add_url_rule(\"/<int:id>\", methods=[\"GET\"], view_func=self.controller.get_by_id)\n        self.router.add_url_rule(\"/\", methods=[\"POST\"], view_func=self.controller.create)\n        self.router.add_url_rule(\"/<int:id>\", methods=[\"PUT\"], view_func=self.controller.update)\n\n        # Soft delete: NO elimina el registro de la base de datos\n        self.router.add_url_rule(\"/<int:id>\", methods=[\"DELETE\"], view_func=self.controller.delete)\n\n        # Restore: reactiva un registro eliminado l√≥gicamente\n        # NO crea un nuevo registro en la base de datos\n        self.router.add_url_rule(\"/<int:id>/restore\", methods=[\"POST\"], view_func=self.controller.restore)\n\n# /src/app/api/routers/base_router.py",
                "base_service.py": "# /src/app/services/base_service.py\n\"\"\"\nBaseService ‚Äî v3.0\n\nService base del sistema DemeArizOil.\n\nProporciona:\n- CRUD gen√©rico\n- Soft delete\n- Restore\n- Control de errores t√©cnicos\n\nIMPORTANTE:\n- NO contiene l√≥gica de negocio\n- NO valida reglas de dominio\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\n\nfrom src.app.core.config.database import db_session\nfrom src.app.core.exceptions import (\n    NotFoundException,\n    BadRequestException,\n    ServerErrorException,\n)\nfrom src.app.models.base_model import BaseModel\n\n\nclass BaseService:\n    \"\"\"\n    Clase base para todos los services CRUD.\n    \"\"\"\n\n    model: type[BaseModel] | None = None\n\n    # ------------------------------------------------------------\n    # HELPERS INTERNOS\n    # ------------------------------------------------------------\n    def _ensure_model(self):\n        \"\"\"\n        Asegura que el service tiene un modelo asignado.\n        \"\"\"\n        if self.model is None:\n            raise ServerErrorException(\"Service model not defined\")\n\n    # ------------------------------------------------------------\n    # CRUD\n    # ------------------------------------------------------------\n    def get_all(self):\n        \"\"\"\n        Devuelve todos los registros activos del modelo.\n        \"\"\"\n        self._ensure_model()\n        return (\n            db_session.query(self.model)\n            .filter(self.model.is_active == True)\n            .all()\n        )\n\n    def get_by_id(self, id: int):\n        \"\"\"\n        Devuelve un registro activo por ID.\n        \"\"\"\n        self._ensure_model()\n\n        obj = (\n            db_session.query(self.model)\n            .filter(self.model.id == id, self.model.is_active == True)\n            .first()\n        )\n\n        if not obj:\n            raise NotFoundException(f\"{self.model.__name__} not found\")\n\n        return obj\n\n    def create(self, data: dict):\n        \"\"\"\n        Crea un nuevo registro activo.\n        \"\"\"\n        self._ensure_model()\n\n        try:\n            obj = self.model(**data)\n            db_session.add(obj)\n            db_session.commit()\n            return obj\n\n        except IntegrityError as exc:\n            db_session.rollback()\n            raise BadRequestException(\"Integrity constraint violated\") from exc\n\n        except SQLAlchemyError as exc:\n            db_session.rollback()\n            raise ServerErrorException(\"Database error during create\") from exc\n\n    def update(self, id: int, data: dict):\n        \"\"\"\n        Actualiza un registro activo.\n        \"\"\"\n        self._ensure_model()\n        obj = self.get_by_id(id)\n\n        try:\n            for key, value in data.items():\n                if not hasattr(obj, key):\n                    raise BadRequestException(f\"Invalid field: {key}\")\n                setattr(obj, key, value)\n\n            obj.updated_at = datetime.now(timezone.utc)\n            db_session.commit()\n            return obj\n\n        except IntegrityError as exc:\n            db_session.rollback()\n            raise BadRequestException(\"Integrity constraint violated\") from exc\n\n        except SQLAlchemyError as exc:\n            db_session.rollback()\n            raise ServerErrorException(\"Database error during update\") from exc\n\n    def delete(self, id: int):\n        \"\"\"\n        Soft delete de un registro.\n        \"\"\"\n        self._ensure_model()\n        obj = self.get_by_id(id)\n\n        try:\n            obj.is_active = False\n            obj.deleted_at = datetime.now(timezone.utc)\n            db_session.commit()\n            return obj\n\n        except SQLAlchemyError as exc:\n            db_session.rollback()\n            raise ServerErrorException(\"Database error during delete\") from exc\n\n    def restore(self, id: int):\n        \"\"\"\n        Restaura un registro eliminado l√≥gicamente.\n        \"\"\"\n        self._ensure_model()\n\n        obj = db_session.query(self.model).filter(self.model.id == id).first()\n        if not obj:\n            raise NotFoundException(f\"{self.model.__name__} not found\")\n\n        try:\n            obj.is_active = True\n            obj.deleted_at = None\n            db_session.commit()\n            return obj\n\n        except SQLAlchemyError as exc:\n            db_session.rollback()\n            raise ServerErrorException(\"Database error during restore\") from exc\n\n#BaseService NO debe exportar una instancia. Los services concretos importan la CLASE BaseService y exportan SU instancia\n# /src/app/services/base_service.py\n",
                "_controller_extension_template.py": "# /src/app/controllers/_controller_extension_template.py\n\"\"\"\n<ControllerName>Controller ‚Äî v3.0\n\nController de dominio del sistema DemeArizOil.\n\nExtiende BaseController para:\n- Exponer CRUD est√°ndar\n- A√±adir endpoints espec√≠ficos de negocio\n\nIMPORTANTE:\n- Importa una INSTANCIA del service\n- Exporta una INSTANCIA del controller\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.service_name_service import service_name_service\nfrom src.app.core.exceptions import BadRequestException\n\n\nclass ControllerNameController(BaseController):\n    \"\"\"\n    Controller para <Entidad / Documento>.\n\n    Hereda CRUD de BaseController.\n    \"\"\"\n\n    service = service_name_service\n\n    # ------------------------------------------------------------\n    # ENDPOINTS ESPEC√çFICOS DE NEGOCIO\n    # ------------------------------------------------------------\n    def special_action(self):\n        \"\"\"\n        Endpoint de negocio espec√≠fico.\n        \"\"\"\n        data = self.parse_json(required=True)\n\n        if \"required_field\" not in data:\n            raise BadRequestException(\"required_field is mandatory\")\n\n        result = self.service.special_method(data)\n        return self.response_ok(result)\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncontroller_name_controller = ControllerNameController()\n\n# /src/app/controllers/_controller_extension_template.py\n",
                "_router_extension_template.py": "# /src/app/api/routers/_router_extension_template.py\n\"\"\"\n<resource> router ‚Äî v3.0\n\nRouter CRUD del sistema DemeArizOil con endpoints adicionales.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar mediante BaseRouter\n- Exponer endpoints adicionales de negocio\n- Delegar toda la l√≥gica en el controller\n\nIMPORTANTE:\n- NO contiene l√≥gica de negocio\n- NO importa request\n- Todas las rutas llaman directamente al controller\n\"\"\"\n\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.controller_name_controller import controller_name_controller\n\n# ------------------------------------------------------------\n# ROUTER CRUD BASE\n# ------------------------------------------------------------\nrouter = BaseRouter(\"<resource>\", controller_name_controller).router\n\n# ------------------------------------------------------------\n# ENDPOINTS ADICIONALES DE NEGOCIO\n# ------------------------------------------------------------\n@router.post(\"/action\")\ndef action():\n    \"\"\"\n    Endpoint adicional de negocio.\n    \"\"\"\n    return controller_name_controller.action()\n\n# /src/app/api/routers/_router_extension_template.py",
                "_service_extension_template.py": "# /src/app/services/_service_extension_template.py\n\"\"\"\n<ServiceName>Service ‚Äî v3.0\n\nService extendido del sistema DemeArizOil.\n\nIncluye:\n- L√≥gica de negocio\n- Validaciones de dominio\n- Uso de movimientos si aplica\n\nIMPORTANTE:\n- Este service hereda TODOS los m√©todos CRUD de BaseService:\n  get_all, get_by_id, create, update, delete, restore\n- NO se redeclaran m√©todos base salvo para extender comportamiento\n\nCumple architecture_v*:\n- Exporta instancia\n- Controllers importan la instancia\n\"\"\"\nfrom src.app.services.base_service import BaseService\nfrom src.app.core.exceptions import BadRequestException, NotFoundException\n\n\nclass ServiceNameService(BaseService): # Aqu√≠ hereda\n    \"\"\"\n    Service de dominio para <Entidad / Documento>.\n\n    Hereda los m√©todos CRUD de BaseService.\n    \"\"\"\n\n    model = None  # Asignar modelo correspondiente\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n\n    # ------------------------------------------------------------\n    # M√âTODOS DE NEGOCIO\n    # ------------------------------------------------------------\n    def special_method(self, data: dict):\n        \"\"\"\n        M√©todo de negocio espec√≠fico.\n\n        Define:\n        - validaciones\n        - efectos\n        - reglas expl√≠citas\n        \"\"\"\n        if not data:\n            raise BadRequestException(\"Invalid data\")\n\n        # l√≥gica de negocio aqu√≠\n        pass\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    \n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\n# Cada Service particular DEBE exportar una instancia.\n# Sin esta instancia se rompe el patr√≥n Base ‚Üí Particular a nivel runtime.\nservice_name_service = ServiceNameService()\n# /src/app/services/_service_extension_template.py\n",
                "_special_controller_template.py": "# /src/app/controllers/_special_controller_template.py\n\"\"\"\n<ControllerName>Controller ‚Äî v3.0\n\nController especial del sistema DemeArizOil.\n\nResponsabilidad:\n- Exponer endpoints NO CRUD\n- Delegar en services especiales\n\nIMPORTANTE:\n- NO expone CRUD\n- Importa una INSTANCIA del service especial\n- Exporta una INSTANCIA del controller\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.special_service_name_service import special_service_name_service\nfrom src.app.core.exceptions import BadRequestException\n\n\nclass ControllerNameController(BaseController):\n    \"\"\"\n    Controller especial.\n    \"\"\"\n\n    service = special_service_name_service\n\n    # ------------------------------------------------------------\n    # ENDPOINTS ESPECIALES\n    # ------------------------------------------------------------\n    def action(self):\n        \"\"\"\n        Ejecuta una acci√≥n especial del sistema.\n        \"\"\"\n        data = self.parse_json(required=True)\n\n        result = self.service.public_method(data)\n        return self.response_ok(result)\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncontroller_name_controller = ControllerNameController()\n\n# /src/app/controllers/_special_controller_template.py\n",
                "_special_router_template.py": "# /src/app/api/routers/_special_router_template.py\n\"\"\"\n<resource> router ‚Äî v3.0\n\nRouter especial del sistema DemeArizOil.\n\nResponsabilidad:\n- Exponer endpoints NO CRUD\n- Delegar completamente en el controller\n\nIMPORTANTE:\n- NO usa BaseRouter\n- NO expone CRUD\n- NO importa request\n\"\"\"\n\nfrom flask import Blueprint\nfrom src.app.controllers.controller_name_controller import controller_name_controller\n\nrouter = Blueprint(\"<resource>\", __name__, url_prefix=\"/<resource>\")\n\n# ------------------------------------------------------------\n# ENDPOINTS ESPECIALES\n# ------------------------------------------------------------\n@router.post(\"/action\")\ndef action():\n    \"\"\"\n    Acci√≥n expl√≠cita del sistema.\n    \"\"\"\n    return controller_name_controller.action()\n\n# /src/app/api/routers/_special_router_template.py",
                "_special_service_template.py": "# /src/app/services/_special_service_template.py\n\"\"\"\n<ServiceName>Service ‚Äî v3.0\n\nService especial del sistema DemeArizOil.\n\nResponsabilidad:\n- L√≥gica transversal o t√©cnica\n- Movimientos no persistentes\n- Autenticaci√≥n, backup u operaciones de sistema\n\nIMPORTANTE:\n- NO hereda de BaseService\n- NO representa un modelo persistente\n- NO expone CRUD\n- Exporta instancia obligatoriamente\n\"\"\"\n\nfrom src.app.core.exceptions import BadRequestException, NotFoundException\n\n\nclass ServiceNameService:\n    \"\"\"\n    Service especial.\n\n    No sigue el patr√≥n CRUD Base ‚Üí Extensi√≥n.\n    \"\"\"\n\n    # ------------------------------------------------------------\n    # M√âTODOS P√öBLICOS\n    # ------------------------------------------------------------\n    def public_method(self, data: dict):\n        \"\"\"\n        Ejecuta una acci√≥n espec√≠fica del sistema.\n\n        Define:\n        - validaciones\n        - efectos\n        - reglas expl√≠citas\n        \"\"\"\n        pass\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _helper_method(self):\n        \"\"\"\n        M√©todo auxiliar interno.\n        \"\"\"\n        pass\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\n# Cada Service particular DEBE exportar una instancia.\n# Sin esta instancia se rompe el patr√≥n Base ‚Üí Particular a nivel runtime.\nservice_name_service = ServiceNameService()\n\n# /src/app/services/_special_service_template.py\n"
            }
        },
        "logs": {},
        "README.md": "<!-- /README.md -->\n\n# DemeArizOil Backend v3.0\n\nBackend Flask + SQLite para gesti√≥n de compras, ventas, stock y cash en DemeArizOil.  \nEl comportamiento est√° definido por `docs/architecture_v3.0.md` y `docs/business_logic_v3.0.md`.\n\n## Tecnolog√≠as\n\n- Flask\n- SQLite\n- SQLAlchemy\n- JWT\n- Arquitectura Router ‚Üí Controller ‚Üí Service ‚Üí Model\n- Soft delete con `is_active` y `deleted_at`\n\n## Arquitectura v3.0 (resumen)\n\n- Router: HTTP y binding al controller.\n- Controller: orquestaci√≥n HTTP y serializaci√≥n.\n- Service: reglas de negocio, validaciones y transacciones.\n- Model: estado persistente y `to_dict()`.\n\n## Dominios y documentos clave\n\n- Master data: Users, Products, Customers, Suppliers.\n- Stock: StockLocation, StockProductLocation.\n- Cash: CashAccount.\n- Documentos:\n  - PurchaseNote + l√≠neas\n  - SalesNote + l√≠neas\n  - StockDepositNote\n  - CashTransferNote\n\n## L√≥gica de negocio (resumen)\n\n- Los movimientos NO se persisten; solo actualizan estado actual.\n- PurchaseNote: entra stock, registra pago inicial y deuda (no liquida deuda).\n- SalesNote: solo se vende lo pagado; stock sale primero del cliente y luego de DEME.\n- StockDepositNote: mueve stock entre ubicaciones, sin cash.\n- CashTransferNote: mueve cash entre cuentas y sirve para pagar deudas.\n- Deuda de proveedor vive solo en CashAccount (balance puede ser negativo).\n\n## API y endpoints\n\n- Prefijo: `/api`\n- Rutas p√∫blicas: `/`, `/api/auth/login`, `/api/auth/refresh`\n- Documentaci√≥n de endpoints: `docs/API_ENDPOINTS.md`\n\n## Seguridad\n\n- JWT obligatorio en rutas protegidas.\n- Tokens invalidados si cambia `password_changed_at`.\n- Middleware centralizado en `jwt_middleware`.\n\n## Soft delete\n\nNo se borra f√≠sicamente. Se marca:\n\n```\nobj.is_active = False\nobj.deleted_at = datetime.now(timezone.utc)\n```\n\n## Tests\n\n- Smoke CRUD: `tests/test_900_api_smoke.py`\n- Flujo completo: `tests/test_100_full_flow_basic.py`\n\n<!-- /README.md -->\n",
        "requirements.txt": "Flask==3.0.3\nFlask-Cors==4.0.1\nPyJWT==2.9.0\nSQLAlchemy==2.0.31\nWerkzeug==3.0.3\nbcrypt==4.1.2\npython-dotenv==1.0.1\npytest==8.3.2\npytest-cov==5.0.0\n",
        "src": {
            "app": {
                "api": {
                    "api_router.py": "# /src/app/api/api_router.py\n\"\"\"\nAPI Router ‚Äî v3.0\n\nRouter ra√≠z de la API del backend DemeArizOil.\n\nEste archivo es el punto central de exposici√≥n HTTP del sistema.\nAqu√≠ NO se implementa l√≥gica de negocio ni seguridad: √∫nicamente\nse registran los routers de cada dominio/documento.\n\nDecisiones clave:\n- El prefijo global de la API se define en settings.API_PREFIX\n- Todas las rutas pasan por el middleware de seguridad\n- Las rutas p√∫blicas se declaran en settings.PUBLIC_PATHS\n- Este archivo debe reflejar TODOS los documentos existentes del sistema\n\nReferencia normativa:\n- architecture_v3.0.md\n\"\"\"\n\nfrom __future__ import annotations\n\n# Blueprint es el mecanismo de Flask para agrupar rutas\nfrom flask import Blueprint\n\n# Settings centraliza prefijos y configuraci√≥n global\nfrom src.app.core.config.settings import settings\n\n# ============================================================\n# IMPORTS DE ROUTERS\n# ============================================================\n# Cada router representa un dominio o documento del sistema.\n# Este archivo SOLO los importa y los registra.\n# No debe existir l√≥gica adicional aqu√≠.\n\n# AUTH\n# Login / refresh (rutas p√∫blicas)\nfrom src.app.api.routers.auth_router import auth_router\n\n# USERS Y ENTIDADES MAESTRAS\n# CRUD b√°sicos del sistema\nfrom src.app.api.routers.users_router import users_router\nfrom src.app.api.routers.products_router import products_router\nfrom src.app.api.routers.customers_router import customers_router\nfrom src.app.api.routers.suppliers_router import suppliers_router\n\n# DOCUMENTOS DE COMPRA\n# Albaranes de compra y sus l√≠neas\nfrom src.app.api.routers.purchase_notes_router import purchase_notes_router\nfrom src.app.api.routers.purchase_line_router import purchase_line_router\n\n# DOCUMENTOS DE VENTA\n# Albaranes de venta y sus l√≠neas\nfrom src.app.api.routers.sales_notes_router import sales_notes_router\nfrom src.app.api.routers.sales_line_router import sales_line_router\n\n# STOCK\n# Ubicaciones de stock y stock por producto/ubicaci√≥n\nfrom src.app.api.routers.stock_locations_router import stock_locations_router\nfrom src.app.api.routers.stock_product_locations_router import stock_product_locations_router\n\n# Documento v3.0: dep√≥sito de stock f√≠sico\n# (puede venir de proveedor, cliente o ajuste operativo)\nfrom src.app.api.routers.stock_deposit_notes_router import stock_deposit_notes_router\n\n# CASH\n# Cuentas de cash internas de la empresa\nfrom src.app.api.routers.cash_accounts_router import cash_accounts_router\n\n# Documento v3.0: transferencia de dinero entre cuentas internas\nfrom src.app.api.routers.cash_transfer_notes_router import cash_transfer_notes_router\n\n# SISTEMA\n# Operaciones t√©cnicas del sistema (backup, restore, etc.)\nfrom src.app.api.routers.backup_router import backup_router\n\n# ============================================================\n# BLUEPRINTS\n# ============================================================\n# El prefijo (/api) NO se hardcodea aqu√≠.\n# Se obtiene siempre desde settings para permitir cambios futuros\n# (por ejemplo /api/v1) sin tocar routers.\napi_router = Blueprint(\"api\", __name__, url_prefix=settings.API_PREFIX)\n\n# REGISTRO DE ROUTERS\n# Agrupado por dominio para facilitar lectura y mantenimiento.\n\n# AUTH (rutas p√∫blicas)\napi_router.register_blueprint(auth_router, url_prefix=\"/auth\")\n\n# USERS\napi_router.register_blueprint(users_router, url_prefix=\"/users\")\n\n# ENTIDADES MAESTRAS\napi_router.register_blueprint(products_router, url_prefix=\"/products\")\napi_router.register_blueprint(customers_router, url_prefix=\"/customers\")\napi_router.register_blueprint(suppliers_router, url_prefix=\"/suppliers\")\n\n# PURCHASE NOTES + LINES\n# Las l√≠neas comparten prefijo con su documento padre\napi_router.register_blueprint(purchase_notes_router, url_prefix=\"/purchase_notes\")\napi_router.register_blueprint(purchase_line_router, url_prefix=\"/purchase_notes\")\n\n# SALES NOTES + LINES\napi_router.register_blueprint(sales_notes_router, url_prefix=\"/sales_notes\")\napi_router.register_blueprint(sales_line_router, url_prefix=\"/sales_notes\")\n\n# STOCK\n# Documentos, ubicaciones y consultas\napi_router.register_blueprint(stock_locations_router, url_prefix=\"/stock_locations\")\napi_router.register_blueprint(stock_product_locations_router, url_prefix=\"/stock_product_locations\")\napi_router.register_blueprint(stock_deposit_notes_router, url_prefix=\"/stock_deposit_notes\")\n\n# CASH\n# Documentos, cuentas y consultas\napi_router.register_blueprint(cash_accounts_router, url_prefix=\"/cash_accounts\")\napi_router.register_blueprint(cash_transfer_notes_router, url_prefix=\"/cash_transfer_notes\")\n\n# SISTEMA\napi_router.register_blueprint(backup_router, url_prefix=\"/backup\")\n\n# /src/app/api/api_router.py\n",
                    "routers": {
                        "auth_router.py": "# /src/app/api/routers/auth_router.py\nfrom flask import Blueprint, request\nfrom src.app.controllers.auth_controller import auth_controller\n\nauth_router = Blueprint(\"auth\", __name__)\n\nauth_router.post(\"/login\")(auth_controller.login)\n\n@auth_router.post(\"/refresh\")\ndef refresh():\n    auth_header = request.headers.get(\"Authorization\")\n    if not auth_header or not auth_header.startswith(\"Bearer \"):\n        return {\"error\": \"Missing refresh token\"}, 401\n    token = auth_header.replace(\"Bearer \", \"\").strip()\n    return auth_controller.refresh(token)\n\nauth_router.get(\"/me\")(auth_controller.me)\n# /src/app/api/routers/auth_router.py",
                        "backup_router.py": "# /src/app/api/routers/backup_router.py\nfrom flask import Blueprint\nfrom src.app.controllers.backup_controller import backup_controller\n\nbackup_router = Blueprint(\"backup\", __name__)\n\nbackup_router.get(\"\")(backup_controller.export_backup)\nbackup_router.post(\"\")(backup_controller.restore_backup)\n# /src/app/api/routers/backup_router.py",
                        "base_router.py": "# /src/app/api/routers/base_router.py\n\"\"\"\nBaseRouter ‚Äî v3.0\n\nRouter base del sistema DemeArizOil.\n\nResponsabilidad:\n- Definir endpoints CRUD est√°ndar\n- Conectar HTTP con controllers\n\nIMPORTANTE:\n- DELETE realiza un *soft delete* (no elimina registros de la base de datos).\n- RESTORE reactiva un registro previamente eliminado l√≥gicamente.\n\"\"\"\n\nfrom flask import Blueprint\n\n\nclass BaseRouter:\n    \"\"\"\n    Router CRUD gen√©rico basado en un controller.\n\n    Sem√°ntica de endpoints:\n    - DELETE /<resource>/<id>\n        Realiza un borrado l√≥gico (soft delete).\n        Internamente:\n            - is_active = False\n            - deleted_at = datetime.now(timezone.utc)\n        El registro NO se elimina de la base de datos.\n\n    - POST /<resource>/<id>/restore\n        Restaura un registro eliminado l√≥gicamente.\n        Internamente:\n            - is_active = True\n            - deleted_at = None\n        NO crea un nuevo registro en la base de datos.\n    \"\"\"\n\n    def __init__(self, resource: str, controller):\n        \"\"\"\n        Inicializa el router base.\n\n        :param resource: nombre del recurso (plural)\n        :param controller: instancia del controller\n        \"\"\"\n        self.resource = resource\n        self.controller = controller\n        self.router = Blueprint(resource, __name__, url_prefix=f\"/{resource}\")\n        self._register_routes()\n\n    # ------------------------------------------------------------\n    # ROUTES CRUD\n    # ------------------------------------------------------------\n    def _register_routes(self):\n        \"\"\"\n        Registra las rutas CRUD est√°ndar.\n\n        Nota:\n        - Los endpoints DELETE y RESTORE delegan en el controller,\n          que a su vez delega en el service.\n        - La l√≥gica de soft delete y restore vive en el service,\n          NO en el router.\n        \"\"\"\n        self.router.add_url_rule(\"/\", methods=[\"GET\"], view_func=self.controller.get_all)\n        self.router.add_url_rule(\"/<int:id>\", methods=[\"GET\"], view_func=self.controller.get_by_id)\n        self.router.add_url_rule(\"/\", methods=[\"POST\"], view_func=self.controller.create)\n        self.router.add_url_rule(\"/<int:id>\", methods=[\"PUT\"], view_func=self.controller.update)\n\n        # Soft delete: NO elimina el registro de la base de datos\n        self.router.add_url_rule(\"/<int:id>\", methods=[\"DELETE\"], view_func=self.controller.delete)\n\n        # Restore: reactiva un registro eliminado l√≥gicamente\n        # NO crea un nuevo registro en la base de datos\n        self.router.add_url_rule(\"/<int:id>/restore\", methods=[\"POST\"], view_func=self.controller.restore)\n\n# /src/app/api/routers/base_router.py",
                        "cash_accounts_router.py": "# /src/app/api/routers/cash_accounts_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.cash_account_controller import cash_account_controller\n\ncash_accounts_router = BaseRouter(\"cash_accounts\", cash_account_controller).router\n\n@cash_accounts_router.get(\"/by_name/<string:name>\")\ndef get_by_name(name):\n    return cash_account_controller.get_by_name(name)\n# /src/app/api/routers/cash_accounts_router.py",
                        "cash_transfer_notes_router.py": "# /src/app/api/routers/cash_transfer_notes_router.py\n\"\"\"\ncash_transfer_notes router ‚Äî v3.0\n\nRouter del documento CashTransferNotes.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar\n- Exponer endpoint expl√≠cito de confirmaci√≥n\n\nIMPORTANTE:\n- No contiene l√≥gica de negocio\n- No importa request\n- Delegaci√≥n total en el controller\n\"\"\"\n\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.cash_transfer_notes_controller import (\n    cash_transfer_notes_controller,\n)\n\n# ------------------------------------------------------------\n# ROUTER CRUD BASE\n# ------------------------------------------------------------\ncash_transfer_notes_router = BaseRouter(\n    \"cash_transfer_notes\",\n    cash_transfer_notes_controller,\n).router\n\n\n# ------------------------------------------------------------\n# ENDPOINTS EXPL√çCITOS DE DOCUMENTO\n# ------------------------------------------------------------\n@cash_transfer_notes_router.post(\"/<int:id>/confirm\")\ndef confirm(id: int):\n    \"\"\"\n    Confirma un CashTransferNotes.\n    \"\"\"\n    return cash_transfer_notes_controller.confirm(id)\n\n# /src/app/api/routers/cash_transfer_notes_router.py\n",
                        "customers_router.py": "# /src/app/api/routers/customers_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.customers_controller import customers_controller\n\ncustomers_router = BaseRouter(\"customers\", customers_controller).router\n# /src/app/api/routers/customers_router.py",
                        "products_router.py": "# /src/app/api/routers/products_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.products_controller import products_controller\n\nproducts_router = BaseRouter(\"products\", products_controller).router\n# /src/app/api/routers/products_router.py",
                        "purchase_line_router.py": "# /src/app/api/routers/purchase_line_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.purchase_line_controller import purchase_line_controller\n\npurchase_line_router = BaseRouter(\"purchase_lines\", purchase_line_controller).router\n\npurchase_line_router.post(\"/<int:purchase_id>/lines\")(purchase_line_controller.create_line)\npurchase_line_router.get(\"/<int:purchase_id>/lines\")(purchase_line_controller.get_all)\npurchase_line_router.delete(\"/lines/<int:id>\")(purchase_line_controller.delete)\n# /src/app/api/routers/purchase_line_router.py\n",
                        "purchase_notes_router.py": "# /src/app/api/routers/purchase_notes_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.purchase_notes_controller import purchase_notes_controller\n\npurchase_notes_router = BaseRouter(\"purchase_notes\", purchase_notes_controller).router\n\npurchase_notes_router.post(\"/<int:id>/confirm\")(purchase_notes_controller.confirm)\n# /src/app/api/routers/purchase_notes_router.py\n",
                        "sales_line_router.py": "# /src/app/api/routers/sales_line_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.sales_line_controller import sales_line_controller\n\nsales_line_router = BaseRouter(\"sales_lines\", sales_line_controller).router\n\nsales_line_router.post(\"/<int:sales_id>/lines\")(sales_line_controller.create_line)\nsales_line_router.get(\"/<int:sales_id>/lines\")(sales_line_controller.get_all)\nsales_line_router.delete(\"/lines/<int:id>\")(sales_line_controller.delete)\n# /src/app/api/routers/sales_line_router.py\n",
                        "sales_notes_router.py": "# /src/app/api/routers/sales_notes_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.sales_notes_controller import sales_notes_controller\n\nsales_notes_router = BaseRouter(\"sales_notes\", sales_notes_controller).router\n\nsales_notes_router.post(\"/<int:id>/confirm\")(sales_notes_controller.confirm)\n# /src/app/api/routers/sales_notes_router.py\n",
                        "stock_deposit_notes_router.py": "# /src/app/api/routers/stock_deposit_notes_router.py\n\"\"\"\nstock_deposit_notes router ‚Äî v3.0\n\"\"\"\n\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.stock_deposit_notes_controller import (stock_deposit_notes_controller)\n\nstock_deposit_notes_router = BaseRouter(\"stock_deposit_notes\", stock_deposit_notes_controller).router\n\n\n@stock_deposit_notes_router.post(\"/<int:id>/confirm\")\ndef confirm(id: int):\n    \"\"\"\n    Confirma un StockDepositNotes.\n    \"\"\"\n    return stock_deposit_notes_controller.confirm(id)\n\n# /src/app/api/routers/stock_deposit_notes_router.py\n",
                        "stock_locations_router.py": "# /src/app/api/routers/stock_locations_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.stock_locations_controller import stock_locations_controller\n\nstock_locations_router = BaseRouter(\"stock_locations\", stock_locations_controller).router\n\n@stock_locations_router.get(\"/by_name/<string:name>\")\ndef get_by_name(name):\n    return stock_locations_controller.get_by_name(name)\n# /src/app/api/routers/stock_locations_router.py",
                        "stock_product_locations_router.py": "# /src/app/api/routers/stock_product_locations_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.stock_product_locations_controller import stock_product_locations_controller\n\nstock_product_locations_router = BaseRouter(\"stock_product_locations\", stock_product_locations_controller).router\n# /src/app/api/routers/stock_product_locations_router.py",
                        "suppliers_router.py": "# /src/app/api/routers/suppliers_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.suppliers_controller import suppliers_controller\n\nsuppliers_router = BaseRouter(\"suppliers\", suppliers_controller).router\n# /src/app/api/routers/suppliers_router.py",
                        "users_router.py": "# /src/app/api/routers/users_router.py\nfrom src.app.api.routers.base_router import BaseRouter\nfrom src.app.controllers.user_controller import user_controller\n\nusers_router = BaseRouter(\"users\", user_controller).router\n\nusers_router.post(\"/change-password\")(user_controller.change_password)\n# /src/app/api/routers/users_router.py",
                        "__init__.py": "# /src/app/api/routers/__init__.py\n\nfrom .auth_router import auth_router\n\n# USERS Y ENTIDADES MAESTRAS\nfrom .users_router import users_router\nfrom .products_router import products_router\nfrom .customers_router import customers_router\nfrom .suppliers_router import suppliers_router\n\n# DOCUMENTOS DE COMPRA\nfrom .purchase_notes_router import purchase_notes_router\nfrom .purchase_line_router import purchase_line_router\n\n# DOCUMENTOS DE VENTA\nfrom .sales_notes_router import sales_notes_router\nfrom .sales_line_router import sales_line_router\n\n# STOCK\nfrom .stock_locations_router import stock_locations_router\nfrom .stock_product_locations_router import stock_product_locations_router\nfrom .stock_deposit_notes_router import stock_deposit_notes_router\n\n# CASH\nfrom .cash_accounts_router import cash_accounts_router\nfrom .cash_transfer_notes_router import cash_transfer_notes_router\n\n# SISTEMA\nfrom .backup_router import backup_router\n\n# /src/app/api/routers/__init__.py\n"
                    },
                    "__init__.py": "# /src/app/api/__init__.py \nfrom .api_router import api_router\n# /src/app/api/__init__.py "
                },
                "backups": {
                    "create_backup.py": "# /src/app/backups/create_backup.py \nimport os\nimport shutil\nfrom datetime import datetime, timezone\n\n# Ruta fija seg√∫n architecture_v2.0\ndatabase_path = \"src/app/db/database.db\"\nBACKUP_DIR = \"backups\"\n\n# Best practice: copia segura timestamp + creaci√≥n del directorio\n\ndef create_backup():\n    os.makedirs(BACKUP_DIR, exist_ok=True)\n\n    if not os.path.exists(database_path):\n        return None\n\n    timestamp = datetime.now(timezone.utc).strftime(\"%Y%m%d_%H%M%S\")\n    backup_path = os.path.join(BACKUP_DIR, f\"database_{timestamp}.db\")\n\n    shutil.copy2(database_path, backup_path)\n    return backup_path\n\nif __name__ == \"__main__\":\n    print(create_backup())\n# /src/app/backups/create_backup.py ",
                    "restore_backup.py": "# /src/app/backups/restore_backup.py \nimport os\nimport shutil\nfrom src.app.backups.create_backup import create_backup\nfrom src.app.core.config.database import engine\nfrom sqlalchemy import create_engine\n\n# Rutas obligatorias seg√∫n architecture_v2.0\ndatabase_path = \"src/app/db/database.db\"\n\n# Best practice: validaci√≥n estricta + atomicidad\n\ndef restore_backup(uploaded_file_path: str):\n    if not os.path.exists(uploaded_file_path):\n        raise FileNotFoundError(\"Uploaded DB file not found\")\n\n    # Validar que sea un archivo SQLite\n    if not uploaded_file_path.endswith(\".db\"):\n        raise ValueError(\"Invalid database file\")\n\n    # Crear backup previo obligatorio\n    old_backup = create_backup()\n\n    try:\n        # Cerrar engine actual\n        engine.dispose()\n\n        # Reemplazar DB\n        shutil.copy2(uploaded_file_path, database_path)\n\n        # Reiniciar engine\n        from src.app.core.config.database import engine as new_engine\n        return {\"status\": \"ok\", \"backup\": old_backup}\n\n    except Exception as e:\n        # Revertir en caso de error\n        if old_backup and os.path.exists(old_backup):\n            shutil.copy2(old_backup, database_path)\n        raise e\n\nif __name__ == \"__main__\":\n    print(\"Use this module through the API upload endpoint.\")\n# /src/app/backups/restore_backup.py ",
                    "__init__.py": "# /src/app/backups/__init__.py \n# Backups module (create + restore)\n# /src/app/backups/__init__.py "
                },
                "controllers": {
                    "auth_controller.py": "# /src/app/controllers/auth_controller.py\n\"\"\"\nAuthController ‚Äî v3.0\n\nController de autenticaci√≥n.\n\nResponsabilidades:\n- Exponer endpoints NO CRUD relacionados con autenticaci√≥n\n- Validar input HTTP m√≠nimo\n- Delegar l√≥gica de negocio al AuthService\n- Serializar respuestas HTTP (JSON)\n\nIMPORTANTE:\n- NO contiene l√≥gica de negocio\n- NO accede directamente a base de datos\n- Las excepciones se gestionan en core.exceptions.handlers\n\"\"\"\n\nfrom flask import request, g\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.auth_service import auth_service\nfrom src.app.core.logging import get_logger\nfrom src.app.core.exceptions.base import BadRequestException\n\nlogger = get_logger(__name__)\n\n\nclass AuthController(BaseController):\n    \"\"\"\n    Controller de autenticaci√≥n.\n\n    Este controller expone endpoints especiales de auth\n    que no siguen el patr√≥n CRUD est√°ndar.\n    \"\"\"\n\n    service = auth_service\n\n    # ------------------------------------------------------------\n    # LOGIN\n    # ------------------------------------------------------------\n    def login(self):\n        \"\"\"\n        Autentica un usuario y devuelve tokens JWT.\n\n        Endpoint:\n            POST /api/auth/login\n\n        Request JSON esperado:\n            {\n                \"username\": str,\n                \"password\": str\n            }\n\n        Respuesta:\n            200 OK\n            {\n                \"access_token\": str,\n                \"refresh_token\": str,\n                \"user\": dict\n            }\n\n        Raises:\n            BadRequestException: Si el body no existe.\n            UnauthorizedException: Si las credenciales son inv√°lidas.\n        \"\"\"\n\n        logger.info(\"Login request received\")\n\n        data = request.get_json()\n        if not data:\n            raise BadRequestException(\"Request body required\")\n\n        result = self.service.authenticate(\n            data.get(\"username\"),\n            data.get(\"password\"),\n        )\n\n        return self.response_ok(\n            {\n                \"access_token\": result[\"access_token\"],\n                \"refresh_token\": result[\"refresh_token\"],\n                \"user\": result[\"user\"].to_dict(),\n            }\n        )\n\n    # ------------------------------------------------------------\n    # REFRESH TOKEN\n    # ------------------------------------------------------------\n    def refresh(self, token: str):\n        \"\"\"\n        Refresca los tokens JWT a partir de un refresh_token v√°lido.\n\n        Endpoint:\n            POST /api/auth/refresh\n\n        Args:\n            token (str): Refresh token JWT.\n\n        Respuesta:\n            200 OK\n            {\n                \"access_token\": str,\n                \"refresh_token\": str,\n                \"user\": dict\n            }\n\n        Raises:\n            UnauthorizedException: Si el token es inv√°lido o ha expirado.\n        \"\"\"\n\n        logger.info(\"Refreshing token\")\n\n        result = self.service.refresh_token(token)\n\n        return self.response_ok(\n            {\n                \"access_token\": result[\"access_token\"],\n                \"refresh_token\": result[\"refresh_token\"],\n                \"user\": result[\"user\"].to_dict(),\n            }\n        )\n\n    # ------------------------------------------------------------\n    # ME\n    # ------------------------------------------------------------\n    def me(self):\n        \"\"\"\n        Devuelve la informaci√≥n del usuario autenticado.\n\n        Endpoint:\n            GET /api/auth/me\n\n        Requisitos:\n            - JWT v√°lido en el contexto (middleware)\n\n        Respuesta:\n            200 OK\n            {\n                ... user serializado ...\n            }\n        \"\"\"\n\n        logger.info(\"Fetching authenticated user data\")\n        return self.response_ok(g.current_user.to_dict())\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nauth_controller = AuthController()\n# /src/app/controllers/auth_controller.py\n",
                    "backup_controller.py": "# /src/app/controllers/backup_controller.py\n\"\"\"\nBackupController ‚Äî v3.0\n\nController de backup del sistema.\n\nResponsabilidad:\n- Exponer endpoints t√©cnicos de export / restore\n- Delegar la l√≥gica de filesystem/DB en el BackupService\n\nIMPORTANTE:\n- Las excepciones se gestionan en core.exceptions.handlers\n\"\"\"\n\nfrom flask import send_file, request\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.backup_service import backup_service\nfrom src.app.core.logging import get_logger\nfrom src.app.core.exceptions.base import BadRequestException\n\nlogger = get_logger(__name__)\n\n\nclass BackupController(BaseController):\n    \"\"\"\n    Controller de Backup (endpoints especiales).\n    \"\"\"\n\n    service = backup_service\n\n    # ------------------------------------------------------------\n    # ENDPOINTS ESPEC√çFICOS\n    # ------------------------------------------------------------\n    def export_backup(self):\n        logger.info(\"Exporting database backup\")\n        database_path = self.service.export_database()\n        return send_file(\n            database_path,\n            as_attachment=True,\n            download_name=\"backup.sqlite3\",\n            mimetype=\"application/octet-stream\",\n        )\n\n    def restore_backup(self):\n        logger.info(\"Restoring database backup\")\n        if \"file\" not in request.files:\n            raise BadRequestException(\"File is required\")\n        uploaded_file = request.files[\"file\"]\n        result = self.service.restore_database(uploaded_file)\n        return self.response_ok(result)\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nbackup_controller = BackupController()\n\n# /src/app/controllers/backup_controller.py\n",
                    "base_controller.py": "# /src/app/controllers/base_controller.py\n\"\"\"\nBaseController ‚Äî v3.0\n\nController base del sistema DemeArizOil.\n\nResponsabilidad:\n- Orquestar peticiones HTTP\n- Construir payloads (data: dict)\n- Delegar l√≥gica en services\n- Lanzar excepciones de orquestaci√≥n\n\nIMPORTANTE:\n- Este controller SOLO devuelve respuestas HTTP de √©xito (200 / 201).\n- Las respuestas HTTP de error (400 / 401 / 403 / 404 / 409 / 500)\n  se gestionan EXCLUSIVAMENTE en core.exceptions.handlers.\n- Los controllers lanzan excepciones, nunca construyen errores HTTP.\n\"\"\"\n\nfrom flask import request, jsonify\nfrom src.app.core.logging import get_logger\nfrom src.app.services.base_service import BaseService\nfrom src.app.core.exceptions import BadRequestException\n\nlogger = get_logger(__name__)\n\n\nclass BaseController:\n    \"\"\"\n    Controller base para recursos CRUD.\n\n    Todo controller concreto DEBE asignar:\n    - service: instancia de un Service que herede de BaseService\n    \"\"\"\n\n    service: BaseService\n\n    # ------------------------------------------------------------\n    # HELPERS DE INPUT\n    # ------------------------------------------------------------\n    def parse_json(self, req=None, required: bool = False) -> dict:\n        \"\"\"\n        Extrae el cuerpo JSON del request.\n\n        :param req: request opcional (por defecto flask.request)\n        :param required: si True, lanza excepci√≥n si no hay body\n        :raises BadRequestException: si required=True y body vac√≠o\n        \"\"\"\n        data = (req or request).get_json(silent=True)\n\n        if required and not data:\n            raise BadRequestException(\"Request body is required\")\n\n        return data or {}\n\n    # ------------------------------------------------------------\n    # HELPERS DE RESPUESTA (SOLO √âXITO)\n    # ------------------------------------------------------------\n    def response_ok(self, data):\n        \"\"\"\n        Respuesta HTTP 200 OK.\n        \"\"\"\n        return jsonify(data), 200\n\n    def response_created(self, data):\n        \"\"\"\n        Respuesta HTTP 201 Created.\n        \"\"\"\n        return jsonify(data), 201\n\n    # ------------------------------------------------------------\n    # CRUD (usados por BaseRouter)\n    # ------------------------------------------------------------\n    def get_all(self):\n        \"\"\"\n        Devuelve todos los registros activos.\n        \"\"\"\n        items = self.service.get_all()\n        return self.response_ok([i.to_dict() for i in items])\n\n    def get_by_id(self, id: int):\n        \"\"\"\n        Devuelve un registro por ID.\n        \"\"\"\n        obj = self.service.get_by_id(id)\n        return self.response_ok(obj.to_dict())\n\n    def create(self):\n        \"\"\"\n        Crea un nuevo registro.\n        \"\"\"\n        data = self.parse_json(required=True)\n        obj = self.service.create(data)\n        return self.response_created(obj.to_dict())\n\n    def update(self, id: int):\n        \"\"\"\n        Actualiza un registro existente.\n        \"\"\"\n        data = self.parse_json(required=True)\n        obj = self.service.update(id, data)\n        return self.response_ok(obj.to_dict())\n\n    def delete(self, id: int):\n        \"\"\"\n        Soft delete de un registro.\n        \"\"\"\n        obj = self.service.delete(id)\n        return self.response_ok({}) # BaseService.delete() devuelve None\n\n    def restore(self, id: int):\n        \"\"\"\n        Restaura un registro eliminado l√≥gicamente.\n        \"\"\"\n        obj = self.service.restore(id)\n        return self.response_ok(obj.to_dict())\n\n\n# /src/app/controllers/base_controller.py",
                    "cash_account_controller.py": "# /src/app/controllers/cash_account_controller.py\n\"\"\"\nCashAccountController ‚Äî v3.0\n\nController de CashAccount.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar heredado de BaseController\n- Delegar TODA la l√≥gica de negocio y errores en el service\n\nIMPORTANTE:\n- No usa request\n- No construye errores HTTP\n- No controla manualmente estados inexistentes\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.cash_accounts_service import cash_accounts_service\n\n\nclass CashAccountController(BaseController):\n    \"\"\"\n    Controller de CashAccount.\n    \"\"\"\n\n    service = cash_accounts_service\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncash_account_controller = CashAccountController()\n\n# /src/app/controllers/cash_account_controller.py\n",
                    "cash_transfer_notes_controller.py": "# /src/app/controllers/cash_transfer_notes_controller.py\n\"\"\"\nCashTransferNotesController ‚Äî v3.0\n\nResponsabilidad (arquitectura v3.0):\n- Exponer endpoints HTTP para CashTransferNotes.\n- NO contiene l√≥gica contable.\n- NO modifica balances directamente.\n- Delega todo en CashTransferNotesService.\n\nRelaci√≥n con Cash:\n- El controller NO toca CashAccount.balance.\n- Los efectos financieros se ejecutan solo en confirm().\n- El movimiento real se ejecuta en cash_movements_service.\n\nFlujo t√≠pico en la API:\n1) Crear CashTransferNote (DRAFT)\n   POST /api/cash_transfer_notes\n\n2) Confirmar la transferencia\n   POST /api/cash_transfer_notes/<id>/confirm\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.cash_transfer_notes_service import cash_transfer_notes_service\n\n\nclass CashTransferNotesController(BaseController):\n    \"\"\"\n    Controller de CashTransferNotes.\n    \"\"\"\n\n    service = cash_transfer_notes_service\n\n    def confirm(self, id: int):\n        \"\"\"\n        Confirma un documento de transferencia de efectivo.\n\n        Efectos:\n        - Lanza un movimiento de cash v√≠a cash_movements_service\n        - Cambia el estado del documento a CONFIRMED\n\n        Nota:\n        - Si el movimiento viola invariantes contables,\n          se lanza excepci√≥n y el documento permanece en DRAFT.\n        \"\"\"\n        note = self.service.confirm(id)\n        return self.response_ok(note.to_dict())\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncash_transfer_notes_controller = CashTransferNotesController()\n\n# /src/app/controllers/cash_transfer_notes_controller.py\n",
                    "customers_controller.py": "# /src/app/controllers/customers_controller.py\n\"\"\"\nCustomersController ‚Äî v3.0\n\nController de Customers.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar heredado de BaseController\n- Delegar TODA la l√≥gica de negocio en el service\n\nIMPORTANTE:\n- No redefine m√©todos CRUD\n- No usa request\n- No construye errores HTTP\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.customers_service import customers_service\n\n\nclass CustomersController(BaseController):\n    \"\"\"\n    Controller de Customers.\n    \"\"\"\n\n    service = customers_service\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncustomers_controller = CustomersController()\n\n# /src/app/controllers/customers_controller.py\n",
                    "products_controller.py": "# /src/app/controllers/products_controller.py\n\"\"\"\nProductsController ‚Äî v3.0\n\nController de Products.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar heredado de BaseController\n- Delegar la l√≥gica en el ProductsService\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.products_service import products_service\nfrom src.app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass ProductsController(BaseController):\n    \"\"\"\n    Controller de Products.\n    \"\"\"\n\n    service = products_service\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nproducts_controller = ProductsController()\n\n# /src/app/controllers/products_controller.py\n",
                    "purchase_line_controller.py": "# /src/app/controllers/purchase_line_controller.py\n\"\"\"\nPurchaseLineController ‚Äî v3.0\n\nResponsabilidad (arquitectura v3.0):\n- Exponer endpoints HTTP para gestionar l√≠neas de compra (PurchaseLine).\n- NO contiene l√≥gica de negocio.\n- NO confirma documentos.\n- Delega validaciones y persistencia al PurchaseLinesService.\n\nRelaci√≥n PurchaseNote ‚Üî PurchaseLine:\n- Una PurchaseLine SIEMPRE pertenece a una PurchaseNote.\n- El ID de la PurchaseNote se pasa por la URL (path param).\n- El payload de la l√≠nea NO incluye purchase_note_id.\n- El service inyecta purchase_note_id internamente.\n\nRelaci√≥n PurchaseLine ‚Üî Product (IMPORTANTE):\n- PurchaseLine referencia a Product mediante product_id.\n- El atributo `is_inventory` pertenece al Product, NO a la l√≠nea.\n- Durante la confirmaci√≥n de la PurchaseNote:\n    - Si product.is_inventory == True  ‚Üí se genera movimiento de stock\n    - Si product.is_inventory == False ‚Üí NO se genera stock\n  (ej. transporte, gastos, servicios)\n\nFlujo t√≠pico en la API:\n1) Crear PurchaseNote (DRAFT)\n   POST /api/purchase_notes\n\n2) Crear l√≠neas asociadas\n   POST /api/purchase_lines/<purchase_id>/lines\n\n3) Confirmar PurchaseNote\n   POST /api/purchase_notes/<id>/confirm\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.purchase_lines_service import purchase_lines_service\n\n\nclass PurchaseLineController(BaseController):\n    \"\"\"\n    Controller de PurchaseLine.\n\n    Se limita a:\n    - parsear el payload JSON\n    - delegar la creaci√≥n al service\n    - devolver la respuesta HTTP adecuada\n\n    NO:\n    - decide si hay stock o no\n    - usa is_inventory directamente\n    \"\"\"\n\n    service = purchase_lines_service\n\n    def create_line(self, purchase_id: int):\n        \"\"\"\n        Crea una l√≠nea de compra asociada a una PurchaseNote.\n\n        Endpoint:\n        POST /api/purchase_lines/<purchase_id>/lines\n\n        Path params:\n        - purchase_id: ID de la PurchaseNote a la que pertenece la l√≠nea\n\n        Payload esperado:\n        {\n            \"product_id\": int,\n            \"quantity\": float,\n            \"unit_price\": float,\n            \"total_price\": float\n        }\n\n        Notas importantes:\n        - El payload NO incluye purchase_note_id.\n        - El payload NO incluye is_inventory.\n        - `is_inventory` se obtiene desde Product en la fase de confirmaci√≥n.\n        \"\"\"\n        data = self.parse_json(required=True)\n\n        line = self.service.create_line(purchase_id, data)\n\n        return self.response_created(line.to_dict())\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\npurchase_line_controller = PurchaseLineController()\n\n# /src/app/controllers/purchase_line_controller.py\n",
                    "purchase_notes_controller.py": "# /src/app/controllers/purchase_notes_controller.py\n\"\"\"\nPurchaseNotesController ‚Äî v3.0\n\nResponsabilidad (arquitectura v3.0):\n- Orquestar flujos de negocio de alto nivel para PurchaseNote.\n- NO contiene l√≥gica de dominio (c√°lculos, invariantes).\n- NO persiste relaciones complejas directamente.\n- Coordina services especializados.\n\nFlujo expuesto por la API:\n- POST /api/purchase_notes\n    Crea una PurchaseNote en estado DRAFT (sin l√≠neas).\n- POST /api/purchase_notes/<id>/confirm\n    Confirma una PurchaseNote existente (movimientos + estado CONFIRMED)\n\nIMPORTANTE:\n- Las l√≠neas NO son un campo del modelo PurchaseNote.\n- Las l√≠neas se gestionan v√≠a el endpoint de l√≠neas.\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.core import BadRequestException\nfrom src.app.services.purchase_notes_service import purchase_notes_service\n\nfrom datetime import date as py_date\n\n\nclass PurchaseNotesController(BaseController):\n    \"\"\"\n    Controller de PurchaseNote.\n    \"\"\"\n    service = purchase_notes_service\n\n    def create(self):\n        \"\"\"\n        Crea una PurchaseNote en estado DRAFT.\n        \"\"\"\n        payload = self.parse_json(required=True)\n\n        # ---------------------------------------------------------\n        # NORMALIZAR DATE (API ‚Üí dominio)\n        # ---------------------------------------------------------\n        if \"date\" in payload and isinstance(payload[\"date\"], str):\n            payload[\"date\"] = py_date.fromisoformat(payload[\"date\"])\n\n        # ---------------------------------------------------------\n        # VALIDACI√ìN DRAFT: no se permite paid_amount > 0 sin l√≠neas\n        # ---------------------------------------------------------\n        paid_amount = payload.get(\"paid_amount\")\n        if paid_amount is not None and float(paid_amount) > 0:\n            raise BadRequestException(\"paid_amount must be 0 when creating a DRAFT purchase note\")\n\n        note = self.service.create(payload)\n        return self.response_created(note.to_dict())\n\n    def confirm(self, id: int):\n        \"\"\"\n        Confirma una PurchaseNote existente.\n        \"\"\"\n        note = self.service.confirm(id)\n        return self.response_ok(note.to_dict())\n\n\npurchase_notes_controller = PurchaseNotesController()\n\n# /src/app/controllers/purchase_notes_controller.py\n",
                    "sales_line_controller.py": "# /src/app/controllers/sales_line_controller.py\n\"\"\"\nSalesLineController ‚Äî v3.0\n\nResponsabilidad (arquitectura v3.0):\n- Exponer endpoints HTTP para gestionar l√≠neas de venta (SalesLine).\n- NO contiene l√≥gica de negocio.\n- NO confirma documentos.\n- Delega validaciones y persistencia al SalesLinesService.\n\nRelaci√≥n SalesNote ‚Üî SalesLine:\n- Una SalesLine SIEMPRE pertenece a una SalesNote.\n- El ID de la SalesNote se pasa por la URL (path param).\n- El payload de la l√≠nea NO incluye sales_note_id.\n- El service inyecta sales_note_id internamente.\n\nFlujo t√≠pico en la API:\n1) Crear SalesNote (DRAFT)\n   POST /api/sales_notes\n\n2) Crear l√≠neas asociadas\n   POST /api/sales_lines/<sales_id>/lines\n\n3) Confirmar SalesNote\n   POST /api/sales_notes/<id>/confirm\n\nEste controller solo cubre el paso (2).\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.sales_lines_service import sales_lines_service\n\n\nclass SalesLineController(BaseController):\n    \"\"\"\n    Controller de SalesLine.\n\n    Se limita a:\n    - parsear el payload JSON\n    - delegar la creaci√≥n al service\n    - devolver la respuesta HTTP adecuada\n    \"\"\"\n\n    service = sales_lines_service\n\n    def create_line(self, sales_id: int):\n        \"\"\"\n        Crea una l√≠nea de venta asociada a una SalesNote.\n\n        Endpoint:\n        POST /api/sales_lines/<sales_id>/lines\n\n        Path params:\n        - sales_id: ID de la SalesNote a la que pertenece la l√≠nea\n\n        Payload esperado:\n        {\n            \"product_id\": int,\n            \"quantity\": float,\n            \"unit_price\": float,\n            \"total_price\": float\n        }\n\n        Notas:\n        - El payload NO incluye sales_note_id.\n        - El service se encarga de:\n            - inyectar sales_note_id\n            - validar que la SalesNote exista\n            - validar que est√© en estado DRAFT\n        \"\"\"\n        data = self.parse_json(required=True)\n\n        line = self.service.create_line(sales_id, data)\n\n        return self.response_created(line.to_dict())\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nsales_line_controller = SalesLineController()\n\n# /src/app/controllers/sales_line_controller.py\n",
                    "sales_notes_controller.py": "# /src/app/controllers/sales_notes_controller.py\n\"\"\"\nSalesNotesController ‚Äî v3.0\n\nResponsabilidad:\n- Orquestar el flujo de confirmaci√≥n de una venta.\n- Mantiene la misma sem√°ntica que PurchaseNotesController.\n\nDiferencias clave con Purchase:\n- No genera deuda (paid_amount suele ser igual a total_amount).\n- Impacta stock en salida.\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.sales_notes_service import sales_notes_service\nfrom datetime import date as py_date\n\n\nclass SalesNotesController(BaseController):\n    service = sales_notes_service\n\n    def create(self):\n        \"\"\"\n        Crea una SalesNote en estado DRAFT.\n        \"\"\"\n        payload = self.parse_json(required=True)\n\n        # ---------------------------------------------------------\n        # NORMALIZAR DATE (API ‚Üí dominio)\n        # ---------------------------------------------------------\n        if \"date\" in payload and isinstance(payload[\"date\"], str):\n            payload[\"date\"] = py_date.fromisoformat(payload[\"date\"])\n\n        note = self.service.create(payload)\n        return self.response_created(note.to_dict())\n\n    def confirm(self, id: int):\n        \"\"\"\n        Confirma una SalesNote existente.\n        \"\"\"\n        note = self.service.confirm(id)\n        return self.response_ok(note.to_dict())\n\n\nsales_notes_controller = SalesNotesController()\n\n# /src/app/controllers/sales_notes_controller.py\n",
                    "stock_deposit_notes_controller.py": "# /src/app/controllers/stock_deposit_notes_controller.py\n\"\"\"\nStockDepositNotesController ‚Äî v3.0\n\nResponsabilidad (arquitectura v3.0):\n- Exponer endpoints HTTP para StockDepositNotes.\n- NO contiene l√≥gica de negocio.\n- NO modifica stock.\n- Delega completamente en StockDepositNotesService.\n\nRelaci√≥n con Stock:\n- El controller NO crea ni modifica StockProductLocation.\n- El stock se modifica √∫nicamente en confirm().\n- El movimiento real se ejecuta en stock_movements_service.\n\nFlujo t√≠pico en la API:\n1) Crear StockDepositNote (DRAFT)\n   POST /api/stock_deposit_notes\n\n2) Confirmar el dep√≥sito\n   POST /api/stock_deposit_notes/<id>/confirm\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.stock_deposit_notes_service import stock_deposit_notes_service\n\n\nclass StockDepositNotesController(BaseController):\n    \"\"\"\n    Controller de StockDepositNotes.\n    \"\"\"\n\n    service = stock_deposit_notes_service\n\n    def confirm(self, id: int):\n        \"\"\"\n        Confirma un documento de dep√≥sito de stock.\n\n        Efectos:\n        - Lanza un movimiento de stock v√≠a stock_movements_service\n        - Cambia el estado del documento a CONFIRMED\n\n        Nota:\n        - Si el movimiento viola invariantes (ej. stock negativo),\n          se lanza excepci√≥n y el documento permanece en DRAFT.\n        \"\"\"\n        note = self.service.confirm(id)\n        return self.response_ok(note.to_dict())\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA\n# ------------------------------------------------------------\nstock_deposit_notes_controller = StockDepositNotesController()\n\n# /src/app/controllers/stock_deposit_notes_controller.py\n",
                    "stock_locations_controller.py": "# /src/app/controllers/stock_locations_controller.py\n\"\"\"\nStockLocationsController ‚Äî v3.0\n\nController de StockLocations.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar heredado de BaseController\n- Delegar TODA la l√≥gica de negocio y errores en el service\n\nIMPORTANTE:\n- No usa request\n- No construye errores HTTP\n- No controla manualmente estados inexistentes\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.stock_locations_service import stock_locations_service\n\n\nclass StockLocationsController(BaseController):\n    \"\"\"\n    Controller de StockLocations.\n    \"\"\"\n\n    service = stock_locations_service\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nstock_locations_controller = StockLocationsController()\n\n# /src/app/controllers/stock_locations_controller.py\n",
                    "stock_product_locations_controller.py": "# /src/app/controllers/stock_product_locations_controller.py\n\"\"\"\nStockProductLocationsController ‚Äî v3.0\n\nController de StockProductLocations.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar heredado de BaseController\n- Delegar la l√≥gica en el StockProductLocationsService\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.stock_product_locations_service import stock_product_locations_service\nfrom src.app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass StockProductLocationsController(BaseController):\n    \"\"\"\n    Controller de StockProductLocations.\n    \"\"\"\n\n    service = stock_product_locations_service\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nstock_product_locations_controller = StockProductLocationsController()\n\n# /src/app/controllers/stock_product_locations_controller.py\n",
                    "suppliers_controller.py": "# /src/app/controllers/suppliers_controller.py\n\"\"\"\nSuppliersController ‚Äî v3.0\n\nController de Suppliers.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar heredado de BaseController\n- Delegar la l√≥gica en el SuppliersService\n\"\"\"\n\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.suppliers_service import suppliers_service\nfrom src.app.core.logging import get_logger\n\nlogger = get_logger(__name__)\n\n\nclass SuppliersController(BaseController):\n    \"\"\"\n    Controller de Suppliers.\n    \"\"\"\n\n    service = suppliers_service\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nsuppliers_controller = SuppliersController()\n\n# /src/app/controllers/suppliers_controller.py\n",
                    "user_controller.py": "# /src/app/controllers/user_controller.py\n\"\"\"\nUserController ‚Äî v3.0\n\nController de usuarios.\n\nResponsabilidad:\n- Exponer CRUD est√°ndar heredado de BaseController\n- Exponer endpoint expl√≠cito de cambio de contrase√±a\n- Delegar TODA la l√≥gica de seguridad en el service y core\n\nIMPORTANTE:\n- No usa request directamente\n- No construye errores HTTP\n- No devuelve mensajes arbitrarios\n\"\"\"\n\nfrom flask import g\nfrom src.app.controllers.base_controller import BaseController\nfrom src.app.services.users_service import users_service\n\n\nclass UserController(BaseController):\n    \"\"\"\n    Controller de usuarios.\n    \"\"\"\n\n    service = users_service\n\n    # ------------------------------------------------------------\n    # ENDPOINTS ESPEC√çFICOS\n    # ------------------------------------------------------------\n    def change_password(self):\n        \"\"\"\n        Cambia la contrase√±a del usuario autenticado.\n        \"\"\"\n        data = self.parse_json(required=True)\n\n        user_id = g.current_user.id\n        old_password = data.get(\"old_password\")\n        new_password = data.get(\"new_password\")\n\n        self.service.change_password(\n            user_id=user_id,\n            old_password=old_password,\n            new_password=new_password,\n        )\n\n        return self.response_ok({})\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nuser_controller = UserController()\n\n# /src/app/controllers/user_controller.py\n",
                    "__init__.py": "# /src/app/controllers/__init__.py\n\nfrom .auth_controller import auth_controller\nfrom .user_controller import user_controller\nfrom .customers_controller import customers_controller\nfrom .suppliers_controller import suppliers_controller\nfrom .products_controller import products_controller\n\nfrom .purchase_notes_controller import purchase_notes_controller\nfrom .purchase_line_controller import purchase_line_controller\nfrom .sales_notes_controller import sales_notes_controller\nfrom .sales_line_controller import sales_line_controller\n\nfrom .cash_account_controller import cash_account_controller\nfrom .cash_transfer_notes_controller import cash_transfer_notes_controller\n\nfrom .stock_locations_controller import stock_locations_controller\nfrom .stock_product_locations_controller import stock_product_locations_controller\nfrom .stock_deposit_notes_controller import stock_deposit_notes_controller\n\n# /src/app/controllers/__init__.py\n"
                },
                "core": {
                    "config": {
                        "database.py": "# /src/app/core/config/database.py \nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import scoped_session, sessionmaker\nfrom src.app.core.config.settings import settings\n\n# Best practice: engine √∫nico y session scoped\nDATABASE_URL = f\"sqlite:///{settings.DATABASE_PATH}\"\n\nengine = create_engine(\n    DATABASE_URL,\n    connect_args={\"check_same_thread\": False},\n    echo=False\n)\n\n# ------------------------------------------------------\n# IMPORTANTE:\n# Registrar TODOS los modelos antes de crear la sesi√≥n.\n# Base importa user, products, suppliers, etc.\n# ------------------------------------------------------\nfrom src.app.db.base import Base\n\nSessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)\ndb_session = scoped_session(SessionLocal)\n\n# Hook para cerrar sesi√≥n en teardown\ndef init_app(app):\n    @app.teardown_appcontext\n    def shutdown_session(exception=None):\n        db_session.remove()\n\n# /src/app/core/config/database.py ",
                        "settings.py": "# /src/app/core/config/settings.py\n\"\"\"\nApplication Settings ‚Äî v3.0\n\nConfiguraci√≥n centralizada del backend DemeArizOil.\n\nEste m√≥dulo es la √öNICA fuente de verdad para:\n- Prefijos de API\n- Rutas p√∫blicas (sin autenticaci√≥n)\n- Configuraci√≥n JWT (secret y expiraciones)\n- Paths del sistema (BD, logs, backups)\n- Constantes de sistema y negocio\n\nPrincipios de dise√±o:\n- NO contiene l√≥gica de negocio\n- NO contiene l√≥gica de seguridad (solo configuraci√≥n)\n- NO contiene secretos hardcodeados\n- Todas las decisiones aqu√≠ deben ser expl√≠citas y auditables\n\nReferencia normativa:\n- architecture_v3.0.md\n- security_v3.0.md\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom dotenv import load_dotenv\n\n# ============================================================\n# CARGA DE VARIABLES DE ENTORNO\n# ============================================================\n\n# Carga autom√°tica de variables desde .env (si existe)\nload_dotenv()\n\n# ============================================================\n# CLASE DE CONFIGURACI√ìN\n# ============================================================\n\nclass Settings:\n    \"\"\"\n    Contenedor tipado de configuraci√≥n del sistema.\n\n    Esta clase:\n    - Lee variables de entorno\n    - Aplica valores por defecto seguros\n    - Expone configuraci√≥n inmutable al resto de la aplicaci√≥n\n\n    IMPORTANTE:\n    - No instanciar esta clase fuera de este m√≥dulo\n    - Importar siempre la instancia `settings`\n    \"\"\"\n\n    # --------------------------------------------------------\n    # API\n    # --------------------------------------------------------\n\n    # Prefijo global de la API\n    # Ejemplos:\n    #   /api\n    #   /api/v1\n    API_PREFIX: str = os.getenv(\"API_PREFIX\", \"/api\")\n\n    # --------------------------------------------------------\n    # RUTAS P√öBLICAS (SIN JWT)\n    # --------------------------------------------------------\n    # Lista expl√≠cita y centralizada de rutas que NO requieren autenticaci√≥n.\n    #\n    # Reglas:\n    # - Toda ruta NO incluida aqu√≠ requiere JWT v√°lido\n    # - Security NO conoce routers ni controllers\n    # - El prefijo de API se construye din√°micamente\n    #\n    PUBLIC_PATHS: list[str] = [\n        \"/\",  # ra√≠z / landing / health b√°sica\n        f\"{API_PREFIX}/auth/login\",\n        f\"{API_PREFIX}/auth/refresh\",\n    ]\n\n    # --------------------------------------------------------\n    # JWT / AUTH\n    # --------------------------------------------------------\n\n    # Secret √∫nico para firmar TODOS los JWT (access y refresh)\n    # OBLIGATORIO en producci√≥n (v√≠a entorno)\n    JWT_SECRET_KEY: str = os.getenv(\"JWT_SECRET_KEY\", \"CHANGE_ME\")\n\n    # Expiraci√≥n del access token (en minutos)\n    TOKEN_EXPIRE_MINUTES: int = int(\n        os.getenv(\"TOKEN_EXPIRE_MINUTES\", 60)\n    )\n\n    # Expiraci√≥n del refresh token (en d√≠as)\n    REFRESH_EXPIRE_DAYS: int = int(\n        os.getenv(\"REFRESH_EXPIRE_DAYS\", 30)\n    )\n\n    # --------------------------------------------------------\n    # BASE DE DATOS\n    # --------------------------------------------------------\n\n    # Path al archivo SQLite.\n    #\n    # Notas:\n    # - Relativo al root del proyecto\n    # - Puede sobreescribirse para tests o backups\n    #\n    DATABASE_PATH: str = os.getenv(\n        \"DATABASE_PATH\",\n        \"src/app/db/database.db\",\n    )\n\n    # --------------------------------------------------------\n    # ENTIDADES DEL SISTEMA (CONSTANCIAS DE NEGOCIO)\n    # --------------------------------------------------------\n\n    # Nombre can√≥nico de la cuenta principal de DEME (cash)\n    DEME_CASH_ACCOUNT_NAME: str = \"DEME_CASH\"\n\n    # Nombre can√≥nico de la ubicaci√≥n principal de stock de DEME\n    DEME_STOCK_LOCATION_NAME: str = \"DEME_STOCK\"\n\n    # Patr√≥n para generar ubicaciones de stock por cliente\n    # Ejemplo: customer_12_stock\n    CUSTOMER_STOCK_LOCATION_PATTERN: str = \"customer_{id}_stock\"\n\n\n# ============================================================\n# INSTANCIA √öNICA DE CONFIGURACI√ìN\n# ============================================================\n\n# Esta es la √öNICA instancia que debe usarse en toda la app\nsettings = Settings()\n\n# /src/app/core/config/settings.py\n",
                        "__init__.py": "# /src/app/core/config/__init__.py \nfrom .settings import settings\nfrom .database import db_session, engine\n# /src/app/core/config/__init__.py "
                    },
                    "enum.py": "# /src/app/core/enum.py\n\"\"\"Domain enum ‚Äî v3.0\n\nFuente √∫nica de verdad para valores discretos del dominio.\n\nReglas:\n- Los enum NO son modelos ORM\n- Los enum NO se persisten por s√≠ mismos\n- Son usados por models y services\n- Evitan strings m√°gicos en el c√≥digo\n\nReferencia:\n- architecture_v3.0.md\n- business_logic_v3.0.md\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom enum import Enum\n\n\nclass UserRole(str, Enum):\n    \"\"\"Roles de usuario del sistema.\"\"\"\n\n    ADMIN = \"ADMIN\"\n    USER = \"USER\"\n\n\nclass DocumentStatus(str, Enum):\n    \"\"\"Estados de un documento de negocio.\"\"\"\n\n    DRAFT = \"DRAFT\"\n    CONFIRMED = \"CONFIRMED\"\n\n\nclass StockMovementType(str, Enum):\n    \"\"\"Tipos l√≥gicos de movimiento de stock.\n\n    NOTA:\n    - Este enum NO forma parte del schema\n    - Se usa solo en services para calcular efectos\n    \"\"\"\n\n    PURCHASE = \"PURCHASE\"\n    SALE = \"SALE\"\n    TRANSFER = \"TRANSFER\"\n    ADJUSTMENT = \"ADJUSTMENT\"\n\n# /src/app/core/enum.py",
                    "exceptions": {
                        "base.py": "# /src/app/core/exceptions/base.py\n\"\"\"\nExcepciones base y especializadas del proyecto.\n\nRegla:\n- Los services/controladores pueden lanzar estas excepciones.\n- El handler global las traduce a respuestas JSON con status_code.\n\"\"\"\n\nclass BaseAppException(Exception):\n    \"\"\"\n    Excepci√≥n base de la aplicaci√≥n.\n\n    Atributos:\n        error_name: Nombre l√≥gico del error (para respuesta API).\n        status_code: HTTP status asociado.\n    \"\"\"\n    error_name = \"ApplicationError\"\n    status_code = 500\n\n    def __init__(self, message: str = \"Unexpected error\"):\n        \"\"\"\n        Args:\n            message: Mensaje seguro para exponer en API.\n        \"\"\"\n        self.message = message\n        super().__init__(message)\n\n\nclass BadRequestException(BaseAppException):\n    \"\"\"400 Bad Request.\"\"\"\n    error_name = \"BadRequest\"\n    status_code = 400\n\n\nclass UnauthorizedException(BaseAppException):\n    \"\"\"401 Unauthorized.\"\"\"\n    error_name = \"Unauthorized\"\n    status_code = 401\n\n\nclass ForbiddenException(BaseAppException):\n    \"\"\"403 Forbidden.\"\"\"\n    error_name = \"Forbidden\"\n    status_code = 403\n\n\nclass NotFoundException(BaseAppException):\n    \"\"\"404 Not Found.\"\"\"\n    error_name = \"NotFound\"\n    status_code = 404\n\n\nclass ConflictException(BaseAppException):\n    \"\"\"409 Conflict.\"\"\"\n    error_name = \"Conflict\"\n    status_code = 409\n\n\nclass ServerErrorException(BaseAppException):\n    \"\"\"500 Server Error.\"\"\"\n    error_name = \"ServerError\"\n    status_code = 500\n# /src/app/core/exceptions/base.py\n",
                        "handlers.py": "# /src/app/core/exceptions/handlers.py\n\"\"\"\nHandlers globales de excepciones para Flask.\n\nConvierte:\n- Excepciones propias (BaseAppException) ‚Üí JSON consistente\n- HTTPException (Werkzeug) ‚Üí JSON consistente\n- Errores inesperados ‚Üí 500 gen√©rico + log con traceback\n\nNota:\n- Los logs de ERROR terminar√°n en app.log y exceptions.log (por configuraci√≥n de handlers).\n\"\"\"\n\nfrom flask import jsonify\nfrom werkzeug.exceptions import HTTPException\n\nfrom src.app.core.logging import get_logger\nfrom .base import BaseAppException\n\nlogger = get_logger(__name__)\n\n# ------------------------------------------------------------\n# Registro de handlers\n# ------------------------------------------------------------\n\ndef register_exception_handlers(app) -> None:\n    \"\"\"\n    Registra handlers de errores en la app Flask.\n\n    Args:\n        app: instancia de Flask.\n    \"\"\"\n\n    # --------------------------------------------------------\n    # Excepciones del dominio (BaseAppException)\n    # --------------------------------------------------------\n    @app.errorhandler(BaseAppException)\n    def handle_base_exception(e: BaseAppException):\n        \"\"\"\n        Handler para excepciones controladas del dominio.\n        \"\"\"\n        logger.error(f\"[{e.status_code}] {e.message}\")\n        return jsonify({\"error\": e.error_name, \"message\": e.message}), e.status_code\n\n    # --------------------------------------------------------\n    # Excepciones HTTP est√°ndar (Werkzeug)\n    # --------------------------------------------------------\n    @app.errorhandler(HTTPException)\n    def handle_http_exception(e: HTTPException):\n        \"\"\"\n        Handler para errores HTTP (404, 405, etc.) generados por Flask/Werkzeug.\n        \"\"\"\n        logger.warning(f\"HTTPException {e.code}: {e.description}\")\n        return jsonify({\"error\": e.name, \"message\": e.description}), e.code\n\n    # --------------------------------------------------------\n    # Excepciones no controladas\n    # --------------------------------------------------------\n    @app.errorhandler(Exception)\n    def handle_unexpected_exception(e: Exception):\n        \"\"\"\n        Handler para errores no previstos.\n        \"\"\"\n        logger.exception(\"Unexpected server error\")\n        return jsonify({\"error\": \"ServerError\", \"message\": \"Unexpected error\"}), 500\n# /src/app/core/exceptions/handlers.py",
                        "__init__.py": "# /src/app/core/exceptions/__init__.py\n\"\"\"\nPackage de excepciones del core.\n\nExpone:\n- Excepciones de dominio (para services y controllers)\n- Registro de handlers para Flask\n\"\"\"\n\nfrom .base import (\n    BaseAppException,\n    BadRequestException,\n    UnauthorizedException,\n    ForbiddenException,\n    NotFoundException,\n    ConflictException,\n    ServerErrorException,\n)\nfrom .handlers import register_exception_handlers\n\n__all__ = [\n    \"BaseAppException\",\n    \"BadRequestException\",\n    \"UnauthorizedException\",\n    \"ForbiddenException\",\n    \"NotFoundException\",\n    \"ConflictException\",\n    \"ServerErrorException\",\n    \"register_exception_handlers\",\n]\n\n# /src/app/core/exceptions/__init__.py\n"
                    },
                    "logging": {
                        "logger.py": "# /src/app/core/logging/logger.py\n\"\"\"\nSistema centralizado de logging del backend DemeArizOil.\n\nCaracter√≠sticas:\n- Un √∫nico sistema de logging para toda la aplicaci√≥n.\n- Dos archivos de salida:\n  - app.log        ‚Üí INFO y superiores\n  - exceptions.log ‚Üí ERROR y superiores\n- Rotaci√≥n autom√°tica por tama√±o.\n- Todos los m√≥dulos escriben a trav√©s del logger ra√≠z.\n\"\"\"\n\nimport logging\nfrom logging.handlers import RotatingFileHandler\nimport os\n\n# ------------------------------------------------------------\n# Configuraci√≥n b√°sica de archivos de log\n# ------------------------------------------------------------\n\nLOG_DIR = \"logs\"\nAPP_LOG = \"app.log\"\nEXCEPTIONS_LOG = \"exceptions.log\"\n\n# Aseguramos que la carpeta de logs existe\nos.makedirs(LOG_DIR, exist_ok=True)\n\n# ------------------------------------------------------------\n# Formato com√∫n para todos los logs del sistema\n# ------------------------------------------------------------\n\n_formatter = logging.Formatter(\n    \"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n    \"%Y-%m-%d %H:%M:%S\"\n)\n\n# ------------------------------------------------------------\n# Creaci√≥n de handlers (uso interno)\n# ------------------------------------------------------------\n\ndef _create_handler(filename: str, level: int) -> RotatingFileHandler:\n    \"\"\"\n    Crea un RotatingFileHandler configurado.\n\n    level es un umbral de severidad:\n    - DEBUG=10, INFO=20, WARNING=30, ERROR=40, CRITICAL=50\n    Regla: un handler con level=X escribe solo mensajes con nivel >= X.\n    Ejemplos:\n    - level=INFO  ‚Üí INFO, WARNING, ERROR, CRITICAL\n    - level=ERROR ‚Üí ERROR, CRITICAL\n\n    Args:\n        filename: Nombre del archivo dentro de LOG_DIR (ej: \"app.log\").\n        level: Umbral m√≠nimo de severidad que este handler registrar√°.\n\n    Returns:\n        RotatingFileHandler configurado.\n    \"\"\"\n    handler = RotatingFileHandler(\n        os.path.join(LOG_DIR, filename),\n        maxBytes=1_000_000,   # 1 MB por archivo\n        backupCount=5         # Mantener hasta 5 archivos antiguos\n    )\n    handler.setLevel(level)\n    handler.setFormatter(_formatter)\n    return handler\n\n# ------------------------------------------------------------\n# Inicializaci√≥n global del logging (UNA sola vez)\n# ------------------------------------------------------------\n\ndef setup_logging() -> None:\n    \"\"\"\n    Inicializa el sistema de logging global de la aplicaci√≥n.\n\n    Esta funci√≥n:\n    - Configura el logger ra√≠z.\n    - A√±ade los handlers de app.log y exceptions.log.\n    - Evita configuraciones duplicadas.\n\n    DEBE llamarse:\n    - Una sola vez\n    - Al arrancar la aplicaci√≥n (en main.py)\n    \"\"\"\n    root_logger = logging.getLogger()\n    root_logger.setLevel(logging.INFO)\n\n    # Evitar a√±adir handlers duplicados (por imports repetidos)\n    if root_logger.handlers:\n        return\n\n    # Log general de la aplicaci√≥n (INFO y superiores)\n    root_logger.addHandler(_create_handler(APP_LOG, logging.INFO))\n\n    # Log exclusivo de errores (ERROR y superiores)\n    root_logger.addHandler(_create_handler(EXCEPTIONS_LOG, logging.ERROR))\n\n# ------------------------------------------------------------\n# Obtenci√≥n de loggers l√≥gicos por m√≥dulo\n# ------------------------------------------------------------\n\ndef get_logger(name: str) -> logging.Logger:\n    \"\"\"\n    Devuelve un logger l√≥gico identificado por nombre.\n\n    Importante:\n    - Este m√©todo NO crea archivos.\n    - NO a√±ade handlers.\n    - El logger obtenido propaga sus mensajes al logger ra√≠z.\n\n    Uso recomendado:\n        logger = get_logger(__name__)\n\n    :param name: Nombre del m√≥dulo (normalmente __name__)\n    :return: Logger configurado\n    \"\"\"\n    return logging.getLogger(name)\n# /src/app/core/logging/logger.py",
                        "__init__.py": "# /src/app/core/logging/__init__.py\n\"\"\"\nCore logging package for DemeArizOil backend.\n\nEste m√≥dulo expone una API m√≠nima y controlada para el sistema de logging\ndel proyecto, evitando configuraciones duplicadas o dispersas.\n\nUso esperado:\n- setup_logging(): se llama UNA vez al arrancar la aplicaci√≥n.\n- get_logger(__name__): se usa en cualquier m√≥dulo para emitir logs.\n\"\"\"\n\n# ------------------------------------------------------------\n# API p√∫blica del m√≥dulo logging\n# ------------------------------------------------------------\n\nfrom .logger import setup_logging, get_logger\n\n__all__ = [\n    \"setup_logging\",\n    \"get_logger\",\n]\n# /src/app/core/logging/__init__.py"
                    },
                    "utils": {
                        "datetime_utils.py": "# /src/app/core/utils/datetime_utils.py\n\"\"\"\nUtilidades de fechas y timestamps para DemeArizOil.\n\nObjetivo:\n- Estandarizar el formato de salida de TODOS los datetime de la aplicaci√≥n\n  (API, JWT, serializaciones) para evitar inconsistencias.\n\nFormato can√≥nico:\n- ISO8601 en UTC\n- Sin microsegundos\n- Con sufijo 'Z'\n\nEjemplo:\n- 2025-12-15T11:44:06Z\n\nNotas:\n- SQLite suele almacenar datetimes sin timezone (naive). Se asume UTC impl√≠cito.\n- Esta utilidad normaliza tanto datetimes naive como timezone-aware.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Optional\n\n# ------------------------------------------------------------\n# Normalizaci√≥n ISO8601 (UTC, sin microsegundos, sufijo Z)\n# ------------------------------------------------------------\n\ndef dt_to_iso_z(dt: Optional[datetime]) -> Optional[str]:\n    \"\"\"\n    Convierte un datetime a string ISO8601 consistente en UTC con sufijo 'Z'.\n\n    Reglas:\n    - None ‚Üí None\n    - datetime naive ‚Üí se asume UTC (tzinfo=UTC)\n    - datetime aware ‚Üí se convierte a UTC\n    - se eliminan microsegundos para evitar divergencias entre DB/token/API\n    - se fuerza el sufijo 'Z'\n\n    Args:\n        dt: datetime naive/aware o None.\n\n    Returns:\n        ISO8601 UTC con 'Z' o None.\n    \"\"\"\n    if dt is None:\n        return None\n    if dt.tzinfo is None:\n        dt = dt.replace(tzinfo=timezone.utc)\n    dt = dt.astimezone(timezone.utc).replace(microsecond=0)\n    return dt.isoformat().replace(\"+00:00\", \"Z\")\n\n# ------------------------------------------------------------\n# Epoch seconds (robusto para iat/exp de JWT)\n# ------------------------------------------------------------\n\ndef now_epoch() -> int:\n    \"\"\"\n    Timestamp actual en epoch seconds (UTC).\n\n    Returns:\n        int: segundos desde epoch.\n    \"\"\"\n    return int(datetime.now(timezone.utc).timestamp())\n\n\ndef future_epoch(delta: timedelta) -> int:\n    \"\"\"\n    Timestamp futuro en epoch seconds (UTC).\n\n    Args:\n        delta: incremento temporal.\n\n    Returns:\n        int: segundos desde epoch en el futuro.\n    \"\"\"\n    return int((datetime.now(timezone.utc) + delta).timestamp())\n# /src/app/core/utils/datetime_utils.py\n"
                    },
                    "__init__.py": "# /src/app/core/__init__.py\n\"\"\"Core package ‚Äî v3.0\n\nPunto de entrada √∫nico al n√∫cleo de la aplicaci√≥n.\n\nEste m√≥dulo expone la API p√∫blica de `core` para facilitar imports\nlimpios y coherentes en el resto del proyecto.\n\"\"\"\n\n# ============================================================\n# enum DE DOMINIO\n# ============================================================\n\nfrom src.app.core.enum import UserRole, DocumentStatus, StockMovementType\n\n# ============================================================\n# CONFIGURACI√ìN\n# ============================================================\n\nfrom src.app.core.config.settings import settings\n\n# ============================================================\n# LOGGING\n# ============================================================\n\nfrom src.app.core.logging import get_logger, setup_logging\n\n# ============================================================\n# HANDLERS DE EXCEPCIONES\n# ============================================================\n\nfrom src.app.core.exceptions import register_exception_handlers\n\n# ============================================================\n# EXCEPCIONES\n# ============================================================\n\nfrom src.app.core.exceptions import (\n    BaseAppException,\n    BadRequestException,\n    UnauthorizedException,\n    ForbiddenException,\n    NotFoundException,\n    ConflictException,\n    ServerErrorException,\n)\n\n# ============================================================\n# UTILIDADES\n# ============================================================\n\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z, now_epoch, future_epoch\n\n# ============================================================\n# DATABASE\n# ============================================================\n\nfrom src.app.core.config.database import db_session\n\n\n# /src/app/core/__init__.py"
                },
                "db": {
                    "base.py": "# /src/app/db/base.py\n\"\"\"\nDeclarative Base ‚Äî v3.0\n\nBase declarativa centralizada de SQLAlchemy para el backend DemeArizOil.\n\nResponsabilidad:\n- Definir la clase Base com√∫n para todos los modelos ORM\n- Forzar el registro de TODOS los modelos persistentes del sistema\n\nIMPORTANTE (regla cr√≠tica de SQLAlchemy):\n- SQLAlchemy SOLO crea tablas de los modelos que han sido importados\n- Si un modelo no se importa aqu√≠, su tabla NO se crea en la base de datos\n\nDecisiones de arquitectura v3.0:\n- Solo se importan MODELOS PERSISTENTES\n- Los movimientos (StockMovement, CashMovement) NO existen como tablas\n- Los documentos de negocio (PurchaseNote, SalesNote, StockDepositNotes,\n  CashTransferNote, etc.) S√ç existen como modelos ORM\n\nReferencia normativa:\n- architecture_v3.0.md\n- business_logic_v3.0.md\n\"\"\"\n\nfrom sqlalchemy.orm import declarative_base\n\n# ============================================================\n# BASE DECLARATIVA\n# ============================================================\n# Todos los modelos ORM del sistema DEBEN heredar de esta Base.\nBase = declarative_base()\n\n# ============================================================\n# REGISTRO DE MODELOS ORM (OBLIGATORIO)\n# ============================================================\n# NOTA CR√çTICA:\n# - Estos imports NO son decorativos\n# - Su √∫nico prop√≥sito es registrar los modelos en el metadata de SQLAlchemy\n# - El orden no es relevante, pero la lista debe estar COMPLETA\n\n# -----------------\n# USUARIOS Y ENTIDADES MAESTRAS\n# -----------------\nfrom src.app.models.user import User\nfrom src.app.models.product import Product\nfrom src.app.models.customer import Customer\nfrom src.app.models.supplier import Supplier\n\n# -----------------\n# STOCK\n# -----------------\n# Ubicaciones y stock por producto\nfrom src.app.models.stock_location import StockLocation\nfrom src.app.models.stock_product_location import StockProductLocation\n\n# Documento v3.0: dep√≥sito de stock f√≠sico\nfrom src.app.models.stock_deposit_note import StockDepositNote\n\n# -----------------\n# CASH\n# -----------------\n# Cuentas internas de cash\nfrom src.app.models.cash_account import CashAccount\n\n# Documento v3.0: transferencia de dinero entre cuentas internas\nfrom src.app.models.cash_transfer_note import CashTransferNote\n\n# -----------------\n# DOCUMENTOS DE COMPRA\n# -----------------\nfrom src.app.models.purchase_note import PurchaseNote\nfrom src.app.models.purchase_note_line import PurchaseNoteLine\n\n# -----------------\n# DOCUMENTOS DE VENTA\n# -----------------\nfrom src.app.models.sales_note import SalesNote\nfrom src.app.models.sales_note_line import SalesNoteLine\n\n# /src/app/db/base.py\n",
                    "database.db": "",
                    "__init__.py": "# /src/app/db/__init__.py \n\n# /src/app/db/__init__.py "
                },
                "init_data.py": "# /src/app/init_data.py\n\"\"\"\nInicializaci√≥n de datos b√°sicos del sistema (seeding).\n\nEste m√≥dulo se ejecuta al arrancar la aplicaci√≥n y garantiza que\nexisten los elementos m√≠nimos para poder operar el sistema.\n\nCaracter√≠sticas:\n- Idempotente: puede ejecutarse m√∫ltiples veces sin duplicar datos.\n- No depende de requests ni contexto HTTP.\n- Solo se usa en el arranque de la app (main.py).\n\nDatos que asegura:\n1. Usuario administrador inicial.\n2. Ubicaci√≥n de stock COMPANY de DEME.\n3. Cuenta de efectivo principal de DEME.\n\"\"\"\n\nfrom datetime import datetime, timezone\n\nfrom src.app.core import settings, get_logger, UserRole\nfrom src.app.core.config.database import db_session\nfrom src.app.security.password import hash_password\n\nfrom src.app.models.user import User\nfrom src.app.models.stock_location import StockLocation\nfrom src.app.models.cash_account import CashAccount\n\nlogger = get_logger(__name__)\n\n# ------------------------------------------------------------\n# FUNCI√ìN PRINCIPAL\n# ------------------------------------------------------------\n\ndef init_data() -> None:\n    \"\"\"\n    Inserta datos iniciales en base de datos si no existen.\n\n    Esta funci√≥n:\n    - NO borra datos existentes.\n    - NO asume una base de datos vac√≠a.\n    - Puede ejecutarse en cada arranque sin efectos secundarios.\n\n    Cualquier error aqu√≠ se considera cr√≠tico para el arranque.\n    \"\"\"\n\n    # --------------------------------------------------------\n    # 1. USUARIO ADMINISTRADOR\n    # --------------------------------------------------------\n    admin_username = getattr(settings, \"INIT_ADMIN_USERNAME\", \"admin\")\n    admin_email = getattr(settings, \"INIT_ADMIN_EMAIL\", \"admin@example.com\")\n    admin_password = getattr(settings, \"INIT_ADMIN_PASSWORD\", \"admin123\")\n\n    admin = db_session.query(User).filter(User.username == admin_username).first()\n    if not admin:\n        admin = User(\n            username=admin_username,\n            email=admin_email,\n            hash_password=hash_password(admin_password),\n            rol=UserRole.ADMIN,\n            password_changed_at=datetime.now(timezone.utc),\n        )\n        db_session.add(admin)\n        logger.info(\"Created initial admin user\")\n\n    # --------------------------------------------------------\n    # 2. UBICACI√ìN DE STOCK COMPANY (DEME)\n    # --------------------------------------------------------\n    deme_stock_name = settings.DEME_STOCK_LOCATION_NAME\n\n    deme_stock = (\n        db_session.query(StockLocation)\n        .filter(StockLocation.name == deme_stock_name)\n        .first()\n    )\n    if not deme_stock:\n        deme_stock = StockLocation(\n            name=deme_stock_name,\n        )\n        db_session.add(deme_stock)\n        logger.info(\"Created DEME COMPANY stock location\")\n\n    # --------------------------------------------------------\n    # 3. CUENTA DE EFECTIVO PRINCIPAL DE DEME\n    # --------------------------------------------------------\n    deme_cash_name = settings.DEME_CASH_ACCOUNT_NAME\n\n    deme_cash = (\n        db_session.query(CashAccount)\n        .filter(CashAccount.name == deme_cash_name)\n        .first()\n    )\n    if not deme_cash:\n        deme_cash = CashAccount(\n            name=deme_cash_name,\n            balance=2000,\n        )\n        db_session.add(deme_cash)\n        logger.info(\"Created DEME cash account\")\n\n    # --------------------------------------------------------\n    # COMMIT FINAL\n    # --------------------------------------------------------\n    db_session.commit()\n    logger.info(\"Initial data check completed successfully\")\n\n# ------------------------------------------------------------\n# EJECUCI√ìN DIRECTA (solo desarrollo / debug)\n# ------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    init_data()\n# /src/app/init_data.py\n",
                "main.py": "# /src/app/main.py\n\"\"\"\nPunto de entrada principal del backend DemeArizOil.\n\nResponsabilidades de este m√≥dulo:\n- Crear y configurar la aplicaci√≥n Flask.\n- Inicializar logging, base de datos y datos iniciales.\n- Registrar middleware, excepciones y rutas.\n- Exponer la aplicaci√≥n WSGI.\n\"\"\"\n\nfrom flask import Flask\n\n# ------------------------------------------------------------\n# Importaciones del core del proyecto\n# ------------------------------------------------------------\nfrom src.app.core import get_logger, setup_logging, register_exception_handlers, settings\n\n# ------------------------------------------------------------\n# Importaciones de base de datos (infraestructura)\n# ------------------------------------------------------------\nfrom src.app.core.config.database import engine, init_app\nfrom src.app.db.base import Base\n\n# ------------------------------------------------------------\n# Importaciones de la capa API y seguridad\n# ------------------------------------------------------------\nfrom src.app.api.api_router import api_router\nfrom src.app.security.middleware import jwt_middleware\n\n# ------------------------------------------------------------\n# Datos iniciales\n# ------------------------------------------------------------\nfrom src.app.init_data import init_data\n\n# ------------------------------------------------------------\n# Factory de la aplicaci√≥n Flask\n# ------------------------------------------------------------\ndef create_app(testing: bool = False) -> Flask:\n    \"\"\"\n    Crea y configura la aplicaci√≥n Flask.\n\n    Este m√©todo:\n    - Inicializa logging (una sola vez).\n    - Configura Flask y la base de datos.\n    - Crea las tablas.\n    - Inserta datos iniciales.\n    - Registra middleware, handlers y rutas.\n\n    :param testing: Indica si la app se ejecuta en modo testing.\n    :return: Instancia configurada de Flask.\n    \"\"\"\n\n    # --------------------------------------------------------\n    # Inicializaci√≥n del logging (OBLIGATORIO al inicio)\n    # --------------------------------------------------------\n    setup_logging()\n    logger = get_logger(__name__)\n    logger.info(\"Starting DemeArizOil backend\")\n\n    # --------------------------------------------------------\n    # Creaci√≥n de la aplicaci√≥n Flask\n    # --------------------------------------------------------\n    app = Flask(__name__)\n    app.testing = testing\n\n    # --------------------------------------------------------\n    # Inicializaci√≥n de la base de datos y configuraci√≥n\n    # --------------------------------------------------------\n    init_app(app)\n\n    # --------------------------------------------------------\n    # Creaci√≥n de tablas\n    # --------------------------------------------------------\n    Base.metadata.create_all(bind=engine)\n\n    # --------------------------------------------------------\n    # Carga de datos iniciales\n    # --------------------------------------------------------\n    if not testing:\n        try:\n            init_data()\n        except Exception:\n            logger.exception(\"Error seeding initial data\")\n\n    # --------------------------------------------------------\n    # Registro de handlers de excepciones\n    # --------------------------------------------------------\n    register_exception_handlers(app)\n\n    # --------------------------------------------------------\n    # Registro del middleware de seguridad JWT\n    # --------------------------------------------------------\n    jwt_middleware(app)\n\n    # --------------------------------------------------------\n    # Endpoint ra√≠z (healthcheck)\n    # --------------------------------------------------------\n    @app.get(\"/\")\n    def root():\n        \"\"\"\n        Endpoint de verificaci√≥n de estado del backend.\n        \"\"\"\n        return {\n            \"app\": \"DemeArizOil Backend\",\n            \"status\": \"running\",\n        }, 200\n\n    # --------------------------------------------------------\n    # Registro de la API principal\n    # --------------------------------------------------------\n    app.register_blueprint(api_router, url_prefix=\"/api\")\n\n    return app\n\n# ------------------------------------------------------------\n# Exposici√≥n de la app WSGI\n# ------------------------------------------------------------\n\napp = create_app()\n\n# ------------------------------------------------------------\n# Ejecuci√≥n directa (solo desarrollo)\n# ------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\n# /src/app/main.py\n",
                "models": {
                    "base_model.py": "# /src/app/models/base_model.py\n\"\"\"\nBaseModel ‚Äî v3.0\n\nModelo base del sistema DemeArizOil.\nDefine:\n- Identidad\n- Auditor√≠a\n- Soft delete\n- Serializaci√≥n base\n\nTODOS los modelos persistentes heredan de esta clase.\n\"\"\"\nfrom datetime import datetime, timezone\nfrom sqlalchemy import DateTime, Boolean, Integer\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.app.db.base import Base\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\n\nclass BaseModel(Base):\n    \"\"\"\n    Clase base para todos los modelos ORM persistentes.\n    \"\"\"\n\n    __abstract__ = True\n\n    # ------------------------------------------------------------\n    # CAMPOS BASE\n    # ------------------------------------------------------------\n    id: Mapped[int] = mapped_column(Integer, primary_key=True)\n\n    created_at: Mapped[datetime] = mapped_column(DateTime, default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)\n\n    deleted_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)\n\n    created_by: Mapped[int | None] = mapped_column(Integer, nullable=True)\n    updated_by: Mapped[int | None] = mapped_column(Integer, nullable=True)\n\n    # ------------------------------------------------------------\n    # SERIALIZACI√ìN\n    # ------------------------------------------------------------\n    def to_dict(self) -> dict:\n        \"\"\"\n        Serializa los campos base del modelo.\n\n        Este m√©todo:\n        - DEBE ser extendido por los modelos hijos\n        - NUNCA debe ser eliminado\n        \"\"\"\n        return {\n            \"id\": self.id,\n            \"is_active\": self.is_active,\n            \"created_at\": dt_to_iso_z(self.created_at),\n            \"updated_at\": dt_to_iso_z(self.updated_at),\n            \"deleted_at\": dt_to_iso_z(self.deleted_at),\n            \"created_by\": self.created_by,\n            \"updated_by\": self.updated_by,\n        }\n# /src/app/models/base_model.py\n",
                    "cash_account.py": "# /src/app/models/cash_account.py\n\"\"\"CashAccount Model ‚Äî v3.0\n\nRepresenta una cuenta de efectivo o bancaria del sistema.\n\nNotas v3.0:\n- El balance puede ser positivo o negativo seg√∫n el tipo l√≥gico de cuenta.\n- Las reglas de dominio (empresa >= 0, proveedor <= 0) se validan en services.\n\nReglas:\n- Sin l√≥gica de negocio.\n- Serializaci√≥n consistente v√≠a BaseModel.to_dict().\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import Numeric, String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.app.models.base_model import BaseModel\n\n\nclass CashAccount(BaseModel):\n    \"\"\"Cuenta de cash/banco persistente.\"\"\"\n\n    __tablename__ = \"cash_accounts\"\n\n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)\n    balance: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False, default=0)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        data = super().to_dict()\n        data.update({\"name\": self.name, \"balance\": float(self.balance)})\n        return data\n\n# /src/app/models/cash_account.py\n",
                    "cash_transfer_note.py": "# /src/app/models/cash_transfer_note.py\n\"\"\"CashTransferNote Model ‚Äî v3.0\n\nDocumento de transferencia de cash entre cuentas internas.\n\nRegla de dominio:\n- Esta transferencia nunca debe generar balance positivo en cuentas de proveedor.\n- La validaci√≥n se realiza en services.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import CheckConstraint, Date, ForeignKey, Numeric, String, Enum as SAEnum\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom datetime import datetime, timezone\nfrom sqlalchemy import DateTime\n\n\nfrom src.app.models.base_model import BaseModel\nfrom src.app.core import DocumentStatus\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\n\n\n\nclass CashTransferNote(BaseModel):\n    \"\"\"Documento de transferencia de cash.\"\"\"\n\n    __tablename__ = \"cash_transfer_notes\"\n\n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    from_cash_account_id: Mapped[int] = mapped_column(ForeignKey(\"cash_accounts.id\"), nullable=False)\n    to_cash_account_id: Mapped[int] = mapped_column(ForeignKey(\"cash_accounts.id\"), nullable=False)\n\n    date: Mapped[datetime] = mapped_column(DateTime, default=lambda: datetime.now(timezone.utc))\n    status: Mapped[DocumentStatus] = mapped_column(SAEnum(DocumentStatus), nullable=False)\n\n    amount: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)\n    notes: Mapped[str | None] = mapped_column(String(255), nullable=True)\n\n    __table_args__ = (\n        CheckConstraint(\"amount > 0\", name=\"ck_cash_transfer_amount_positive\"),\n    )\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        data = super().to_dict()\n        data.update({\n            \"from_cash_account_id\": self.from_cash_account_id,\n            \"to_cash_account_id\": self.to_cash_account_id,\n            \"date\": dt_to_iso_z(self.date),\n            \"status\": self.status,\n            \"amount\": float(self.amount),\n            \"notes\": self.notes,\n        })\n        return data\n\n# /src/app/models/cash_transfer_note.py\n",
                    "customer.py": "# /src/app/models/customer.py\n\"\"\"Customer Model ‚Äî v3.0\n\nRepresenta un cliente del sistema.\n\nNotas:\n- En v3.0 el cliente puede tener stock \"depositado\" mediante ubicaciones y documentos,\n  pero el modelo Customer no necesita relaciones ORM directas para ello.\n\nReglas:\n- Sin l√≥gica de negocio.\n- Serializaci√≥n consistente v√≠a BaseModel.to_dict().\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.app.models.base_model import BaseModel\n\n\nclass Customer(BaseModel):\n    \"\"\"Entidad cliente persistente.\"\"\"\n\n    __tablename__ = \"customers\"\n\n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)\n    phone: Mapped[str] = mapped_column(String(30), nullable=True)\n    email: Mapped[str] = mapped_column(String(100), nullable=True)\n    address: Mapped[str] = mapped_column(String(200), nullable=True)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        \"\"\"Serializa el cliente para exposici√≥n en API.\n\n        Returns:\n            dict: representaci√≥n serializable del cliente.\n        \"\"\"\n\n        data = super().to_dict() # Datos heredados\n        data.update({\"name\": self.name, \"phone\": self.phone, \"email\": self.email, \"address\": self.address}) # Datos del modelo\n        return data\n\n# /src/app/models/customer.py",
                    "product.py": "# /src/app/models/product.py\n\"\"\"Product Model ‚Äî v3.0\n\nRepresenta un producto comercializado por el sistema.\n\nReglas:\n- Sin l√≥gica de negocio.\n- cost_average se gestiona en services.\n- Serializaci√≥n consistente v√≠a BaseModel.to_dict().\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import Boolean, Numeric, String\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom src.app.models.base_model import BaseModel\n\n\nclass Product(BaseModel):\n    \"\"\"Producto persistente.\"\"\"\n\n    __tablename__ = \"products\"\n\n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    name: Mapped[str] = mapped_column(String(150), nullable=False, unique=True)\n    unit_measure: Mapped[str] = mapped_column(String(50), nullable=False)\n    is_inventory: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)\n    cost_average: Mapped[float] = mapped_column(Numeric(18, 6), default=0, nullable=False)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        \"\"\"Serializa el producto para exposici√≥n en API.\n\n        Returns:\n            dict: representaci√≥n serializable del producto.\n        \"\"\"\n\n        data = super().to_dict() # Datos heredados\n        data.update({\"name\": self.name, \"unit_measure\": self.unit_measure, \"is_inventory\": self.is_inventory, \"cost_average\": float(self.cost_average)}) # Datos del modelo\n        return data\n\n# /src/app/models/product.py",
                    "purchase_note.py": "# /src/app/models/purchase_note.py\n\"\"\"PurchaseNote Model ‚Äî v3.0\n\nDocumento de compra a proveedor.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import CheckConstraint, Date, ForeignKey, Numeric, Enum as SAEnum\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom datetime import datetime, timezone\nfrom sqlalchemy import DateTime\n\n\nfrom src.app.models.base_model import BaseModel\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\nfrom src.app.core import DocumentStatus\n\nclass PurchaseNote(BaseModel):\n    \"\"\"Documento de compra persistente.\"\"\"\n\n    __tablename__ = \"purchase_notes\"\n    \n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    supplier_id: Mapped[int] = mapped_column(ForeignKey(\"suppliers.id\"), nullable=False)\n    date: Mapped[datetime] = mapped_column(DateTime, default=lambda: datetime.now(timezone.utc))\n    status: Mapped[DocumentStatus] = mapped_column(SAEnum(DocumentStatus), nullable=False)\n\n    total_amount: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)\n    paid_amount: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)\n\n    __table_args__ = (\n        CheckConstraint(\"total_amount >= paid_amount\", name=\"ck_purchase_total_ge_paid\"),\n    )\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        \"\"\"Serializa el cliente para exposici√≥n en API.\n\n        Returns:\n            dict: representaci√≥n serializable del cliente.\n        \"\"\"\n\n        data = super().to_dict() # Datos heredados\n        data.update({\"supplier_id\": self.supplier_id, \"date\": dt_to_iso_z(self.date), \"status\": self.status, \"total_amount\": float(self.total_amount), \"paid_amount\": float(self.paid_amount)}) # Datos del modelo\n        return data\n\n# /src/app/models/purchase_note.py\n",
                    "purchase_note_line.py": "# /src/app/models/purchase_note_line.py\n\"\"\"PurchaseNoteLine Model ‚Äî v3.0\n\nRepresenta una l√≠nea de producto dentro de un documento de compra.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import ForeignKey, Numeric\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.app.models.base_model import BaseModel\n\n\nclass PurchaseNoteLine(BaseModel):\n    \"\"\"L√≠nea de documento de compra.\"\"\"\n\n    __tablename__ = \"purchase_note_lines\"\n    \n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    purchase_note_id: Mapped[int] = mapped_column(ForeignKey(\"purchase_notes.id\"), nullable=False)\n    product_id: Mapped[int] = mapped_column(ForeignKey(\"products.id\"), nullable=False)\n\n    quantity: Mapped[float] = mapped_column(Numeric(12, 3), nullable=False)\n    unit_price: Mapped[float] = mapped_column(Numeric(14, 4), nullable=False)\n    total_price: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        data = super().to_dict() # Datos heredados\n        data.update({\"purchase_note_id\": self.purchase_note_id, \"product_id\": self.product_id, \"quantity\": float(self.quantity), \"unit_price\": float(self.unit_price), \"total_price\": float(self.total_price)}) # Datos del modelo\n        return data\n\n# /src/app/models/purchase_note_line.py",
                    "sales_note.py": "# /src/app/models/sales_note.py\n\"\"\"SalesNote Model ‚Äî v3.0\n\nDocumento de venta a cliente.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import CheckConstraint, Date, ForeignKey, Numeric, Enum as SAEnum\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom datetime import datetime, timezone\nfrom sqlalchemy import DateTime\n\n\nfrom src.app.models.base_model import BaseModel\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\nfrom src.app.core import DocumentStatus\n\nclass SalesNote(BaseModel):\n    \"\"\"Documento de venta persistente.\"\"\"\n\n    __tablename__ = \"sales_notes\"\n    \n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    customer_id: Mapped[int] = mapped_column(ForeignKey(\"customers.id\"), nullable=False)\n    date: Mapped[datetime] = mapped_column(DateTime, default=lambda: datetime.now(timezone.utc))\n    status: Mapped[DocumentStatus] = mapped_column(SAEnum(DocumentStatus), nullable=False)\n\n    total_amount: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)\n    paid_amount: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)\n\n    __table_args__ = (\n        CheckConstraint(\"total_amount = paid_amount\", name=\"ck_sales_total_eq_paid\"),\n    )\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        data = super().to_dict() # Datos heredados\n        data.update({\"customer_id\": self.customer_id, \"date\": dt_to_iso_z(self.date), \"status\": self.status, \"total_amount\": float(self.total_amount), \"paid_amount\": float(self.paid_amount)}) # Datos del modelo\n        return data\n\n# /src/app/models/sales_note.py\n",
                    "sales_note_line.py": "# /src/app/models/sales_note_line.py\n\"\"\"SalesNoteLine Model ‚Äî v3.0\n\nRepresenta una l√≠nea de producto dentro de un documento de venta.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import ForeignKey, Numeric\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.app.models.base_model import BaseModel\n\n\nclass SalesNoteLine(BaseModel):\n    \"\"\"L√≠nea de documento de venta.\"\"\"\n\n    __tablename__ = \"sales_note_lines\"\n    \n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    sales_note_id: Mapped[int] = mapped_column(ForeignKey(\"sales_notes.id\"), nullable=False)\n    product_id: Mapped[int] = mapped_column(ForeignKey(\"products.id\"), nullable=False)\n\n    quantity: Mapped[float] = mapped_column(Numeric(12, 3), nullable=False)\n    unit_price: Mapped[float] = mapped_column(Numeric(14, 4), nullable=False)\n    total_price: Mapped[float] = mapped_column(Numeric(14, 2), nullable=False)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        data = super().to_dict() # Datos heredados\n        data.update({\"sales_note_id\": self.sales_note_id, \"product_id\": self.product_id, \"quantity\": float(self.quantity), \"unit_price\": float(self.unit_price), \"total_price\": float(self.total_price)}) # Datos del modelo\n        return data\n\n# /src/app/models/sales_note_line.py",
                    "stock_deposit_note.py": "# /src/app/models/stock_deposit_note.py\n\"\"\"StockDepositNote Model ‚Äî v3.0\n\nDocumento de movimiento de stock entre ubicaciones.\n\nNotas v3.0:\n- Persiste cantidades ni productos.\n- El impacto real en stock se calcula en stock_deposit_note_service, y se refleja en el quantity de StockProductLocation\n\nReglas:\n- Sin l√≥gica de negocio.\n- Serializaci√≥n consistente v√≠a BaseModel.to_dict().\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import Date, ForeignKey, String, Numeric, Enum as SAEnum\nfrom sqlalchemy.orm import Mapped, mapped_column\nfrom datetime import datetime, timezone\nfrom sqlalchemy import DateTime\n\n\n\nfrom src.app.models.base_model import BaseModel\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\nfrom src.app.core import DocumentStatus\n\nclass StockDepositNote(BaseModel):\n    \"\"\"Documento de dep√≥sito en la ubicaci√≥n del cliente.\"\"\"\n\n    __tablename__ = \"stock_deposit_notes\"\n\n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    from_stock_location_id: Mapped[int] = mapped_column(ForeignKey(\"stock_locations.id\"), nullable=False)\n    to_stock_location_id: Mapped[int] = mapped_column(ForeignKey(\"stock_locations.id\"), nullable=False)\n\n    date: Mapped[datetime] = mapped_column(DateTime, default=lambda: datetime.now(timezone.utc))\n    product_id: Mapped[int] = mapped_column(ForeignKey(\"products.id\"), nullable=False)\n\n    quantity: Mapped[float] = mapped_column(Numeric(12, 3), nullable=False)\n    status: Mapped[DocumentStatus] = mapped_column(SAEnum(DocumentStatus), nullable=False)\n\n    notes: Mapped[str | None] = mapped_column(String(255), nullable=True)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        data = super().to_dict()\n        data.update({\"from_stock_location_id\": self.from_stock_location_id,\"to_stock_location_id\": self.to_stock_location_id,\"date\": dt_to_iso_z(self.date), \"product_id\": self.product_id, \"quantity\": float(self.quantity),\"status\": self.status,\"notes\": self.notes})\n        return data\n\n# /src/app/models/stock_deposit_note.py\n",
                    "stock_location.py": "# /src/app/models/stock_location.py\n\"\"\"StockLocation Model ‚Äî v3.0\n\nRepresenta una ubicaci√≥n de stock.\n\nNotas v3.0:\n- NO existen movimientos como modelos persistentes (StockMovement no es tabla).\n- Las consultas de movimientos son l√≥gicas y viven en services.\n\nReglas:\n- Sin l√≥gica de negocio.\n- Serializaci√≥n consistente v√≠a BaseModel.to_dict().\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.app.models.base_model import BaseModel\n\n\nclass StockLocation(BaseModel):\n    \"\"\"Ubicaci√≥n de stock persistente.\n\n    Entidad que representa un lugar f√≠sico o l√≥gico donde se almacena stock.\n\n    Notas:\n    - No distingue tipos de ubicaci√≥n (empresa, cliente, etc.).\n    - Las reglas de negocio que dependen del uso de la ubicaci√≥n viven en services.\n    \"\"\"\n\n    __tablename__ = \"stock_locations\"\n\n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        \"\"\"Serializa la ubicaci√≥n de stock para exposici√≥n en API.\n\n        Returns:\n            dict: representaci√≥n serializable de la ubicaci√≥n.\n        \"\"\"\n\n        data = super().to_dict() # Datos heredados\n        data.update({\"name\": self.name}) # Datos del modelo\n        return data\n\n# /src/app/models/stock_location.py\n",
                    "stock_product_location.py": "# /src/app/models/stock_product_location.py\n\"\"\"StockProductLocation Model ‚Äî v3.0\n\nRepresenta el stock de un producto en una ubicaci√≥n concreta.\n\nNotas v3.0:\n- Las actualizaciones de quantity se realizan en services.\n- Este modelo es la fuente persistente del \"stock actual\".\n\nReglas:\n- Sin l√≥gica de negocio.\n- Serializaci√≥n consistente v√≠a BaseModel.to_dict().\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import ForeignKey, Numeric, CheckConstraint, UniqueConstraint\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom src.app.models.base_model import BaseModel\n\n\nclass StockProductLocation(BaseModel):\n    \"\"\"Stock por producto y ubicaci√≥n (tabla persistente).\"\"\"\n\n    __tablename__ = \"stock_product_locations\"\n\n    # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    product_id: Mapped[int] = mapped_column(ForeignKey(\"products.id\"), nullable=False)\n    stock_location_id: Mapped[int] = mapped_column(ForeignKey(\"stock_locations.id\"), nullable=False)\n    quantity: Mapped[float] = mapped_column(Numeric(12, 3), nullable=False, default=0)\n\n    __table_args__ = (\n        UniqueConstraint(\"stock_location_id\", \"product_id\", name=\"uq_stock_product_location\"),\n        CheckConstraint(\"quantity >= 0\", name=\"ck_stock_quantity_non_negative\"),\n    )\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        \"\"\"Serializa el stock (producto/ubicaci√≥n) para exposici√≥n en API.\n\n        Returns:\n            dict: representaci√≥n serializable del stock.\n        \"\"\"\n\n        data = super().to_dict()\n        data.update({\"product_id\": self.product_id, \"stock_location_id\": self.stock_location_id, \"quantity\": float(self.quantity)})\n        return data\n\n# /src/app/models/stock_product_location.py",
                    "supplier.py": "# /src/app/models/supplier.py\n\"\"\"Supplier Model ‚Äî v3.0\n\nRepresenta un proveedor del sistema.\n\nReglas:\n- Sin l√≥gica de negocio.\n- Serializaci√≥n consistente v√≠a BaseModel.to_dict().\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom sqlalchemy import String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.app.models.base_model import BaseModel\n\n\nclass Supplier(BaseModel):\n    \"\"\"Entidad proveedor persistente.\"\"\"\n\n    __tablename__ = \"suppliers\"\n\n     # ============================================================\n    # CAMPOS PRINCIPALES\n    # ============================================================\n\n    name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)\n    phone: Mapped[str] = mapped_column(String(30), nullable=True)\n    email: Mapped[str] = mapped_column(String(100), nullable=True)\n    address: Mapped[str] = mapped_column(String(200), nullable=True)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        \"\"\"Serializa el cliente para exposici√≥n en API.\n\n        Returns:\n            dict: representaci√≥n serializable del cliente.\n        \"\"\"\n\n        data = super().to_dict() # Datos heredados\n        data.update({\"name\": self.name, \"phone\": self.phone, \"email\": self.email, \"address\": self.address}) # Datos del modelo\n        return data\n\n# /src/app/models/supplier.py",
                    "user.py": "# /src/app/models/user.py\n\"\"\"User Model ‚Äî v3.0\n\nRepresenta un usuario del sistema.\n\nNotas:\n- Usado por auth, security y auditor√≠a\n- Preferencias incluidas para frontend\n- Fechas siempre normalizadas\n\nReglas:\n- hash_password NUNCA se serializa\n- Sin l√≥gica de negocio\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom sqlalchemy import DateTime, Enum as SAEnum, String\nfrom sqlalchemy.orm import Mapped, mapped_column\n\nfrom src.app.models.base_model import BaseModel\nfrom src.app.core import UserRole\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\n\nclass User(BaseModel):\n    \"\"\"Usuario persistente.\"\"\"\n\n    __tablename__ = \"users\"\n\n    # ============================================================\n    # IDENTIDAD\n    # ============================================================\n\n    username: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)\n    email: Mapped[str | None] = mapped_column(String(100), nullable=True)\n    rol: Mapped[UserRole] = mapped_column(SAEnum(UserRole), nullable=False)\n\n    # ============================================================\n    # PREFERENCIAS\n    # ============================================================\n\n    user_language: Mapped[str | None] = mapped_column(String(10), nullable=True)\n    user_theme: Mapped[str | None] = mapped_column(String(20), nullable=True)\n\n    # ============================================================\n    # SEGURIDAD\n    # ============================================================\n\n    hash_password: Mapped[str] = mapped_column(String(255), nullable=False)\n    last_login: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)\n    password_changed_at: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)\n\n    # ============================================================\n    # SERIALIZACI√ìN\n    # ============================================================\n\n    def to_dict(self) -> dict:\n        \"\"\"Serializa el usuario para API.\n\n        Seguridad:\n        - No expone hash_password\n        \"\"\"\n\n        data = super().to_dict()\n        data.update({\"username\": self.username, \"email\": self.email, \"rol\": self.rol, \"user_language\": self.user_language, \"user_theme\": self.user_theme, \"last_login\": dt_to_iso_z(self.last_login), \"password_changed_at\": dt_to_iso_z(self.password_changed_at)})\n        return data\n\n# /src/app/models/user.py\n",
                    "__init__.py": "# /src/app/models/__init__.py\n\"\"\"Models Package ‚Äî v3.0\n\nPunto de exportaci√≥n controlado de modelos ORM persistentes.\n\nReglas:\n- Solo exporta modelos persistentes (tablas reales).\n- NO exporta \"movimientos\" como modelos (v3.0 elimina StockMovement/CashMovement como tablas).\n- Mantener esta lista alineada con /src/app/db/base.py.\n\nUso:\n- Importar modelos desde este paquete es opcional.\n- El registro ORM se fuerza en /src/app/db/base.py.\n\"\"\"\n\n# ============================================================\n# BASE\n# ============================================================\n\nfrom .base_model import BaseModel\n\n# ============================================================\n# ENTIDADES\n# ============================================================\n\nfrom .user import User\nfrom .customer import Customer\nfrom .supplier import Supplier\nfrom .product import Product\n\n# ============================================================\n# STOCK\n# ============================================================\n\nfrom .stock_location import StockLocation\nfrom .stock_product_location import StockProductLocation\n\n# ============================================================\n# CASH\n# ============================================================\n\nfrom .cash_account import CashAccount\n\n# ============================================================\n# DOCUMENTOS\n# ============================================================\n\nfrom .purchase_note import PurchaseNote\nfrom .purchase_note_line import PurchaseNoteLine\nfrom .sales_note import SalesNote\nfrom .sales_note_line import SalesNoteLine\nfrom .cash_transfer_note import CashTransferNote\nfrom .stock_deposit_note import StockDepositNote\n\n__all__ = [\"BaseModel\", \"User\", \"Customer\", \"Supplier\", \"Product\", \"StockLocation\", \"StockProductLocation\", \"CashAccount\", \"PurchaseNote\", \"PurchaseNoteLine\", \"SalesNote\", \"SalesNoteLine\", \"CashTransferNote\", \"StockDepositNote\"]\n\n# /src/app/models/__init__.py"
                },
                "security": {
                    "jwt.py": "# /src/app/security/jwt.py\n\"\"\"\nJWT Utilities ‚Äî v3.0\n\nUtilidades centralizadas para la creaci√≥n y validaci√≥n de tokens JWT\nen el backend DemeArizOil.\n\nResponsabilidades de este m√≥dulo:\n- Emitir access tokens y refresh tokens\n- Definir el payload est√°ndar del proyecto\n- Normalizar timestamps de forma consistente\n- Garantizar compatibilidad con frontend y middleware\n\nDecisiones clave de dise√±o:\n- Se utiliza UN √öNICO SECRET para access y refresh tokens\n- El access token incluye un objeto `user` para consumo directo del frontend\n- El refresh token NO est√° pensado para ser le√≠do por el frontend\n- Todos los timestamps se normalizan usando datetime_utils.py\n\nIMPORTANTE:\n- Este m√≥dulo NO valida permisos ni roles\n- Este m√≥dulo NO accede a la base de datos\n- Este m√≥dulo NO contiene l√≥gica de negocio\n\nReferencia normativa:\n- security_v3.0.md\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom datetime import timedelta\nfrom typing import Any, Dict\n\nimport jwt\n\nfrom src.app.core.config.settings import settings\nfrom src.app.core.utils.datetime_utils import (\n    dt_to_iso_z,\n    now_epoch,\n    future_epoch,\n)\n\n# ============================================================\n# CONSTANTES INTERNAS\n# ============================================================\n\nJWT_ALGORITHM = \"HS256\"\n\n# ============================================================\n# HELPERS PRIVADOS\n# ============================================================\n\ndef _build_user_claim(user: Any) -> Dict[str, Any]:\n    \"\"\"\n    Construye el objeto `user` que se incluye en el payload\n    del access token.\n\n    Este objeto existe EXCLUSIVAMENTE para facilitar al frontend:\n    - identificaci√≥n del usuario\n    - carga de preferencias\n    - lectura de permisos b√°sicos\n\n    Reglas:\n    - Nunca incluir informaci√≥n sensible\n    - Nunca incluir hashes o secretos\n    - Nunca incluir objetos complejos o no serializables\n\n    Args:\n        user: instancia del modelo User.\n\n    Returns:\n        dict serializable con informaci√≥n m√≠nima del usuario.\n    \"\"\"\n    return {\n        \"id\": user.id,\n        \"username\": user.username,\n        \"rol\": user.rol,\n        \"email\": getattr(user, \"email\", None),\n        \"user_language\": getattr(user, \"user_language\", None),\n        \"user_theme\": getattr(user, \"user_theme\", None),\n        \"is_active\": user.is_active,\n        \"last_login\": dt_to_iso_z(getattr(user, \"last_login\", None)),\n    }\n\n# ============================================================\n# CREACI√ìN DE TOKENS\n# ============================================================\n\ndef create_access_token(user: Any) -> str:\n    \"\"\"\n    Crea un JWT de acceso (access token).\n\n    Uso:\n    - Se devuelve al frontend tras login\n    - Se env√≠a en cada request protegido (Authorization: Bearer)\n\n    Payload est√°ndar:\n    - sub: user.id\n    - username\n    - rol\n    - password_changed_at (normalizado)\n    - user (objeto auxiliar para frontend)\n    - type = \"access\"\n    - iat / exp (epoch seconds)\n\n    Args:\n        user: instancia del modelo User.\n\n    Returns:\n        JWT access token firmado.\n    \"\"\"\n    payload = {\n        \"sub\": user.id,\n        \"username\": user.username,\n        \"rol\": user.rol,\n        \"password_changed_at\": dt_to_iso_z(user.password_changed_at),\n        \"user\": _build_user_claim(user),\n        \"type\": \"access\",\n        \"iat\": now_epoch(),\n        \"exp\": future_epoch(\n            timedelta(minutes=settings.TOKEN_EXPIRE_MINUTES)\n        ),\n    }\n\n    return jwt.encode(\n        payload,\n        settings.JWT_SECRET_KEY,\n        algorithm=JWT_ALGORITHM,\n    )\n\n\ndef create_refresh_token(user: Any) -> str:\n    \"\"\"\n    Crea un JWT de refresco (refresh token).\n\n    Uso:\n    - Se devuelve junto con el access token en login\n    - Se utiliza √∫nicamente para obtener un nuevo access token\n    - NO est√° pensado para ser le√≠do por el frontend\n\n    Payload:\n    - sub\n    - password_changed_at\n    - type = \"refresh\"\n    - iat / exp\n\n    Args:\n        user: instancia del modelo User.\n\n    Returns:\n        JWT refresh token firmado.\n    \"\"\"\n    payload = {\n        \"sub\": user.id,\n        \"password_changed_at\": dt_to_iso_z(user.password_changed_at),\n        \"type\": \"refresh\",\n        \"iat\": now_epoch(),\n        \"exp\": future_epoch(\n            timedelta(days=settings.REFRESH_EXPIRE_DAYS)\n        ),\n    }\n\n    return jwt.encode(\n        payload,\n        settings.JWT_SECRET_KEY,\n        algorithm=JWT_ALGORITHM,\n    )\n\n# ============================================================\n# DECODIFICACI√ìN\n# ============================================================\n\ndef decode_token(token: str) -> Dict[str, Any]:\n    \"\"\"\n    Decodifica un JWT y devuelve su payload.\n\n    IMPORTANTE:\n    - Esta funci√≥n NO valida permisos\n    - La validaci√≥n funcional del token se hace en el middleware\n    - Aqu√≠ solo se verifica firma y expiraci√≥n\n\n    Args:\n        token: JWT en formato string.\n\n    Returns:\n        dict con el payload decodificado.\n\n    Raises:\n        jwt.ExpiredSignatureError\n        jwt.InvalidTokenError\n    \"\"\"\n    return jwt.decode(\n        token,\n        settings.JWT_SECRET_KEY,\n        algorithms=[JWT_ALGORITHM],\n    )\n\n# /src/app/security/jwt.py\n",
                    "middleware.py": "# /src/app/security/middleware.py\n\"\"\"\nJWT Middleware ‚Äî v3.0\n\nMiddleware de seguridad para Flask encargado de validar tokens JWT\nen todas las rutas protegidas del backend DemeArizOil.\n\nResponsabilidades principales:\n- Extraer el token JWT del header Authorization\n- Validar firma y expiraci√≥n\n- Verificar tipo de token (solo access)\n- Cargar el usuario desde base de datos\n- Verificar estado activo del usuario\n- Invalidar tokens tras cambio de contrase√±a\n- Inyectar informaci√≥n de seguridad y auditor√≠a en el contexto global (g)\n\nIMPORTANTE:\n- Este middleware NO contiene l√≥gica de negocio.\n- Este middleware NO genera tokens.\n- Este middleware NO maneja respuestas HTTP directamente:\n  lanza excepciones que son manejadas por core.exceptions.handlers.\n\nReferencia normativa:\n- security_v3.0.md\n\"\"\"\n\nfrom __future__ import annotations\n\nimport jwt\nfrom flask import g, request\n\nfrom src.app.core.config.database import db_session\nfrom src.app.core.config.settings import settings\nfrom src.app.core.exceptions.base import UnauthorizedException\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\nfrom src.app.models.user import User\n\n# ============================================================\n# REGISTRO DEL MIDDLEWARE\n# ============================================================\n\ndef jwt_middleware(app) -> None:\n    \"\"\"\n    Registra el middleware JWT en la aplicaci√≥n Flask.\n\n    Se engancha mediante `before_request` y se ejecuta\n    autom√°ticamente antes de cada request HTTP.\n\n    Args:\n        app: instancia de la aplicaci√≥n Flask.\n    \"\"\"\n\n    # ------------------------------------------------------------\n    # BEFORE REQUEST\n    # ------------------------------------------------------------\n    @app.before_request\n    def validate_jwt():\n        \"\"\"\n        Valida el token JWT de acceso para todas las rutas protegidas.\n\n        Flujo de validaci√≥n (orden cr√≠tico):\n        1. Comprobar si la ruta es p√∫blica\n        2. Extraer header Authorization\n        3. Validar formato Bearer <token>\n        4. Decodificar JWT (firma + expiraci√≥n)\n        5. Verificar tipo de token (access)\n        6. Extraer user_id (sub)\n        7. Cargar usuario desde base de datos\n        8. Verificar usuario activo\n        9. Comparar password_changed_at (invalidaci√≥n autom√°tica)\n        10. Inyectar usuario y datos de auditor√≠a en `g`\n\n        Si cualquiera de los pasos falla:\n        - Se lanza UnauthorizedException\n        - La respuesta HTTP la construye el handler global\n        \"\"\"\n\n        # --------------------------------------------------------\n        # 1. RUTAS P√öBLICAS\n        # --------------------------------------------------------\n        # Las rutas p√∫blicas se definen de forma centralizada en settings\n        if request.path in settings.PUBLIC_PATHS:\n            return None\n\n        # --------------------------------------------------------\n        # 2. HEADER AUTHORIZATION\n        # --------------------------------------------------------\n        auth_header = request.headers.get(\"Authorization\")\n        if not auth_header:\n            raise UnauthorizedException(\"Missing Authorization header\")\n\n        try:\n            scheme, token = auth_header.split()\n            if scheme.lower() != \"bearer\":\n                raise UnauthorizedException(\"Invalid Authorization scheme\")\n        except ValueError:\n            raise UnauthorizedException(\"Invalid Authorization header format\")\n\n        # --------------------------------------------------------\n        # 3. DECODIFICACI√ìN DEL TOKEN\n        # --------------------------------------------------------\n        try:\n            payload = jwt.decode(\n                token,\n                settings.JWT_SECRET_KEY,\n                algorithms=[\"HS256\"],\n            )\n        except jwt.ExpiredSignatureError:\n            raise UnauthorizedException(\"Token has expired\")\n        except jwt.InvalidTokenError:\n            raise UnauthorizedException(\"Invalid token\")\n\n        # --------------------------------------------------------\n        # 4. TIPO DE TOKEN\n        # --------------------------------------------------------\n        if payload.get(\"type\") != \"access\":\n            raise UnauthorizedException(\"Invalid token type\")\n\n        # --------------------------------------------------------\n        # 5. IDENTIDAD DEL USUARIO\n        # --------------------------------------------------------\n        user_id = payload.get(\"sub\")\n        if not user_id:\n            raise UnauthorizedException(\"Invalid token (missing sub)\")\n\n        token_pwd_changed = payload.get(\"password_changed_at\")\n        if not token_pwd_changed:\n            raise UnauthorizedException(\"Invalid token (missing password_changed_at)\")\n\n        # --------------------------------------------------------\n        # 6. CARGA DEL USUARIO DESDE BD\n        # --------------------------------------------------------\n        user = (\n            db_session.query(User)\n            .filter_by(id=user_id, is_active=True)\n            .first()\n        )\n\n        if not user:\n            raise UnauthorizedException(\"User not found or inactive\")\n\n        # --------------------------------------------------------\n        # 7. INVALIDACI√ìN POR CAMBIO DE CONTRASE√ëA\n        # --------------------------------------------------------\n        # La comparaci√≥n se hace SIEMPRE usando la normalizaci√≥n can√≥nica\n        # definida en datetime_utils.py\n        current_pwd_changed = dt_to_iso_z(user.password_changed_at)\n\n        if token_pwd_changed != current_pwd_changed:\n            raise UnauthorizedException(\"Token invalidated (password changed)\")\n\n        # --------------------------------------------------------\n        # 8. INYECCI√ìN DE CONTEXTO GLOBAL\n        # --------------------------------------------------------\n        # Usuario autenticado disponible durante todo el request\n        g.current_user = user\n\n        # Datos de auditor√≠a (no persistencia aqu√≠)\n        g.audit_user_id = user.id\n        g.audit_ip = (\n            request.headers.get(\"X-Forwarded-For\")\n            or request.remote_addr\n            or \"unknown\"\n        )\n        g.audit_user_agent = request.headers.get(\"User-Agent\", \"unknown\")\n\n        return None\n\n# /src/app/security/middleware.py\n",
                    "password.py": "# /src/app/security/password.py\n\"\"\"\nPassword Utilities ‚Äî v3.0\n\nUtilidades centralizadas para la gesti√≥n segura de contrase√±as\nen el backend DemeArizOil.\n\nResponsabilidades de este m√≥dulo:\n- Generar hashes seguros de contrase√±as\n- Verificar contrase√±as en procesos de autenticaci√≥n\n\nDecisiones clave de dise√±o:\n- Se utiliza bcrypt como algoritmo de hashing\n- Nunca se almacenan contrase√±as en texto plano\n- Este m√≥dulo NO accede a base de datos\n- Este m√≥dulo NO contiene l√≥gica de negocio\n\nIMPORTANTE:\n- El hashing y la verificaci√≥n se hacen exclusivamente aqu√≠\n- Ning√∫n otro m√≥dulo debe implementar l√≥gica de hashing\n- Los par√°metros de seguridad est√°n encapsulados en bcrypt\n\nReferencia normativa:\n- security_v3.0.md\n\"\"\"\n\nfrom __future__ import annotations\n\nimport bcrypt\n\n# ============================================================\n# HASHING DE CONTRASE√ëAS\n# ============================================================\n\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Genera un hash seguro de una contrase√±a usando bcrypt.\n\n    Proceso:\n    1. Convierte la contrase√±a a bytes\n    2. Genera un salt seguro autom√°ticamente\n    3. Aplica bcrypt para producir el hash\n    4. Devuelve el hash como string UTF-8\n\n    Seguridad:\n    - bcrypt incorpora salt interno\n    - bcrypt es resistente a ataques de fuerza bruta\n    - El coste computacional es configurable v√≠a bcrypt\n\n    Args:\n        password: contrase√±a en texto plano introducida por el usuario.\n\n    Returns:\n        Hash bcrypt serializable como string.\n    \"\"\"\n    return bcrypt.hashpw(\n        password.encode(),\n        bcrypt.gensalt(),\n    ).decode()\n\n# ============================================================\n# VERIFICACI√ìN DE CONTRASE√ëAS\n# ============================================================\n\ndef verify_password(password: str, hashed: str) -> bool:\n    \"\"\"\n    Verifica si una contrase√±a en texto plano coincide\n    con un hash bcrypt almacenado.\n\n    Proceso:\n    1. Convierte inputs a bytes\n    2. Ejecuta bcrypt.checkpw\n    3. Devuelve True o False\n\n    Comportamiento defensivo:\n    - Cualquier error de formato o tipo devuelve False\n    - No se filtra informaci√≥n sobre el motivo del fallo\n\n    Args:\n        password: contrase√±a en texto plano.\n        hashed: hash bcrypt almacenado en base de datos.\n\n    Returns:\n        True si la contrase√±a es v√°lida; False en cualquier otro caso.\n    \"\"\"\n    try:\n        return bcrypt.checkpw(\n            password.encode(),\n            hashed.encode(),\n        )\n    except Exception:\n        # Fallo silencioso por seguridad (formato inv√°lido, datos corruptos, etc.)\n        return False\n\n# /src/app/security/password.py\n",
                    "__init__.py": "# /src/app/security/__init__.py\n\"\"\"\nSecurity Package ‚Äî v3.0\n\nPaquete de seguridad del backend DemeArizOil.\n\nEste m√≥dulo act√∫a como punto de entrada √∫nico para todas las\nfuncionalidades relacionadas con seguridad, incluyendo:\n\n- Creaci√≥n y decodificaci√≥n de tokens JWT\n- Middleware de autenticaci√≥n JWT para Flask\n- Hashing y verificaci√≥n de contrase√±as\n\nObjetivos:\n- Centralizar imports de seguridad\n- Evitar dependencias directas a subm√≥dulos internos\n- Facilitar el uso correcto del sistema de seguridad\n\nIMPORTANTE:\n- Otros m√≥dulos del proyecto DEBEN importar desde aqu√≠\n  y no desde archivos internos concretos.\n- Esto permite refactorizar la implementaci√≥n interna\n  sin afectar al resto del c√≥digo.\n\nReferencia normativa:\n- architecture_v3.0.md\n- security_v3.0.md\n\"\"\"\n\n# ============================================================\n# JWT\n# ============================================================\n\nfrom .jwt import (\n    create_access_token,\n    create_refresh_token,\n    decode_token,\n)\n\n# ============================================================\n# MIDDLEWARE\n# ============================================================\n\nfrom .middleware import jwt_middleware\n\n# ============================================================\n# PASSWORDS\n# ============================================================\n\nfrom .password import (\n    hash_password,\n    verify_password,\n)\n\n# ============================================================\n# API P√öBLICA DEL PAQUETE\n# ============================================================\n\n__all__ = [\n    # JWT\n    \"create_access_token\",\n    \"create_refresh_token\",\n    \"decode_token\",\n\n    # Middleware\n    \"jwt_middleware\",\n\n    # Passwords\n    \"hash_password\",\n    \"verify_password\",\n]\n\n# /src/app/security/__init__.py\n"
                },
                "services": {
                    "auth_service.py": "# /src/app/services/auth_service.py\n\"\"\"\nAuthService ‚Äî v3.0\n\nServicio de autenticaci√≥n del sistema.\n\nResponsabilidades:\n- Verificar credenciales de usuario\n- Emitir tokens JWT (access / refresh)\n- Refrescar tokens a partir de refresh_token\n\nReglas de arquitectura:\n- NO serializa usuarios\n- NO construye payloads HTTP\n- Devuelve User ORM + tokens\n- Toda la l√≥gica de negocio de auth vive aqu√≠\n\"\"\"\n\nfrom src.app.core.config.database import db_session\nfrom src.app.core.exceptions.base import UnauthorizedException\nfrom src.app.models.user import User\nfrom src.app.security.password import verify_password\nfrom src.app.security.jwt import (\n    create_access_token,\n    create_refresh_token,\n    decode_token,\n)\nfrom src.app.core.utils.datetime_utils import dt_to_iso_z\n\n\nclass AuthService:\n    \"\"\"\n    Servicio de autenticaci√≥n.\n\n    Este service encapsula toda la l√≥gica de negocio relacionada\n    con autenticaci√≥n y gesti√≥n de tokens.\n    \"\"\"\n\n    # ------------------------------------------------------------\n    # LOGIN\n    # ------------------------------------------------------------\n    def authenticate(self, username: str, password: str) -> dict:\n        \"\"\"\n        Autentica un usuario a partir de credenciales.\n\n        Flujo:\n        - Busca el usuario activo por username\n        - Verifica la contrase√±a\n        - Emite access_token y refresh_token\n\n        Args:\n            username (str): Nombre de usuario.\n            password (str): Contrase√±a en texto plano.\n\n        Raises:\n            UnauthorizedException: Si las credenciales son inv√°lidas.\n\n        Returns:\n            dict:\n                {\n                    \"access_token\": str,\n                    \"refresh_token\": str,\n                    \"user\": User\n                }\n        \"\"\"\n\n        user = (\n            db_session.query(User)\n            .filter(User.username == username, User.is_active == True)\n            .first()\n        )\n\n        if not user:\n            raise UnauthorizedException(\"Invalid credentials\")\n\n        if not verify_password(password, user.hash_password):\n            raise UnauthorizedException(\"Invalid credentials\")\n\n        return {\n            \"access_token\": create_access_token(user),\n            \"refresh_token\": create_refresh_token(user),\n            \"user\": user,\n        }\n\n    # ------------------------------------------------------------\n    # REFRESH TOKEN\n    # ------------------------------------------------------------\n    def refresh_token(self, refresh_token: str) -> dict:\n        \"\"\"\n        Refresca los tokens JWT a partir de un refresh_token v√°lido.\n\n        Validaciones realizadas:\n        - El token es de tipo \"refresh\"\n        - El token contiene un subject (user_id)\n        - El usuario existe y est√° activo\n        - El token no ha sido invalidado por cambio de contrase√±a\n\n        Args:\n            refresh_token (str): Token JWT de tipo refresh.\n\n        Raises:\n            UnauthorizedException: Si el token es inv√°lido o ha sido invalidado.\n\n        Returns:\n            dict:\n                {\n                    \"access_token\": str,\n                    \"refresh_token\": str,\n                    \"user\": User\n                }\n        \"\"\"\n\n        payload = decode_token(refresh_token)\n\n        # Validaci√≥n de tipo de token\n        if payload.get(\"type\") != \"refresh\":\n            raise UnauthorizedException(\"Invalid refresh token\")\n\n        user_id = payload.get(\"sub\")\n        if not user_id:\n            raise UnauthorizedException(\"Invalid refresh token\")\n\n        user = (\n            db_session.query(User)\n            .filter(User.id == user_id, User.is_active == True)\n            .first()\n        )\n\n        if not user:\n            raise UnauthorizedException(\"Invalid refresh token\")\n\n        # Invalida tokens antiguos si se cambi√≥ la contrase√±a\n        if payload.get(\"password_changed_at\") != dt_to_iso_z(\n            user.password_changed_at\n        ):\n            raise UnauthorizedException(\"Token no longer valid\")\n\n        return {\n            \"access_token\": create_access_token(user),\n            \"refresh_token\": create_refresh_token(user),\n            \"user\": user,\n        }\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nauth_service = AuthService()\n# /src/app/services/auth_service.py\n",
                    "backup_service.py": "# /src/app/services/backup_service.py\n\n\"\"\"\nBackupService ‚Äî v3.0\n\nServicio de dominio para backup y restore de la base de datos.\n\nCaracter√≠sticas:\n- Independiente del motor (SQLite, MariaDB, PostgreSQL, etc.)\n- Basado en dump l√≥gico SQL\n- Acceso restringido a administradores\n\n‚ö†Ô∏è NO asume base de datos como archivo\n‚ö†Ô∏è NO usa drivers espec√≠ficos (sqlite3, mysqldump, etc.)\n‚ö†Ô∏è NO accede a config interna de core\n\"\"\"\n\nfrom flask import g\nfrom datetime import datetime, timezone\nfrom io import StringIO\n\nfrom sqlalchemy import text\n\nfrom src.app.core import (\n    ForbiddenException,\n    BadRequestException,\n    ServerErrorException,\n    db_session,\n    settings,\n)\n\n\nclass BackupService:\n    \"\"\"\n    Servicio de dominio para backup y restore de base de datos.\n    \"\"\"\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _ensure_admin(self) -> None:\n        \"\"\"\n        Garantiza que el usuario actual es administrador.\n        \"\"\"\n        user = getattr(g, \"current_user\", None)\n        if not user or user.rol != \"admin\":\n            raise ForbiddenException(\"Only admin can perform backup operations\")\n\n    # ------------------------------------------------------------\n    # EXPORT (BACKUP)\n    # ------------------------------------------------------------\n    def export(self) -> dict:\n        \"\"\"\n        Genera un dump l√≥gico de la base de datos.\n\n        Retorna:\n        - dict con filename y contenido SQL\n        \"\"\"\n        self._ensure_admin()\n\n        try:\n            buffer = StringIO()\n            connection = db_session.connection()\n\n            # Obtener todas las tablas visibles\n            tables = connection.execute(\n                text(\n                    \"\"\"\n                    SELECT table_name\n                    FROM information_schema.tables\n                    WHERE table_schema = DATABASE()\n                    \"\"\"\n                )\n            ).fetchall()\n\n            for (table_name,) in tables:\n                buffer.write(f\"-- TABLE {table_name}\\n\")\n\n                rows = connection.execute(text(f\"SELECT * FROM {table_name}\"))\n                columns = rows.keys()\n\n                for row in rows:\n                    values = []\n                    for value in row:\n                        if value is None:\n                            values.append(\"NULL\")\n                        elif isinstance(value, (int, float)):\n                            values.append(str(value))\n                        else:\n                            escaped = str(value).replace(\"'\", \"''\")\n                            values.append(f\"'{escaped}'\")\n\n                    cols = \", \".join(columns)\n                    vals = \", \".join(values)\n                    buffer.write(\n                        f\"INSERT INTO {table_name} ({cols}) VALUES ({vals});\\n\"\n                    )\n\n                buffer.write(\"\\n\")\n\n            filename = f\"backup_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}.sql\"\n\n            return {\n                \"filename\": filename,\n                \"content\": buffer.getvalue(),\n            }\n\n        except Exception as exc:\n            raise ServerErrorException(f\"Backup failed: {str(exc)}\")\n\n    # ------------------------------------------------------------\n    # RESTORE\n    # ------------------------------------------------------------\n    def restore(self, sql_content: str) -> None:\n        \"\"\"\n        Restaura la base de datos a partir de un dump SQL.\n\n        El contenido SQL debe ser:\n        - texto plano\n        - generado por export()\n        \"\"\"\n        self._ensure_admin()\n\n        if not sql_content or not isinstance(sql_content, str):\n            raise BadRequestException(\"Invalid SQL content\")\n\n        try:\n            connection = db_session.connection()\n            statements = [\n                stmt.strip()\n                for stmt in sql_content.split(\";\")\n                if stmt.strip()\n            ]\n\n            for statement in statements:\n                connection.execute(text(statement))\n\n            db_session.commit()\n\n        except Exception as exc:\n            db_session.rollback()\n            raise ServerErrorException(f\"Restore failed: {str(exc)}\")\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nbackup_service = BackupService()\n\n# /src/app/services/backup_service.py\n",
                    "base_service.py": "# /src/app/services/base_service.py\n\"\"\"\nBaseService ‚Äî v3.0\n\nService base del sistema DemeArizOil.\n\nProporciona:\n- CRUD gen√©rico\n- Soft delete\n- Restore\n- Control de errores t√©cnicos\n\nIMPORTANTE:\n- NO contiene l√≥gica de negocio\n- NO valida reglas de dominio\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom sqlalchemy.exc import IntegrityError, SQLAlchemyError\n\nfrom src.app.core.config.database import db_session\nfrom src.app.core.exceptions import (NotFoundException, BadRequestException, ServerErrorException)\nfrom src.app.models.base_model import BaseModel\n\n\nclass BaseService:\n    \"\"\"\n    Clase base para todos los services CRUD.\n    \"\"\"\n\n    model: type[BaseModel] | None = None\n\n    # ------------------------------------------------------------\n    # HELPERS INTERNOS\n    # ------------------------------------------------------------\n    def _ensure_model(self):\n        \"\"\"\n        Asegura que el service tiene un modelo asignado.\n        \"\"\"\n        if self.model is None:\n            raise ServerErrorException(\"Service model not defined\")\n\n    # ------------------------------------------------------------\n    # CRUD\n    # ------------------------------------------------------------\n    def get_all(self):\n        \"\"\"\n        Devuelve todos los registros activos del modelo.\n        \"\"\"\n        self._ensure_model()\n        return (\n            db_session.query(self.model)\n            .filter(self.model.is_active == True)\n            .all()\n        )\n\n    def get_by_id(self, id: int):\n        \"\"\"\n        Devuelve un registro activo por ID.\n        \"\"\"\n        self._ensure_model()\n\n        obj = (\n            db_session.query(self.model)\n            .filter(self.model.id == id, self.model.is_active == True)\n            .first()\n        )\n\n        if not obj:\n            raise NotFoundException(f\"{self.model.__name__} not found\")\n\n        return obj\n\n    def create(self, data: dict):\n        \"\"\"\n        Crea un nuevo registro activo.\n        \"\"\"\n        self._ensure_model()\n\n        try:\n            obj = self.model(**data)\n            db_session.add(obj)\n            db_session.commit()\n            return obj\n\n        except IntegrityError as exc:\n            db_session.rollback()\n            raise BadRequestException(\"Integrity constraint violated\") from exc\n\n        except SQLAlchemyError as exc:\n            db_session.rollback()\n            raise ServerErrorException(\"Database error during create\") from exc\n\n    def update(self, id: int, data: dict):\n        \"\"\"\n        Actualiza un registro activo.\n        \"\"\"\n        self._ensure_model()\n        obj = self.get_by_id(id)\n\n        try:\n            for key, value in data.items():\n                if not hasattr(obj, key):\n                    raise BadRequestException(f\"Invalid field: {key}\")\n                setattr(obj, key, value)\n\n            obj.updated_at = datetime.now(timezone.utc)\n            db_session.commit()\n            return obj\n\n        except IntegrityError as exc:\n            db_session.rollback()\n            raise BadRequestException(\"Integrity constraint violated\") from exc\n\n        except SQLAlchemyError as exc:\n            db_session.rollback()\n            raise ServerErrorException(\"Database error during update\") from exc\n\n    def delete(self, id: int):\n        \"\"\"\n        Soft delete de un registro.\n        \"\"\"\n        self._ensure_model()\n        obj = self.get_by_id(id)\n\n        try:\n            obj.is_active = False\n            obj.deleted_at = datetime.now(timezone.utc)\n            db_session.commit()\n            return \n\n        except SQLAlchemyError as exc:\n            db_session.rollback()\n            raise ServerErrorException(\"Database error during delete\") from exc\n\n    def restore(self, id: int):\n        \"\"\"\n        Restaura un registro eliminado l√≥gicamente.\n        \"\"\"\n        self._ensure_model()\n\n        obj = db_session.query(self.model).filter(self.model.id == id).first()\n        if not obj:\n            raise NotFoundException(f\"{self.model.__name__} not found\")\n\n        try:\n            obj.is_active = True\n            obj.deleted_at = None\n            db_session.commit()\n            return obj\n\n        except SQLAlchemyError as exc:\n            db_session.rollback()\n            raise ServerErrorException(\"Database error during restore\") from exc\n\n#BaseService NO debe exportar una instancia. Los services concretos importan la CLASE BaseService y exportan SU instancia\n# /src/app/services/base_service.py\n",
                    "cash_accounts_service.py": "# /src/app/services/cash_accounts_service.py\n\n\"\"\"\nCashAccountsService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de cuentas de efectivo.\n\n‚ö†Ô∏è NO es un CRUD simple.\n\nResponsabilidades:\n- Crear cuentas de efectivo\n- Consultar cuentas por nombre\n- Proteger la integridad del balance\n- Impedir el borrado de cuentas con balance distinto de 0\n\nReglas de dominio:\n- NO existen modelos de movimientos en v3.0\n- Una CashAccount solo puede soft-deletearse si su balance es 0\n- El estado del registro se controla exclusivamente con is_active\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.models.cash_account import CashAccount\n\nfrom src.app.core import (\n    BadRequestException,\n    ForbiddenException,\n    NotFoundException,\n)\nfrom src.app.core.config.database import db_session\n\n\nclass CashAccountsService(BaseService):\n    \"\"\"\n    Servicio de dominio para CashAccount.\n    \"\"\"\n\n    model = CashAccount\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_account(self, account_id: int) -> CashAccount:\n        \"\"\"\n        Obtiene una cuenta activa por ID o lanza excepci√≥n.\n        \"\"\"\n        account = (\n            db_session.query(CashAccount)\n            .filter(CashAccount.id == account_id, CashAccount.is_active == True)\n            .first()\n        )\n        if not account:\n            raise NotFoundException(\"CashAccount not found\")\n        return account\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> CashAccount:\n        \"\"\"\n        Crea una cuenta de efectivo validando unicidad de nombre.\n        \"\"\"\n        name = data.get(\"name\")\n        if not name:\n            raise BadRequestException(\"CashAccount name is required\")\n\n        exists = db_session.query(CashAccount).filter(\n            CashAccount.name == name,\n            CashAccount.is_active == True,\n        ).first()\n\n        if exists:\n            raise ForbiddenException(\"CashAccount name already exists\")\n\n        return super().create(data)\n\n    def delete(self, account_id: int) -> bool:\n        \"\"\"\n        Soft delete de cuenta de efectivo.\n\n        Regla:\n        - Solo se permite si balance == 0\n        \"\"\"\n        account = self._get_account(account_id)\n\n        if float(account.balance or 0) != 0:\n            raise ForbiddenException(\n                \"CashAccount cannot be deleted because balance is not zero\"\n            )\n\n        account.is_active = False\n        account.deleted_at = datetime.now(timezone.utc)\n        account.updated_by = g.current_user.id\n\n        db_session.commit()\n        return\n    # ------------------------------------------------------------\n    # M√âTODOS DE NEGOCIO\n    # ------------------------------------------------------------\n    def get_by_name(self, name: str) -> CashAccount:\n        \"\"\"\n        Obtiene una cuenta de efectivo por nombre.\n        \"\"\"\n        account = (\n            db_session.query(CashAccount)\n            .filter(CashAccount.name == name, CashAccount.is_active == True)\n            .first()\n        )\n        if not account:\n            raise NotFoundException(\"CashAccount not found\")\n        return account\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncash_accounts_service = CashAccountsService()\n\n# /src/app/services/cash_accounts_service.py\n",
                    "cash_movements_service.py": "# /src/app/services/cash_movements_service.py\n\n\"\"\"\nCashMovementsService ‚Äî v3.0\n\nServicio de dominio para ejecutar movimientos de efectivo.\n\n‚ö†Ô∏è NO es un CRUD\n‚ö†Ô∏è NO tiene modelo\n‚ö†Ô∏è NO persiste movimientos\n‚ö†Ô∏è NO conoce Documents ni cambia estados\n‚ö†Ô∏è NO asume existencia de lines salvo que se le pasen expl√≠citamente\n\nResponsabilidad √∫nica:\n- Aplicar efectos reales sobre CashAccount\n\nModelo operativo (cerrado v3.0):\nUn movement es siempre at√≥mico y se define como:\n(delta, cash_account_id)\n\nCasos permitidos:\n1) Compra:\n   - DEME cash ‚Üì paid_amount\n   - Supplier cash ‚Üì (total_amount - paid_amount)\n\n2) Venta:\n   - DEME cash ‚Üë total_amount\n\n3) Transferencia:\n   - from_cash_account ‚Üì amount\n   - to_cash_account ‚Üë amount\n\nAuditor√≠a:\n- updated_at = date (fecha del note que lanza el movement)\n- updated_by = g.current_user.id\n\"\"\"\n\nfrom datetime import datetime\nfrom decimal import Decimal\nfrom flask import g\n\nfrom src.app.models.cash_account import CashAccount\nfrom src.app.models.supplier import Supplier\nfrom src.app.models.purchase_note import PurchaseNote\nfrom src.app.models.sales_note import SalesNote\nfrom src.app.models.cash_transfer_note import CashTransferNote\n\nfrom src.app.core import BadRequestException, ForbiddenException, db_session\nfrom src.app.core.config.settings import settings\n\n\nclass CashMovementsService:\n    \"\"\"\n    Servicio puro de ejecuci√≥n de movimientos de efectivo.\n    \"\"\"\n\n    # ------------------------------------------------------------\n    # API P√öBLICA\n    # ------------------------------------------------------------\n    def apply_movement(self, aggregate, lines: list | None, date: datetime) -> None:\n        \"\"\"\n        Ejecuta un movimiento de efectivo en funci√≥n del aggregate recibido.\n        \"\"\"\n\n        if isinstance(aggregate, PurchaseNote):\n            self._apply_purchase(aggregate, date)\n            return\n\n        if isinstance(aggregate, SalesNote):\n            self._apply_sale(aggregate, date)\n            return\n\n        if isinstance(aggregate, CashTransferNote):\n            self._apply_cash_transfer(aggregate, date)\n            return\n\n        raise BadRequestException(\"Unsupported aggregate for cash movement\")\n\n    # ------------------------------------------------------------\n    # PURCHASE\n    # ------------------------------------------------------------\n    def _apply_purchase(self, purchase: PurchaseNote, date: datetime) -> None:\n        \"\"\"\n        Salida de efectivo de DEME y registro de deuda con proveedor si aplica.\n        \"\"\"\n\n        if purchase.paid_amount <= 0:\n            return\n\n        deme_account = self._get_deme_account()\n\n        self._apply_delta(\n            account=deme_account,\n            delta=Decimal(-purchase.paid_amount),\n            forbid_negative=True,\n            forbid_positive=False,\n            date=date,\n        )\n\n        if purchase.total_amount > purchase.paid_amount:\n            supplier_account = self._get_supplier_account(purchase.supplier_id)\n            debt = Decimal(purchase.total_amount - purchase.paid_amount)\n\n            self._apply_delta(\n                account=supplier_account,\n                delta=-debt,\n                forbid_negative=False,\n                forbid_positive=False,\n                date=date,\n            )\n\n    # ------------------------------------------------------------\n    # SALE\n    # ------------------------------------------------------------\n    def _apply_sale(self, sale: SalesNote, date: datetime) -> None:\n        \"\"\"\n        Entrada de efectivo en la cuenta DEME.\n        \"\"\"\n\n        if sale.total_amount <= 0:\n            return\n\n        deme_account = self._get_deme_account()\n\n        self._apply_delta(\n            account=deme_account,\n            delta=Decimal(sale.total_amount),\n            forbid_negative=False,\n            forbid_positive=False,\n            date=date,\n        )\n\n    # ------------------------------------------------------------\n    # CASH TRANSFER\n    # ------------------------------------------------------------\n    def _apply_cash_transfer(self, transfer: CashTransferNote, date: datetime) -> None:\n        \"\"\"\n        Transferencia de efectivo entre cuentas.\n        \"\"\"\n\n        from_account = self._get_account(transfer.from_cash_account_id)\n        to_account = self._get_account(transfer.to_cash_account_id)\n\n        self._apply_delta(\n            account=from_account,\n            delta=Decimal(-transfer.amount),\n            forbid_negative=True,\n            forbid_positive=False,\n            date=date,\n        )\n\n        self._apply_delta(\n            account=to_account,\n            delta=Decimal(transfer.amount),\n            forbid_negative=False,\n            forbid_positive=False,\n            date=date,\n        )\n\n    # ------------------------------------------------------------\n    # DELTA CORE\n    # ------------------------------------------------------------\n    def _apply_delta(self, account: CashAccount, delta: Decimal, forbid_negative: bool, forbid_positive: bool, date: datetime) -> None:\n        \"\"\"\n        Aplica un delta de efectivo sobre una CashAccount.\n        \"\"\"\n\n        new_balance = account.balance + delta\n\n        if forbid_negative and new_balance < 0:\n            raise ForbiddenException(\"CashAccount balance cannot become negative\")\n\n        if forbid_positive and new_balance > 0:\n            raise ForbiddenException(\"CashAccount balance cannot become positive\")\n\n        account.balance = new_balance\n        account.updated_at = date\n        account.updated_by = g.current_user.id\n\n        db_session.flush()\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_account(self, account_id: int) -> CashAccount:\n        account = (\n            db_session.query(CashAccount)\n            .filter(\n                CashAccount.id == account_id,\n                CashAccount.is_active == True,\n            )\n            .first()\n        )\n        if not account:\n            raise BadRequestException(\"CashAccount not found\")\n        return account\n\n    def _get_deme_account(self) -> CashAccount:\n        account = (\n            db_session.query(CashAccount)\n            .filter(\n                CashAccount.name == settings.DEME_CASH_ACCOUNT_NAME,\n                CashAccount.is_active == True,\n            )\n            .first()\n        )\n        if not account:\n            raise BadRequestException(\"DEME CashAccount not found\")\n        return account\n\n    def _get_supplier_account(self, supplier_id: int) -> CashAccount:\n        account = (\n            db_session.query(CashAccount)\n            .filter(\n                CashAccount.name == f\"supplier_{supplier_id}_cash\",\n                CashAccount.is_active == True,\n            )\n            .first()\n        )\n        if not account:\n            raise BadRequestException(\"Supplier cash account not found\")\n        return account\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncash_movements_service = CashMovementsService()\n\n# /src/app/services/cash_movements_service.py\n",
                    "cash_transfer_notes_service.py": "# /src/app/services/cash_transfer_notes_service.py\n\n\"\"\"\nCashTransferNotesService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de CashTransferNotes.\n\n‚ö†Ô∏è NO modifica balances directamente.\n‚ö†Ô∏è NO persiste movimientos.\n‚ö†Ô∏è NO valida invariantes de cuentas.\n\nResponsabilidades:\n- CRUD de CashTransferNotes en estado DRAFT\n- Confirmar CashTransferNotes:\n  - orquestar un movimiento de efectivo\n  - cambiar estado a CONFIRMED\n\nReglas de dominio:\n- Solo los documentos en DRAFT son editables\n- Los efectos se ejecutan exclusivamente en confirm()\n- El movimiento usa la fecha del note\n\"\"\"\n\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.services.cash_movements_service import cash_movements_service\n\nfrom src.app.models.cash_transfer_note import CashTransferNote\n\nfrom src.app.core import (BadRequestException, ForbiddenException,  NotFoundException, enum, db_session)\nfrom datetime import datetime, timezone\n\nclass CashTransferNotesService(BaseService):\n    \"\"\"\n    Servicio de dominio para CashTransferNotes.\n    \"\"\"\n\n    model = CashTransferNote\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_note(self, id: int) -> CashTransferNote:\n        \"\"\"\n        Obtiene una CashTransferNotes activa por ID o lanza excepci√≥n.\n        \"\"\"\n        note = (\n            db_session.query(CashTransferNote)\n            .filter(\n                CashTransferNote.id == id,\n                CashTransferNote.is_active == True,\n            )\n            .first()\n        )\n        if not note:\n            raise NotFoundException(\"CashTransferNote not found\")\n        return note\n\n    def _ensure_draft(self, note: CashTransferNote):\n        \"\"\"\n        Valida que el documento est√© en estado DRAFT.\n        \"\"\"\n        if note.status != enum.DocumentStatus.DRAFT:\n            raise ForbiddenException(\n                \"CashTransferNote is not editable unless in DRAFT status\"\n            )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> CashTransferNote:\n        \"\"\"\n        Crea una CashTransferNote en estado DRAFT.\n        \"\"\"\n        data[\"status\"] = enum.DocumentStatus.DRAFT\n        data[\"created_by\"] = g.current_user.id if g.current_user else None\n        return super().create(data)\n\n    def update(self, id: int, data: dict) -> CashTransferNote:\n        \"\"\"\n        Actualiza una CashTransferNote solo si est√° en DRAFT.\n        \"\"\"\n        note = self._get_note(id)\n        self._ensure_draft(note)\n\n        data[\"updated_by\"] = g.current_user.id if g.current_user else None\n        return super().update(id, data)\n\n    def delete(self, id: int) -> bool:\n        \"\"\"\n        Soft delete de una CashTransferNotes solo si est√° en DRAFT.\n        \"\"\"\n        note = self._get_note(id)\n        self._ensure_draft(note)\n\n        note.is_active = False\n        note.deleted_at = datetime.now(timezone.utc)\n        note.updated_by = g.current_user.id if g.current_user else None\n        db_session.commit()\n        return\n\n    # ------------------------------------------------------------\n    # M√âTODOS DE NEGOCIO\n    # ------------------------------------------------------------\n    def confirm(self, id: int) -> CashTransferNote:\n        \"\"\"\n        Confirma una CashTransferNote.\n\n        Este servicio NO decide reglas de negocio ni valida invariantes\n        de cuentas. Su √∫nica responsabilidad es:\n\n        - Reunir toda la informaci√≥n del documento\n        - Lanzar el movimiento de efectivo correspondiente\n        - Si no hay errores, marcar el documento como CONFIRMED\n\n        Todas las reglas de negocio (validaci√≥n de balances,\n        transferencias, invariantes contables, etc.) se validan y\n        ejecutan exclusivamente en el cash_movements_service.\n        \"\"\"\n        note = self._get_note(id)\n        self._ensure_draft(note)\n\n        if note.amount <= 0:\n            raise BadRequestException(\n                \"Transfer amount must be greater than zero\"\n            )\n\n        if note.from_cash_account_id == note.to_cash_account_id:\n            raise BadRequestException(\n                \"Source and destination cash accounts must be different\"\n            )\n\n        # --------------------------------------------------------\n        # MOVIMIENTO DE CASH\n        #\n        # Se lanza el movimiento de efectivo pasando TODA la\n        # informaci√≥n necesaria (documento y fecha).\n        #\n        # El cash_movements_service:\n        # - interpreta el documento\n        # - determina los d√©bitos y cr√©ditos\n        # - valida invariantes contables\n        # - aplica los cambios o lanza excepci√≥n\n        # --------------------------------------------------------\n        cash_movements_service.apply_movement(aggregate=note, lines=None, date=note.date)\n\n        # --------------------------------------------------------\n        # Cambio de estado del documento\n        #\n        # Si hemos llegado aqu√≠, el movimiento se ha aplicado\n        # correctamente (no hubo excepciones).\n        # --------------------------------------------------------\n        note.status = enum.DocumentStatus.CONFIRMED\n        note.updated_by = g.current_user.id if g.current_user else None\n\n        db_session.commit()\n        return note\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncash_transfer_notes_service = CashTransferNotesService()\n\n# /src/app/services/cash_transfer_notes_service.py\n",
                    "customers_service.py": "# /src/app/services/customers_service.py\n\n\"\"\"\nCustomersService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de clientes.\n\n‚ö†Ô∏è NO es un CRUD simple.\n\nResponsabilidades:\n- Crear clientes\n- Crear autom√°ticamente su StockLocation asociada\n- Proteger la integridad de stock y documentos\n- Eliminar clientes solo si no hay dependencias activas\n\nReglas de dominio:\n    - Un Customer tiene exactamente un StockLocation\n    - El StockLocation de cliente se identifica por nombre\n      usando settings.CUSTOMER_STOCK_LOCATION_PATTERN\n- La creaci√≥n del StockLocation se delega en stock_locations_service\n- Al borrar un Customer se soft-deletea tambi√©n su StockLocation\n- NO existen modelos de movimientos en v3.0\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.services.stock_locations_service import stock_locations_service\n\nfrom src.app.models.customer import Customer\nfrom src.app.models.stock_location import StockLocation\nfrom src.app.models.stock_product_location import StockProductLocation\nfrom src.app.models.sales_note import SalesNote\n\nfrom src.app.core import (BadRequestException, ForbiddenException, NotFoundException, settings)\nfrom src.app.core.config.database import db_session\n\n\nclass CustomersService(BaseService):\n    \"\"\"\n    Servicio de dominio para Customer.\n\n    Hereda BaseService y redefine create/delete\n    para aplicar reglas expl√≠citas de negocio.\n    \"\"\"\n\n    model = Customer\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_customer(self, customer_id: int) -> Customer:\n        \"\"\"\n        Obtiene un cliente activo por ID o lanza excepci√≥n.\n        \"\"\"\n        customer = (\n            db_session.query(Customer)\n            .filter(Customer.id == customer_id, Customer.is_active == True)\n            .first()\n        )\n        if not customer:\n            raise NotFoundException(\"Customer not found\")\n        return customer\n\n    def _get_customer_location(self, customer_id: int) -> StockLocation:\n        \"\"\"\n        Obtiene la StockLocation asociada a un cliente.\n        \"\"\"\n        location_name = settings.CUSTOMER_STOCK_LOCATION_PATTERN.format(\n            id=customer_id\n        )\n        location = (\n            db_session.query(StockLocation)\n            .filter(\n                StockLocation.name == location_name,\n                StockLocation.is_active == True,\n            )\n            .first()\n        )\n        if not location:\n            raise NotFoundException(\"Customer stock location not found\")\n        return location\n\n    def _ensure_customer_deletable(self, customer: Customer):\n        \"\"\"\n        Valida que un cliente pueda eliminarse sin romper integridad.\n        \"\"\"\n\n        # 1) No debe haber stock en su ubicaci√≥n\n        location = self._get_customer_location(customer.id)\n\n        stock_exists = db_session.query(StockProductLocation).filter(\n            StockProductLocation.stock_location_id == location.id,\n            StockProductLocation.quantity > 0,\n            StockProductLocation.is_active == True,\n        ).count()\n\n        if stock_exists > 0:\n            raise ForbiddenException(\n                \"Customer cannot be deleted because stock exists\"\n            )\n\n        # 2) No debe haber ventas asociadas\n        sales_exists = db_session.query(SalesNote).filter(\n            SalesNote.customer_id == customer.id,\n            SalesNote.is_active == True,\n        ).count()\n\n        if sales_exists > 0:\n            raise ForbiddenException(\n                \"Customer cannot be deleted because sales exist\"\n            )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> Customer:\n        \"\"\"\n        Crea un cliente y su StockLocation asociada.\n        \"\"\"\n\n        name = data.get(\"name\")\n        if not name:\n            raise BadRequestException(\"Customer name is required\")\n\n        customer = super().create(data)\n\n        location_name = settings.CUSTOMER_STOCK_LOCATION_PATTERN.format(\n            id=customer.id\n        )\n\n        stock_locations_service.create(\n            {\n                \"name\": location_name,\n            }\n        )\n\n        return customer\n\n    def delete(self, customer_id: int) -> bool:\n        \"\"\"\n        Soft delete de cliente con validaciones y borrado en cascada\n        de su StockLocation asociada.\n        \"\"\"\n\n        customer = self._get_customer(customer_id)\n\n        self._ensure_customer_deletable(customer)\n\n        location = self._get_customer_location(customer.id)\n\n        # Soft delete del cliente\n        customer.is_active = False\n        customer.deleted_at = datetime.now(timezone.utc)\n        customer.updated_by = g.current_user.id\n\n        # Soft delete de su StockLocation\n        location.is_active = False\n        location.deleted_at = datetime.now(timezone.utc)\n        location.updated_by = g.current_user.id\n\n        db_session.commit()\n        return\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\ncustomers_service = CustomersService()\n\n# /src/app/services/customers_service.py\n",
                    "products_service.py": "# /src/app/services/products_service.py\n\n\"\"\"\nProductsService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de productos.\n\n‚ö†Ô∏è NO es un CRUD simple.\n\nResponsabilidades:\n- Crear productos con validaciones de unicidad\n- Actualizar productos con reglas estrictas\n- Eliminar productos solo si no hay dependencias activas\n- Proteger la integridad de stock y documentos\n\nCumple architecture_v3.0:\n- Hereda BaseService\n- Exporta una instancia\n- Controllers importan la instancia\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.models.product import Product\nfrom src.app.models.stock_product_location import StockProductLocation\nfrom src.app.models.purchase_note_line import PurchaseNoteLine\nfrom src.app.models.sales_note_line import SalesNoteLine\n\nfrom src.app.core import ( BadRequestException, ForbiddenException, NotFoundException)\n\nfrom src.app.core.config.database import db_session\n\n\nclass ProductsService(BaseService):\n    \"\"\"\n    Servicio de dominio para Product.\n\n    Hereda BaseService y redefine create/update/delete\n    para aplicar reglas expl√≠citas de negocio.\n    \"\"\"\n\n    model = Product\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _ensure_product_deletable(self, product: Product):\n        \"\"\"\n        Valida que un producto pueda eliminarse sin romper integridad.\n        \"\"\"\n\n        pid = product.id\n\n        # 1) No debe haber stock disponible\n        stock_count = db_session.query(StockProductLocation).filter(\n            StockProductLocation.product_id == pid,\n            StockProductLocation.quantity > 0,\n            StockProductLocation.is_active == True,\n        ).count()\n\n        if stock_count > 0:\n            raise ForbiddenException(\n                \"Product cannot be deleted because stock exists\"\n            )\n\n        # 2) No debe aparecer en l√≠neas de compra\n        purchase_use = db_session.query(PurchaseNoteLine).filter(\n            PurchaseNoteLine.product_id == pid,\n            PurchaseNoteLine.is_active == True,\n        ).count()\n\n        if purchase_use > 0:\n            raise ForbiddenException(\n                \"Product cannot be deleted because it appears in purchase notes\"\n            )\n\n        # 3) No debe aparecer en l√≠neas de venta\n        sales_use = db_session.query(SalesNoteLine).filter(\n            SalesNoteLine.product_id == pid,\n            SalesNoteLine.is_active == True,\n        ).count()\n\n        if sales_use > 0:\n            raise ForbiddenException(\n                \"Product cannot be deleted because it appears in sales notes\"\n            )\n\n        # 4) No debe tener hist√≥rico de costes\n        if float(product.cost_average or 0) != 0:\n            raise ForbiddenException(\n                \"Product cannot be deleted because it has cost history\"\n            )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> Product:\n        \"\"\"\n        Crea un producto validando unicidad y reglas iniciales.\n        \"\"\"\n\n        name = data.get(\"name\")\n        if not name:\n            raise BadRequestException(\"Product name is required\")\n\n        exists = db_session.query(Product).filter(\n            Product.name == name,\n            Product.is_active == True,\n        ).first()\n\n        if exists:\n            raise ForbiddenException(\"Product name already exists\")\n\n        if \"cost_average\" in data:\n            raise ForbiddenException(\"cost_average cannot be set manually\")\n\n        return super().create(data)\n\n    def update(self, product_id: int, data: dict) -> Product:\n        \"\"\"\n        Actualiza un producto respetando reglas de negocio estrictas.\n        \"\"\"\n\n        product = self.get_by_id(product_id)\n\n        if \"cost_average\" in data:\n            raise ForbiddenException(\n                \"cost_average cannot be modified directly\"\n            )\n\n        if \"is_inventory\" in data:\n            if data[\"is_inventory\"] != product.is_inventory:\n                has_stock = db_session.query(StockProductLocation).filter(\n                    StockProductLocation.product_id == product.id,\n                    StockProductLocation.quantity > 0,\n                ).count()\n\n                if has_stock > 0:\n                    raise ForbiddenException(\n                        \"Cannot change is_inventory when product has stock\"\n                    )\n\n        if \"name\" in data:\n            new_name = data[\"name\"]\n            exists = db_session.query(Product).filter(\n                Product.name == new_name,\n                Product.id != product_id,\n                Product.is_active == True,\n            ).first()\n\n            if exists:\n                raise ForbiddenException(\n                    \"Another product with that name already exists\"\n                )\n\n        updated = super().update(product_id, data)\n        updated.updated_by = g.current_user.id\n\n        db_session.commit()\n        return updated\n\n    def delete(self, product_id: int) -> bool:\n        \"\"\"\n        Soft delete de producto con validaciones estrictas.\n        \"\"\"\n\n        product = self.get_by_id(product_id)\n\n        self._ensure_product_deletable(product)\n\n        product.is_active = False\n        product.deleted_at = datetime.now(timezone.utc)\n        product.updated_by = g.current_user.id\n\n        db_session.commit()\n        return\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nproducts_service = ProductsService()\n\n# /src/app/services/products_service.py\n",
                    "purchase_lines_service.py": "# /src/app/services/purchase_lines_service.py\n\"\"\"\nPurchaseLinesService ‚Äî v3.0\n\nResponsabilidad:\n- Gestionar l√≠neas de compra (PurchaseLine).\n- Validar que la PurchaseNote exista y est√© en DRAFT.\n- NO confirma documentos.\n- NO ejecuta movimientos.\n\nContrato:\n- Las l√≠neas siempre pertenecen a una PurchaseNote.\n- El ID de la nota NO viene del modelo, se inyecta aqu√≠.\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.core import (BadRequestException, ForbiddenException, NotFoundException, enum, db_session)\nfrom src.app.models.purchase_note import PurchaseNote\nfrom src.app.models.purchase_note_line import PurchaseNoteLine\n\n\nclass PurchaseLinesService(BaseService):\n    model = PurchaseNoteLine\n\n    def create_line(self, purchase_note_id: int, data: dict):\n        \"\"\"\n        Crea una l√≠nea asociada a una PurchaseNote.\n\n        Par√°metros:\n        - purchase_note_id: ID de la nota (path param en la API)\n        - data: payload de la l√≠nea SIN purchase_note_id\n\n        Ejemplo de data:\n        {\n            \"product_id\": 1,\n            \"quantity\": 10,\n            \"unit_price\": 100,\n            \"total_price\": 1000\n        }\n        \"\"\"\n        if not purchase_note_id:\n            raise BadRequestException(\"purchase_note_id is required\")\n\n        purchase = (\n            db_session.query(PurchaseNote)\n            .filter(\n                PurchaseNote.id == purchase_note_id,\n                PurchaseNote.is_active == True,\n            )\n            .first()\n        )\n        if not purchase:\n            raise NotFoundException(\"PurchaseNote not found\")\n        if purchase.status != enum.DocumentStatus.DRAFT:\n            raise ForbiddenException(\n                \"PurchaseNote is not editable unless in DRAFT status\"\n            )\n\n        payload = dict(data)\n        payload[\"purchase_note_id\"] = purchase_note_id\n\n        line = self.create(payload)\n\n        purchase.total_amount = purchase.total_amount + line.total_price\n        purchase.updated_at = datetime.now(timezone.utc)\n        purchase.updated_by = g.current_user.id if g.current_user else None\n        db_session.commit()\n\n        return line\n\n\npurchase_lines_service = PurchaseLinesService()\n\n# /src/app/services/purchase_lines_service.py\n",
                    "purchase_notes_service.py": "# /src/app/services/purchase_notes_service.py\n\n\"\"\"\nPurchaseNotesService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de PurchaseNote.\n\n‚ö†Ô∏è NO ejecuta l√≥gica de negocio de stock ni cash.\n‚úÖ Decide reglas documentales (DRAFT, l√≠neas obligatorias).\n‚ö†Ô∏è NO persiste movimientos.\n‚ö†Ô∏è NO decide reglas contables.\n\nResponsabilidades:\n- CRUD de PurchaseNote en estado DRAFT\n- Confirmar PurchaseNote:\n  - orquestar movimientos de stock y cash\n  - cambiar estado a CONFIRMED\n\nReglas de dominio:\n- Solo las PurchaseNote en DRAFT son editables\n- Las l√≠neas se gestionan exclusivamente en purchase_lines_service\n- Los efectos se ejecutan exclusivamente en confirm()\n\"\"\"\n\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.services.stock_movements_service import stock_movements_service\nfrom src.app.services.cash_movements_service import cash_movements_service\n\nfrom src.app.models.purchase_note import PurchaseNote\nfrom src.app.models.purchase_note_line import PurchaseNoteLine\n\nfrom src.app.core import (BadRequestException, ForbiddenException, NotFoundException, enum, db_session)\nfrom datetime import datetime, timezone\n\n\nclass PurchaseNotesService(BaseService):\n    \"\"\"\n    Servicio de dominio para PurchaseNote.\n    \"\"\"\n\n    model = PurchaseNote\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_purchase(self, purchase_note_id: int) -> PurchaseNote:\n        \"\"\"\n        Obtiene una PurchaseNote activa por ID o lanza excepci√≥n.\n        \"\"\"\n        purchase = (\n            db_session.query(PurchaseNote)\n            .filter(\n                PurchaseNote.id == purchase_note_id,\n                PurchaseNote.is_active == True,\n            )\n            .first()\n        )\n        if not purchase:\n            raise NotFoundException(\"PurchaseNote not found\")\n        return purchase\n\n    def _ensure_draft(self, purchase: PurchaseNote):\n        \"\"\"\n        Valida que la PurchaseNote est√© en estado DRAFT.\n        \"\"\"\n        if purchase.status != enum.DocumentStatus.DRAFT:\n            raise ForbiddenException(\n                \"PurchaseNote is not editable unless in DRAFT status\"\n            )\n\n    def _get_lines(self, purchase_note_id: int) -> list[PurchaseNoteLine]:\n        \"\"\"\n        Obtiene las l√≠neas activas asociadas a la PurchaseNote.\n        \"\"\"\n        return (\n            db_session.query(PurchaseNoteLine)\n            .filter(\n                PurchaseNoteLine.purchase_note_id == purchase_note_id,\n                PurchaseNoteLine.is_active == True,\n            )\n            .all()\n        )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> PurchaseNote:\n        \"\"\"\n        Crea una PurchaseNote en estado DRAFT.\n        \"\"\"\n        data[\"status\"] = enum.DocumentStatus.DRAFT\n        data[\"total_amount\"] = 0\n        if \"paid_amount\" not in data:\n            data[\"paid_amount\"] = 0\n        data[\"created_by\"] = g.current_user.id if g.current_user else None\n        return super().create(data)\n\n    def update(self, purchase_note_id: int, data: dict) -> PurchaseNote:\n        \"\"\"\n        Actualiza una PurchaseNote solo si est√° en DRAFT.\n        \"\"\"\n        purchase = self._get_purchase(purchase_note_id)\n        self._ensure_draft(purchase)\n\n        data[\"updated_by\"] = g.current_user.id if g.current_user else None\n        return super().update(purchase_note_id, data)\n\n    def delete(self, purchase_note_id: int) -> bool:\n        \"\"\"\n        Soft delete de una PurchaseNote solo si est√° en DRAFT.\n        \"\"\"\n        purchase = self._get_purchase(purchase_note_id)\n        self._ensure_draft(purchase)\n\n        purchase.is_active = False\n        purchase.deleted_at = datetime.now(timezone.utc)\n\n        purchase.updated_by = g.current_user.id if g.current_user else None\n        db_session.commit()\n        return\n\n    # ------------------------------------------------------------\n    # M√âTODOS DE NEGOCIO\n    # ------------------------------------------------------------\n    def confirm(self, purchase_note_id: int) -> PurchaseNote:\n        \"\"\"\n        Confirma una PurchaseNote.\n\n        NO decide reglas de negocio complejas ni valida invariantes de stock o cash; √∫nicamente valida estado del documento y consistencia estructural.\n        Su √∫nica responsabilidad es:\n\n        - Reunir toda la informaci√≥n del documento\n        - Lanzar los movimientos correspondientes\n        - Si no hay errores, marcar el documento como CONFIRMED\n\n        Todas las reglas de negocio (stock, cash, deuda, invariantes)\n        se validan y ejecutan exclusivamente en los movement services.\n        \"\"\"\n        purchase = self._get_purchase(purchase_note_id)\n        self._ensure_draft(purchase)\n\n        lines = self._get_lines(purchase.id)\n        if not lines:\n            raise BadRequestException(\n                \"PurchaseNote cannot be confirmed without lines\"\n            )\n\n        # --------------------------------------------------------\n        # MOVIMIENTO DE STOCK\n        #\n        # Se lanza el movimiento de stock pasando TODA la informaci√≥n\n        # necesaria (documento, l√≠neas y fecha).\n        # --------------------------------------------------------\n        stock_movements_service.apply_movement(\n            aggregate=purchase,\n            lines=lines,\n            date=purchase.date,\n        )\n\n        # --------------------------------------------------------\n        # MOVIMIENTO DE CASH\n        #\n        # Se lanza el movimiento de cash con toda la informaci√≥n\n        # del documento.\n        # --------------------------------------------------------\n        cash_movements_service.apply_movement(\n            aggregate=purchase,\n            lines=lines,\n            date=purchase.date,\n        )\n\n        # --------------------------------------------------------\n        # Cambio de estado del documento\n        # --------------------------------------------------------\n        purchase.status = enum.DocumentStatus.CONFIRMED\n        purchase.updated_by = g.current_user.id if g.current_user else None\n\n        db_session.commit()\n        return purchase\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\npurchase_notes_service = PurchaseNotesService()\n\n# /src/app/services/purchase_notes_service.py\n",
                    "sales_lines_service.py": "# /src/app/services/sales_lines_service.py\n\"\"\"\nSalesLinesService ‚Äî v3.0\n\nResponsabilidad:\n- Gestionar l√≠neas de venta (SalesLine).\n- Misma filosof√≠a que PurchaseLinesService.\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.core import (BadRequestException, ForbiddenException, NotFoundException, enum, db_session)\nfrom src.app.models.sales_note import SalesNote\nfrom src.app.models.sales_note_line import SalesNoteLine\n\n\nclass SalesLinesService(BaseService):\n    model = SalesNoteLine\n\n    def create_line(self, sales_note_id: int, data: dict):\n        \"\"\"\n        Crea una l√≠nea asociada a una SalesNote.\n        \"\"\"\n        if not sales_note_id:\n            raise BadRequestException(\"sales_note_id is required\")\n\n        sale = (\n            db_session.query(SalesNote)\n            .filter(\n                SalesNote.id == sales_note_id,\n                SalesNote.is_active == True,\n            )\n            .first()\n        )\n        if not sale:\n            raise NotFoundException(\"SalesNote not found\")\n        if sale.status != enum.DocumentStatus.DRAFT:\n            raise ForbiddenException(\n                \"SalesNote is not editable unless in DRAFT status\"\n            )\n\n        payload = dict(data)\n        payload[\"sales_note_id\"] = sales_note_id\n\n        line = self.create(payload)\n\n        sale.total_amount = sale.total_amount + line.total_price\n        sale.paid_amount = sale.total_amount\n        sale.updated_at = datetime.now(timezone.utc)\n        sale.updated_by = g.current_user.id if g.current_user else None\n        db_session.commit()\n\n        return line\n\n\nsales_lines_service = SalesLinesService()\n\n# /src/app/services/sales_lines_service.py\n",
                    "sales_notes_service.py": "# /src/app/services/sales_notes_service.py\n\n\"\"\"\nSalesNotesService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de SalesNote.\n\n‚ö†Ô∏è NO ejecuta l√≥gica de negocio de stock ni cash.\n‚úÖ Decide reglas documentales (DRAFT, l√≠neas obligatorias).\n‚ö†Ô∏è NO persiste movimientos.\n‚ö†Ô∏è NO decide reglas contables.\n\nResponsabilidades:\n- CRUD de SalesNote en estado DRAFT\n- Confirmar SalesNote:\n  - orquestar movimientos de stock y cash\n  - cambiar estado a CONFIRMED\n\nReglas de dominio:\n- Solo las SalesNote en DRAFT son editables\n- Las l√≠neas se gestionan exclusivamente en sales_lines_service\n- Los efectos se ejecutan exclusivamente en confirm()\n\"\"\"\n\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.services.stock_movements_service import stock_movements_service\nfrom src.app.services.cash_movements_service import cash_movements_service\n\nfrom src.app.models.sales_note import SalesNote\nfrom src.app.models.sales_note_line import SalesNoteLine\n\nfrom src.app.core import ( BadRequestException, ForbiddenException, NotFoundException, enum, db_session)\nfrom datetime import datetime, timezone\n\nclass SalesNotesService(BaseService):\n    \"\"\"\n    Servicio de dominio para SalesNote.\n    \"\"\"\n\n    model = SalesNote\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_sale(self, sales_note_id: int) -> SalesNote:\n        \"\"\"\n        Obtiene una SalesNote activa por ID o lanza excepci√≥n.\n        \"\"\"\n        sale = (\n            db_session.query(SalesNote)\n            .filter(\n                SalesNote.id == sales_note_id,\n                SalesNote.is_active == True,\n            )\n            .first()\n        )\n        if not sale:\n            raise NotFoundException(\"SalesNote not found\")\n        return sale\n\n    def _ensure_draft(self, sale: SalesNote):\n        \"\"\"\n        Valida que la SalesNote est√© en estado DRAFT.\n        \"\"\"\n        if sale.status != enum.DocumentStatus.DRAFT:\n            raise ForbiddenException(\n                \"SalesNote is not editable unless in DRAFT status\"\n            )\n\n    def _get_lines(self, sales_note_id: int) -> list[SalesNoteLine]:\n        \"\"\"\n        Obtiene las l√≠neas activas asociadas a la SalesNote.\n        \"\"\"\n        return (\n            db_session.query(SalesNoteLine)\n            .filter(\n                SalesNoteLine.sales_note_id == sales_note_id,\n                SalesNoteLine.is_active == True,\n            )\n            .all()\n        )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> SalesNote:\n        \"\"\"\n        Crea una SalesNote en estado DRAFT.\n        \"\"\"\n        data[\"status\"] = enum.DocumentStatus.DRAFT\n        data[\"total_amount\"] = 0\n        if \"paid_amount\" not in data:\n            data[\"paid_amount\"] = 0\n        data[\"created_by\"] = g.current_user.id if g.current_user else None\n        return super().create(data)\n\n    def update(self, sales_note_id: int, data: dict) -> SalesNote:\n        \"\"\"\n        Actualiza una SalesNote solo si est√° en DRAFT.\n        \"\"\"\n        sale = self._get_sale(sales_note_id)\n        self._ensure_draft(sale)\n\n        data[\"updated_by\"] = g.current_user.id if g.current_user else None\n        return super().update(sales_note_id, data)\n\n    def delete(self, sales_note_id: int) -> bool:\n        \"\"\"\n        Soft delete de una SalesNote solo si est√° en DRAFT.\n        \"\"\"\n        sale = self._get_sale(sales_note_id)\n        self._ensure_draft(sale)\n\n        sale.is_active = False\n        sale.deleted_at = datetime.now(timezone.utc)\n        sale.updated_by = g.current_user.id if g.current_user else None\n        db_session.commit()\n        return \n\n    # ------------------------------------------------------------\n    # M√âTODOS DE NEGOCIO\n    # ------------------------------------------------------------\n    def confirm(self, sales_note_id: int) -> SalesNote:\n        \"\"\"\n        Confirma una SalesNote.\n\n        NO decide reglas de negocio complejas ni valida invariantes de stock o cash; √∫nicamente valida estado del documento y consistencia estructural.\n        Su √∫nica responsabilidad es:\n\n        - Reunir toda la informaci√≥n del documento\n        - Lanzar los movimientos correspondientes\n        - Si no hay errores, marcar el documento como CONFIRMED\n\n        Todas las reglas de negocio (stock, cash, invariantes)\n        se validan y ejecutan exclusivamente en los movement services.\n        \"\"\"\n        sale = self._get_sale(sales_note_id)\n        self._ensure_draft(sale)\n\n        lines = self._get_lines(sale.id)\n        if not lines:\n            raise BadRequestException(\n                \"SalesNote cannot be confirmed without lines\"\n            )\n\n        # --------------------------------------------------------\n        # MOVIMIENTO DE STOCK\n        #\n        # Se lanza el movimiento de stock pasando TODA la informaci√≥n\n        # necesaria (documento, l√≠neas y fecha).\n        # --------------------------------------------------------\n        stock_movements_service.apply_movement(\n            aggregate=sale,\n            lines=lines,\n            date=sale.date,\n        )\n\n        # --------------------------------------------------------\n        # MOVIMIENTO DE CASH\n        #\n        # Se lanza el movimiento de cash con toda la informaci√≥n\n        # del documento.\n        # --------------------------------------------------------\n        cash_movements_service.apply_movement(\n            aggregate=sale,\n            lines=lines,\n            date=sale.date,\n        )\n\n        # --------------------------------------------------------\n        # Cambio de estado del documento\n        # --------------------------------------------------------\n        sale.status = enum.DocumentStatus.CONFIRMED\n        sale.updated_by = g.current_user.id if g.current_user else None\n\n        db_session.commit()\n        return sale\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nsales_notes_service = SalesNotesService()\n\n# /src/app/services/sales_notes_service.py\n",
                    "stock_deposit_notes_service.py": "# /src/app/services/stock_deposit_notes_service.py\n\n\"\"\"\nStockDepositNotesService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de StockDepositNotes.\n\n‚ö†Ô∏è NO modifica stock directamente.\n‚ö†Ô∏è NO crea ni actualiza StockProductLocation.\n‚ö†Ô∏è NO persiste movimientos.\n\nResponsabilidades:\n- CRUD de StockDepositNotes en estado DRAFT\n- Confirmar StockDepositNotes:\n  - orquestar un √∫nico movimiento de stock\n  - cambiar el estado a CONFIRMED\n\nReglas de dominio:\n- El documento es editable solo en estado DRAFT\n- El movimiento de stock se ejecuta exclusivamente en confirm()\n- El signo del movimiento depende del documento que lo lanza\n- El stock resultante nunca puede quedar negativo (invariante del movement)\n\"\"\"\n\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.services.stock_movements_service import stock_movements_service\n\nfrom src.app.models.stock_deposit_note import StockDepositNote\n\nfrom src.app.core import ( BadRequestException, ForbiddenException, NotFoundException, enum, db_session)\nfrom datetime import datetime, timezone\n\nclass StockDepositNotesService(BaseService):\n    \"\"\"\n    Servicio de dominio para StockDepositNotes.\n    \"\"\"\n\n    model = StockDepositNote\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_note(self, note_id: int) -> StockDepositNote:\n        \"\"\"\n        Obtiene una StockDepositNote activa por ID o lanza excepci√≥n.\n        \"\"\"\n        note = (\n            db_session.query(StockDepositNote)\n            .filter(\n                StockDepositNote.id == note_id,\n                StockDepositNote.is_active == True,\n            )\n            .first()\n        )\n        if not note:\n            raise NotFoundException(\"StockDepositNote not found\")\n        return note\n\n    def _ensure_draft(self, note: StockDepositNote):\n        \"\"\"\n        Valida que el documento est√© en estado DRAFT.\n        \"\"\"\n        if note.status != enum.DocumentStatus.DRAFT:\n            raise ForbiddenException(\n                \"StockDepositNote is not editable unless in DRAFT status\"\n            )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> StockDepositNote:\n        \"\"\"\n        Crea una StockDepositNote en estado DRAFT.\n        \"\"\"\n        data[\"status\"] = enum.DocumentStatus.DRAFT\n        data[\"created_by\"] = g.current_user.id if g.current_user else None\n        return super().create(data)\n\n    def update(self, note_id: int, data: dict) -> StockDepositNote:\n        \"\"\"\n        Actualiza una StockDepositNote solo si est√° en DRAFT.\n        \"\"\"\n        note = self._get_note(note_id)\n        self._ensure_draft(note)\n\n        data[\"updated_by\"] = g.current_user.id if g.current_user else None\n        return super().update(note_id, data)\n\n    def delete(self, note_id: int) -> bool:\n        \"\"\"\n        Soft delete de una StockDepositNote solo si est√° en DRAFT.\n        \"\"\"\n        note = self._get_note(note_id)\n        self._ensure_draft(note)\n\n        note.is_active = False\n        note.deleted_at = datetime.now(timezone.utc)\n        note.updated_by = g.current_user.id if g.current_user else None\n        db_session.commit()\n        return\n\n    # ------------------------------------------------------------\n    # M√âTODOS DE NEGOCIO\n    # ------------------------------------------------------------\n    def confirm(self, note_id: int) -> StockDepositNote:\n        \"\"\"\n        Confirma una StockDepositNote.\n\n        Este servicio NO decide reglas de negocio ni valida invariantes\n        de stock. Su √∫nica responsabilidad es:\n\n        - Reunir toda la informaci√≥n del documento\n        - Lanzar el movimiento de stock correspondiente\n        - Si no hay errores, marcar el documento como CONFIRMED\n\n        Todas las reglas de negocio (signo del movimiento, validaci√≥n\n        de stock no negativo, etc.) se validan y ejecutan exclusivamente\n        en el stock_movements_service.\n        \"\"\"\n        note = self._get_note(note_id)\n        self._ensure_draft(note)\n\n        if note.quantity == 0:\n            raise BadRequestException(\n                \"StockDepositNote quantity cannot be zero\"\n            )\n\n        # --------------------------------------------------------\n        # MOVIMIENTO DE STOCK\n        #\n        # Se lanza el movimiento de stock pasando TODA la informaci√≥n\n        # necesaria (documento y fecha).\n        #\n        # El stock_movements_service:\n        # - interpreta el documento\n        # - determina el signo del movimiento\n        # - valida invariantes (el stock resultante nunca queda negativo)\n        # - aplica los cambios o lanza excepci√≥n\n        # --------------------------------------------------------\n        stock_movements_service.apply_movement(aggregate=note, lines=None, date=note.date)\n\n        # --------------------------------------------------------\n        # Cambio de estado del documento\n        #\n        # Si hemos llegado aqu√≠, el movimiento se ha aplicado\n        # correctamente (no hubo excepciones).\n        # --------------------------------------------------------\n        note.status = enum.DocumentStatus.CONFIRMED\n        note.updated_by = g.current_user.id if g.current_user else None\n\n        db_session.commit()\n        return note\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nstock_deposit_notes_service = StockDepositNotesService()\n\n# /src/app/services/stock_deposit_notes_service.py\n",
                    "stock_locations_service.py": "# /src/app/services/stock_locations_service.py\n\n\"\"\"\nStockLocationsService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de ubicaciones de stock.\n\n‚ö†Ô∏è NO es un CRUD simple.\n\nResponsabilidades:\n- Crear ubicaciones de stock\n- Proteger ubicaciones especiales del sistema\n- Eliminar ubicaciones solo si no contienen stock\n\nReglas de dominio:\n- La ubicaci√≥n principal de DEME se identifica por nombre:\n  settings.DEME_STOCK_LOCATION_NAME\n- Las ubicaciones de cliente:\n  - siguen el patr√≥n CUSTOMER_STOCK_LOCATION_PATTERN\n  - NO se eliminan manualmente\n- NO existe atributo type en StockLocation\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.models.stock_location import StockLocation\nfrom src.app.models.stock_product_location import StockProductLocation\n\nfrom src.app.core import ( BadRequestException, ForbiddenException, NotFoundException, settings)\nfrom src.app.core.config.database import db_session\n\n\nclass StockLocationsService(BaseService):\n    \"\"\"\n    Servicio de dominio para StockLocation.\n    \"\"\"\n\n    model = StockLocation\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_location(self, location_id: int) -> StockLocation:\n        \"\"\"\n        Obtiene una ubicaci√≥n activa por ID o lanza excepci√≥n.\n        \"\"\"\n        location = (\n            db_session.query(StockLocation)\n            .filter(StockLocation.id == location_id, StockLocation.is_active == True)\n            .first()\n        )\n        if not location:\n            raise NotFoundException(\"StockLocation not found\")\n        return location\n\n    def _is_deme_location(self, location: StockLocation) -> bool:\n        \"\"\"\n        Indica si es la ubicaci√≥n principal de DEME.\n        \"\"\"\n        return location.name == settings.DEME_STOCK_LOCATION_NAME\n\n    def _is_customer_location(self, location: StockLocation) -> bool:\n        \"\"\"\n        Indica si es una ubicaci√≥n de cliente.\n        \"\"\"\n        return (\n            location.name.startswith(\"customer_\")\n            and location.name.endswith(\"_stock\")\n        )\n\n    def _ensure_location_deletable(self, location: StockLocation):\n        \"\"\"\n        Valida que una ubicaci√≥n pueda eliminarse sin romper integridad.\n        \"\"\"\n\n        if self._is_deme_location(location):\n            raise ForbiddenException(\"DEME stock location cannot be deleted\")\n\n        if self._is_customer_location(location):\n            raise ForbiddenException(\n                \"Customer stock locations cannot be deleted manually\"\n            )\n\n        stock_exists = db_session.query(StockProductLocation).filter(\n            StockProductLocation.stock_location_id == location.id,\n            StockProductLocation.quantity > 0,\n            StockProductLocation.is_active == True,\n        ).count()\n\n        if stock_exists > 0:\n            raise ForbiddenException(\n                \"Stock location cannot be deleted because it contains stock\"\n            )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> StockLocation:\n        \"\"\"\n        Crea una ubicaci√≥n de stock validando reglas de dominio.\n        \"\"\"\n\n        name = data.get(\"name\")\n        if not name:\n            raise BadRequestException(\"Stock location name is required\")\n\n        exists = db_session.query(StockLocation).filter(\n            StockLocation.name == name,\n            StockLocation.is_active == True,\n        ).first()\n\n        if exists:\n            raise ForbiddenException(\"Stock location name already exists\")\n\n        # Protecci√≥n: no permitir crear manualmente la ubicaci√≥n DEME\n        if name == settings.DEME_STOCK_LOCATION_NAME:\n            raise ForbiddenException(\"DEME stock location already exists\")\n\n        return super().create(data)\n\n    def delete(self, location_id: int) -> bool:\n        \"\"\"\n        Soft delete de ubicaci√≥n de stock con validaciones estrictas.\n        \"\"\"\n\n        location = self._get_location(location_id)\n\n        self._ensure_location_deletable(location)\n\n        location.is_active = False\n        location.deleted_at = datetime.now(timezone.utc)\n        location.updated_by = g.current_user.id\n\n        db_session.commit()\n        return\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nstock_locations_service = StockLocationsService()\n\n# /src/app/services/stock_locations_service.py\n",
                    "stock_movements_service.py": "# /src/app/services/stock_movements_service.py\n\n\"\"\"\nStockMovementsService ‚Äî v3.0\n\nServicio de dominio para ejecutar movimientos de stock.\n\n‚ö†Ô∏è NO es un CRUD\n‚ö†Ô∏è NO tiene modelo\n‚ö†Ô∏è NO persiste movimientos\n‚ö†Ô∏è NO conoce Documents ni cambia estados\n‚ö†Ô∏è NO asume existencia de lines salvo que se le pasen expl√≠citamente\n\nResponsabilidad √∫nica:\n- Aplicar efectos reales sobre StockProductLocation\n\nModelo operativo (cerrado v3.0):\nUn movement es siempre at√≥mico y se define como:\n(product_id, quantity, from_stock_location_id | None, to_stock_location_id | None)\n\nCasos permitidos:\n1) Compra:\n   - from: None\n   - to: DEME_STOCK\n\n2) Dep√≥sito:\n   - from: DEME_STOCK\n   - to: stock_location del cliente\n\n3) Venta:\n   - from: stock_location del cliente ‚Üí None\n   - si no alcanza:\n     - from: DEME_STOCK ‚Üí None\n\nReglas de ejecuci√≥n:\n- Los movements se disparan exclusivamente desde *_note_service.confirm()\n- PurchaseNote y SalesNote usan lines\n- StockDepositNotes NO usa lines (acci√≥n √∫nica)\n\nAuditor√≠a:\n- updated_at = date (fecha del note que lanza el movement)\n\"\"\"\n\nfrom datetime import datetime\nfrom flask import g\n\nfrom src.app.models.stock_product_location import StockProductLocation\nfrom src.app.models.stock_location import StockLocation\nfrom src.app.models.product import Product\nfrom src.app.models.purchase_note import PurchaseNote\nfrom src.app.models.sales_note import SalesNote\nfrom src.app.models.stock_deposit_note import StockDepositNote\n\nfrom src.app.core import BadRequestException, settings, db_session\n\n\nclass StockMovementsService:\n    \"\"\"\n    Servicio puro de ejecuci√≥n de movimientos de stock.\n    \"\"\"\n\n    # ------------------------------------------------------------\n    # API P√öBLICA\n    # ------------------------------------------------------------\n    def apply_movement(self, aggregate, lines: list | None, date: datetime):\n        \"\"\"\n        Ejecuta un movimiento de stock en funci√≥n del aggregate recibido.\n        \"\"\"\n\n        if isinstance(aggregate, PurchaseNote):\n            self._apply_purchase(lines, date)\n            return\n\n        if isinstance(aggregate, SalesNote):\n            self._apply_sale(aggregate, lines, date)\n            return\n\n        if isinstance(aggregate, StockDepositNote):\n            self._apply_stock_deposit(aggregate, date)\n            return\n\n        raise BadRequestException(\"Unsupported aggregate for stock movement\")\n\n    # ------------------------------------------------------------\n    # PURCHASE\n    # ------------------------------------------------------------\n    def _apply_purchase(self, lines: list | None, date: datetime):\n        \"\"\"\n        Entrada de stock desde proveedor hacia DEME_STOCK.\n        \"\"\"\n\n        if not lines:\n            raise BadRequestException(\"Purchase movement requires lines\")\n\n        deme_location = self._get_deme_location()\n\n        for line in lines:\n            self._apply_delta(\n                product_id=line.product_id,\n                location_id=deme_location.id,\n                delta=line.quantity,\n                date=date,\n            )\n\n    # ------------------------------------------------------------\n    # SALE\n    # ------------------------------------------------------------\n    def _apply_sale(self, sale: SalesNote, lines: list | None, date: datetime):\n        \"\"\"\n        Salida de stock desde la ubicaci√≥n del cliente.\n        Si no hay suficiente stock, se completa desde DEME_STOCK.\n        \"\"\"\n\n        if not lines:\n            raise BadRequestException(\"Sale movement requires lines\")\n\n        customer_location = self._get_customer_location(sale.customer_id)\n        deme_location = self._get_deme_location()\n\n        for line in lines:\n            remaining = line.quantity\n\n            available = self._get_quantity(\n                product_id=line.product_id,\n                location_id=customer_location.id,\n            )\n\n            if available > 0:\n                used = min(available, remaining)\n                self._apply_delta(\n                    product_id=line.product_id,\n                    location_id=customer_location.id,\n                    delta=-used,\n                    date=date,\n                )\n                remaining -= used\n\n            if remaining > 0:\n                self._apply_delta(\n                    product_id=line.product_id,\n                    location_id=deme_location.id,\n                    delta=-remaining,\n                    date=date,\n                )\n\n    # ------------------------------------------------------------\n    # STOCK DEPOSIT\n    # ------------------------------------------------------------\n    def _apply_stock_deposit(self, deposit: StockDepositNote, date: datetime):\n        \"\"\"\n        Movimiento √∫nico entre dos ubicaciones.\n        \"\"\"\n\n        if deposit.quantity <= 0:\n            raise BadRequestException(\"Deposit quantity must be greater than zero\")\n\n        self._apply_delta(\n            product_id=deposit.product_id,\n            location_id=deposit.from_stock_location_id,\n            delta=-deposit.quantity,\n            date=date,\n        )\n\n        self._apply_delta(\n            product_id=deposit.product_id,\n            location_id=deposit.to_stock_location_id,\n            delta=deposit.quantity,\n            date=date,\n        )\n\n    # ------------------------------------------------------------\n    # DELTA CORE\n    # ------------------------------------------------------------\n    def _apply_delta(self, product_id: int, location_id: int, delta: float, date: datetime):\n        \"\"\"\n        Aplica un delta de stock sobre una StockProductLocation.\n        \"\"\"\n\n        spl = (\n            db_session.query(StockProductLocation)\n            .filter(\n                StockProductLocation.product_id == product_id,\n                StockProductLocation.stock_location_id == location_id,\n                StockProductLocation.is_active == True,\n            )\n            .first()\n        )\n\n        if not spl:\n            spl = StockProductLocation(\n                product_id=product_id,\n                stock_location_id=location_id,\n                quantity=0,\n                is_active=True,\n            )\n            db_session.add(spl)\n\n        new_quantity = spl.quantity + delta\n        if new_quantity < 0:\n            raise BadRequestException(\"Stock cannot become negative\")\n\n        spl.quantity = new_quantity\n        spl.updated_at = date\n        spl.updated_by = g.current_user.id\n        \n        db_session.flush()\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_deme_location(self) -> StockLocation:\n        location = (\n            db_session.query(StockLocation)\n            .filter(\n                StockLocation.name == settings.DEME_STOCK_LOCATION_NAME,\n                StockLocation.is_active == True,\n            )\n            .first()\n        )\n        if not location:\n            raise BadRequestException(\"DEME stock location not found\")\n        return location\n\n    def _get_customer_location(self, customer_id: int) -> StockLocation:\n        location_name = settings.CUSTOMER_STOCK_LOCATION_PATTERN.format(\n            id=customer_id\n        )\n        location = (\n            db_session.query(StockLocation)\n            .filter(\n                StockLocation.name == location_name,\n                StockLocation.is_active == True,\n            )\n            .first()\n        )\n        if not location:\n            raise BadRequestException(\"Customer stock location not found\")\n        return location\n\n    def _get_quantity(self, product_id: int, location_id: int) -> float:\n        spl = (\n            db_session.query(StockProductLocation)\n            .filter(\n                StockProductLocation.product_id == product_id,\n                StockProductLocation.stock_location_id == location_id,\n                StockProductLocation.is_active == True,\n            )\n            .first()\n        )\n        return spl.quantity if spl else 0.0\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nstock_movements_service = StockMovementsService()\n\n# /src/app/services/stock_movements_service.py\n",
                    "stock_product_locations_service.py": "# /src/app/services/stock_product_locations_service.py\n\n\"\"\"\nStockProductLocationsService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n del stock de un producto\nen una ubicaci√≥n concreta.\n\n‚ö†Ô∏è NO es un CRUD simple.\n\nResponsabilidades:\n- Crear filas de stock producto‚Äìubicaci√≥n\n- Proteger filas asociadas a ubicaciones especiales\n- Impedir eliminaci√≥n si hay stock disponible\n\nReglas de dominio:\n- NO existen modelos de movimientos en v3.0\n- Las ubicaciones protegidas se identifican por:\n  settings.DEME_STOCK_LOCATION_NAME\n- El estado l√≥gico del registro se controla con is_active\n\"\"\"\n\nfrom flask import g\nfrom datetime import datetime, timezone\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.models.stock_product_location import StockProductLocation\nfrom src.app.models.stock_location import StockLocation\n\nfrom src.app.core import ( BadRequestException, ForbiddenException, NotFoundException, settings, enum)\nfrom src.app.core.config.database import db_session\n\n\nclass StockProductLocationsService(BaseService):\n    \"\"\"\n    Servicio de dominio para StockProductLocation.\n    \"\"\"\n\n    model = StockProductLocation\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_row(self, row_id: int) -> StockProductLocation:\n        \"\"\"\n        Obtiene una fila activa por ID o lanza excepci√≥n.\n        \"\"\"\n        row = (\n            db_session.query(StockProductLocation)\n            .filter(\n                StockProductLocation.id == row_id,\n                StockProductLocation.is_active == True,\n            )\n            .first()\n        )\n        if not row:\n            raise NotFoundException(\"StockProductLocation not found\")\n        return row\n\n    def _get_location(self, location_id: int) -> StockLocation:\n        \"\"\"\n        Obtiene una ubicaci√≥n activa por ID o lanza excepci√≥n.\n        \"\"\"\n        location = (\n            db_session.query(StockLocation)\n            .filter(\n                StockLocation.id == location_id,\n                StockLocation.is_active == True,\n            )\n            .first()\n        )\n        if not location:\n            raise NotFoundException(\"StockLocation not found\")\n        return location\n\n    def _ensure_row_deletable(self, row: StockProductLocation):\n        \"\"\"\n        Valida que una fila pueda eliminarse sin romper integridad.\n        \"\"\"\n\n        if float(row.quantity or 0) > 0:\n            raise ForbiddenException(\n                \"Stock row cannot be deleted because quantity is greater than zero\"\n            )\n\n        location = self._get_location(row.stock_location_id)\n\n        if location.name == settings.DEME_STOCK_LOCATION_NAME:\n            raise ForbiddenException(\n                \"Stock rows in DEME stock location cannot be deleted\"\n            )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> StockProductLocation:\n        \"\"\"\n        Crea una fila de stock producto‚Äìubicaci√≥n.\n\n        Si la fila ya existe y est√° activa, lanza excepci√≥n.\n        \"\"\"\n        product_id = data.get(\"product_id\")\n        location_id = data.get(\"location_id\") or data.get(\"stock_location_id\")\n\n        if not product_id or not location_id:\n            raise BadRequestException(\n                \"product_id and location_id are required\"\n            )\n\n        exists = db_session.query(StockProductLocation).filter(\n            StockProductLocation.product_id == product_id,\n            StockProductLocation.stock_location_id == location_id,\n            StockProductLocation.is_active == True,\n        ).first()\n\n        if exists:\n            raise ForbiddenException(\n                \"StockProductLocation already exists\"\n            )\n\n        payload = dict(data)\n        payload[\"stock_location_id\"] = location_id\n        payload.pop(\"location_id\", None)\n\n        return super().create(payload)\n\n    def delete(self, row_id: int) -> bool:\n        \"\"\"\n        Soft delete de fila de stock producto‚Äìubicaci√≥n.\n        \"\"\"\n        row = self._get_row(row_id)\n\n        self._ensure_row_deletable(row)\n\n        row.is_active = False\n        row.deleted_at = datetime.now(timezone.utc)\n        row.updated_by = g.current_user.id\n\n        db_session.commit()\n        return\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nstock_product_locations_service = StockProductLocationsService()\n\n# /src/app/services/stock_product_locations_service.py\n",
                    "suppliers_service.py": "# /src/app/services/suppliers_service.py\n\n\"\"\"\nSuppliersService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de proveedores.\n\nResponsabilidades:\n- CRUD de Supplier\n- Crear autom√°ticamente su CashAccount asociada\n- Garantizar unicidad del nombre\n- Proteger la integridad econ√≥mica\n\nReglas de dominio:\n- Un Supplier tiene exactamente una CashAccount\n- La CashAccount se crea autom√°ticamente al crear el Supplier\n- Un Supplier NO puede borrarse si:\n  - existen PurchaseNotes asociadas\n  - su CashAccount.balance != 0\n- Soft delete con is_active + deleted_at\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom flask import g\nfrom src.app.core import UserRole\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.services.cash_accounts_service import cash_accounts_service\n\nfrom src.app.models.supplier import Supplier\nfrom src.app.models.purchase_note import PurchaseNote\nfrom src.app.models.cash_account import CashAccount\n\nfrom src.app.core import (\n    BadRequestException,\n    ForbiddenException,\n    NotFoundException,\n    db_session,\n)\n\n\nclass SuppliersService(BaseService):\n    \"\"\"\n    Servicio de dominio para Supplier.\n    \"\"\"\n\n    model = Supplier\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_supplier(self, supplier_id: int) -> Supplier:\n        \"\"\"\n        Obtiene un proveedor activo por ID o lanza excepci√≥n.\n        \"\"\"\n        supplier = (\n            db_session.query(Supplier)\n            .filter(\n                Supplier.id == supplier_id,\n                Supplier.is_active == True,\n            )\n            .first()\n        )\n        if not supplier:\n            raise NotFoundException(\"Supplier not found\")\n        return supplier\n\n    def _get_cash_account(self, supplier: Supplier) -> CashAccount:\n        \"\"\"\n        Obtiene la CashAccount asociada a un proveedor.\n        \"\"\"\n        account = (\n            db_session.query(CashAccount)\n            .filter(\n                CashAccount.name == f\"supplier_{supplier.id}_cash\",\n                CashAccount.is_active == True,\n            )\n            .first()\n        )\n        if not account:\n            raise NotFoundException(\"Supplier cash account not found\")\n        return account\n\n    def _ensure_unique_name(self, name: str, supplier_id: int | None = None) -> None:\n        \"\"\"\n        Garantiza que el nombre del proveedor sea √∫nico.\n        \"\"\"\n        q = db_session.query(Supplier).filter(\n            Supplier.name == name,\n            Supplier.is_active == True,\n        )\n        if supplier_id:\n            q = q.filter(Supplier.id != supplier_id)\n\n        if q.first():\n            raise ForbiddenException(\"Supplier name already exists\")\n\n    def _ensure_supplier_deletable(self, supplier: Supplier) -> None:\n        \"\"\"\n        Valida que un proveedor pueda eliminarse sin romper integridad.\n\n        Reglas:\n        - No debe haber PurchaseNotes asociadas\n        - La CashAccount.balance debe ser 0\n        \"\"\"\n\n        # 1) No debe haber compras asociadas\n        purchases_count = db_session.query(PurchaseNote).filter(\n            PurchaseNote.supplier_id == supplier.id\n        ).count()\n\n        if purchases_count > 0:\n            raise ForbiddenException(\n                \"Supplier cannot be deleted because purchases exist\"\n            )\n\n        # 2) La cuenta de efectivo debe estar saldada\n        account = self._get_cash_account(supplier)\n        if account.balance != 0:\n            raise ForbiddenException(\n                \"Supplier cannot be deleted because cash balance is not zero\"\n            )\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, data: dict) -> Supplier:\n        \"\"\"\n        Crea un proveedor y su CashAccount asociada.\n        \"\"\"\n        name = data.get(\"name\")\n        if not name:\n            raise BadRequestException(\"Supplier name is required\")\n\n        self._ensure_unique_name(name)\n\n        data[\"created_by\"] = g.current_user.id if g.current_user else None\n        supplier = super().create(data)\n\n        # Creaci√≥n autom√°tica de CashAccount asociada\n        account = cash_accounts_service.create(\n            {\n                \"name\": f\"supplier_{supplier.id}_cash\",\n            }\n        )\n\n        supplier.updated_by = g.current_user.id if g.current_user else None\n\n        db_session.commit()\n        return supplier\n\n    def update(self, supplier_id: int, data: dict) -> Supplier:\n        \"\"\"\n        Actualiza un proveedor garantizando unicidad del nombre.\n        \"\"\"\n        supplier = self._get_supplier(supplier_id)\n\n        if \"name\" in data:\n            self._ensure_unique_name(data[\"name\"], supplier.id)\n\n        data[\"updated_by\"] = g.current_user.id if g.current_user else None\n        return super().update(supplier_id, data)\n\n    def delete(self, supplier_id: int) -> bool:\n        \"\"\"\n        Soft delete de proveedor con validaciones de integridad econ√≥mica.\n        \"\"\"\n        supplier = self._get_supplier(supplier_id)\n        self._ensure_supplier_deletable(supplier)\n\n        supplier.is_active = False\n        supplier.deleted_at = datetime.now(timezone.utc)\n        supplier.updated_by = g.current_user.id if g.current_user else None\n\n        db_session.commit()\n        return\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nsuppliers_service = SuppliersService()\n\n# /src/app/services/suppliers_service.py\n",
                    "users_service.py": "# /src/app/services/users_service.py\n\n\"\"\"\nUsersService ‚Äî v3.0\n\nServicio de dominio para la gesti√≥n de usuarios del sistema.\n\n‚ö†Ô∏è NO es un CRUD simple.\n\nResponsabilidades:\n- Crear usuarios con credenciales (password en claro ‚Üí hash en servidor)\n- Gestionar roles (solo admin)\n- Cambiar contrase√±as\n- Aplicar reglas de seguridad cr√≠ticas\n- Proteger invariantes (√∫ltimo admin, auto-delete)\n\nCumple architecture_v3.0:\n- Exporta una instancia\n- Controllers importan la instancia\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom flask import g\n\nfrom src.app.services.base_service import BaseService\nfrom src.app.models.user import User\n\nfrom src.app.core import (\n    BadRequestException,\n    ForbiddenException,\n    NotFoundException,\n    UserRole,\n)\nfrom src.app.core.config.database import db_session\n\nfrom src.app.security.password import hash_password, verify_password\n\n\nclass UsersService(BaseService):\n    \"\"\"\n    Servicio de dominio para usuarios.\n\n    Hereda BaseService y redefine create/update/delete\n    por reglas expl√≠citas de seguridad.\n    \"\"\"\n\n    model = User\n\n    # ------------------------------------------------------------\n    # HELPERS\n    # ------------------------------------------------------------\n    def _get_user(self, user_id: int) -> User:\n        \"\"\"\n        Obtiene un usuario activo por ID o lanza excepci√≥n.\n        \"\"\"\n        user = (\n            db_session.query(User)\n            .filter(User.id == user_id, User.is_active == True)\n            .first()\n        )\n        if not user:\n            raise NotFoundException(\"User not found\")\n        return user\n\n    def _ensure_unique_username(self, username: str, user_id: int | None = None):\n        \"\"\"\n        Garantiza que el username sea √∫nico.\n        \"\"\"\n        q = db_session.query(User).filter(\n            User.username == username,\n            User.is_active == True,\n        )\n        if user_id:\n            q = q.filter(User.id != user_id)\n\n        if q.first():\n            raise ForbiddenException(\"Username already exists\")\n\n    def _ensure_not_last_admin(self, user: User):\n        \"\"\"\n        Impide borrar el √∫ltimo usuario admin del sistema.\n        \"\"\"\n        if user.rol != UserRole.ADMIN:\n            return\n\n        total_admins = (\n            db_session.query(User)\n            .filter(\n                User.rol == UserRole.ADMIN,\n                User.is_active == True,\n            )\n            .count()\n        )\n\n        if total_admins <= 1:\n            raise ForbiddenException(\"Cannot delete the last admin\")\n\n    # ------------------------------------------------------------\n    # CRUD MODIFICADO\n    # ------------------------------------------------------------\n    def create(self, user: dict) -> User:\n        \"\"\"\n        Crea un usuario con password hasheado en servidor.\n        \"\"\"\n        username = user.get(\"username\")\n        password = user.get(\"password\")\n        rol = user.get(\"rol\")\n\n        if not username or not password or not rol:\n            raise BadRequestException(\"username, password, and rol are required\")\n\n        self._ensure_unique_username(username)\n\n        user[\"hash_password\"] = hash_password(password)\n        user[\"password_changed_at\"] = datetime.now(timezone.utc)\n        user.pop(\"password\", None)\n\n        user[\"created_by\"] = g.current_user.id if g.current_user else None\n\n        return super().create(user)\n\n    def update(self, user_id: int, user: dict) -> User:\n        \"\"\"\n        Actualiza datos del usuario respetando reglas de seguridad.\n        \"\"\"\n        current = self._get_user(user_id)\n\n        if \"hash_password\" in user or \"password_changed_at\" in user:\n            raise ForbiddenException(\"Cannot modify password directly\")\n\n        if \"username\" in user:\n            self._ensure_unique_username(user[\"username\"], user_id)\n\n        if \"rol\" in user:\n            current_user = g.current_user\n            if not current_user or current_user.rol != UserRole.ADMIN:\n                raise ForbiddenException(\"Only admin can modify roles\")\n\n        updated = super().update(user_id, user)\n        updated.updated_by = g.current_user.id\n\n        db_session.commit()\n        return updated\n\n    def delete(self, user_id: int) -> User:\n        \"\"\"\n        Soft delete de usuario con validaciones.\n        \"\"\"\n        user = self._get_user(user_id)\n\n        current_user = g.current_user\n        if not current_user:\n            raise ForbiddenException(\"Authentication required\")\n\n        if user.id == current_user.id:\n            raise ForbiddenException(\"You cannot delete your own user\")\n\n        self._ensure_not_last_admin(user)\n\n        user.is_active = False\n        user.deleted_at = datetime.now(timezone.utc)\n        user.updated_by = g.current_user.id\n\n        db_session.commit()\n        return\n\n    # ------------------------------------------------------------\n    # M√âTODOS DE NEGOCIO\n    # ------------------------------------------------------------\n    def change_password(self, user_id: int, old_password: str, new_password: str) -> User:\n        \"\"\"\n        Cambia la contrase√±a de un usuario validando credenciales.\n        \"\"\"\n        user = self._get_user(user_id)\n\n        if not old_password or not new_password:\n            raise BadRequestException(\"old_password and new_password are required\")\n\n        if not verify_password(old_password, user.hash_password):\n            raise ForbiddenException(\"Old password is incorrect\")\n\n        if len(new_password) < 6:\n            raise BadRequestException(\"New password must have at least 6 characters\")\n\n        user.hash_password = hash_password(new_password)\n        user.password_changed_at = datetime.now(timezone.utc)\n        user.updated_by = g.current_user.id\n\n        db_session.commit()\n        return user\n\n\n# ------------------------------------------------------------\n# INSTANCIA EXPORTADA (OBLIGATORIA)\n# ------------------------------------------------------------\nusers_service = UsersService()\n\n# /src/app/services/users_service.py\n",
                    "__init__.py": "# /src/app/services/__init__.py\nfrom .base_service import BaseService\n\nfrom .auth_service import auth_service\nfrom .backup_service import backup_service\n\nfrom .users_service import users_service\nfrom .customers_service import customers_service\nfrom .suppliers_service import suppliers_service\n\nfrom .products_service import products_service\n\nfrom .purchase_lines_service import purchase_lines_service\nfrom .purchase_notes_service import purchase_notes_service\n\nfrom .sales_lines_service import sales_lines_service\nfrom .sales_notes_service import sales_notes_service\n\nfrom .cash_accounts_service import cash_accounts_service\nfrom .cash_movements_service import cash_movements_service\n\nfrom .stock_locations_service import stock_locations_service\nfrom .stock_movements_service import stock_movements_service\nfrom .stock_product_locations_service import stock_product_locations_service\n\n# /src/app/services/__init__.py "
                },
                "__init__.py": "# /src/app/__init__.py\n# Paquete principal de la app"
            },
            "__init__.py": "# /src/__init__.py \n# Inicializa el package src\n# /src/__init__.py "
        },
        "tests": {
            "conftest.py": "# /src/app/tests/conftest.py\nimport os\nimport pytest\nfrom datetime import datetime\n\nfrom src.app.core.config.settings import settings\nfrom src.app.main import create_app\nfrom src.app.init_data import init_data\nfrom src.app.db.base import Base\nfrom src.app.core.config.database import engine, db_session, SessionLocal\n\n# ------------------------------------------------------------\n# CONFIGURACI√ìN GLOBAL DE TESTING\n# ------------------------------------------------------------\n\nTEST_DATABASE_PATH = \"/tmp/demearizoil_test.db\"\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef test_settings():\n    os.environ[\"DATABASE_PATH\"] = TEST_DATABASE_PATH\n    settings.DATABASE_PATH = TEST_DATABASE_PATH\n    yield\n    if os.path.exists(TEST_DATABASE_PATH):\n        os.remove(TEST_DATABASE_PATH)\n\n# ------------------------------------------------------------\n# APP + DB LIMPIA POR TEST\n# ------------------------------------------------------------\n\n@pytest.fixture(scope=\"function\")\ndef app():\n    if os.path.exists(TEST_DATABASE_PATH):\n        os.remove(TEST_DATABASE_PATH)\n\n    application = create_app(testing=True)\n    Base.metadata.create_all(bind=engine)\n    init_data()\n\n    with application.app_context():\n        yield application\n\n    Base.metadata.drop_all(bind=engine)\n    db_session.remove()\n\n# ------------------------------------------------------------\n# CLIENTE HTTP\n# ------------------------------------------------------------\n\n@pytest.fixture(scope=\"function\")\ndef client(app):\n    return app.test_client()\n\n# ------------------------------------------------------------\n# SESI√ìN SQLALCHEMY\n# ------------------------------------------------------------\n\n@pytest.fixture(scope=\"function\")\ndef session():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n# ------------------------------------------------------------\n# FIXTURES DE USUARIOS (OPT-IN)\n# ------------------------------------------------------------\n\nfrom src.app.models.user import User\nfrom src.app.security.password import hash_password\nfrom src.app.security.jwt import create_access_token\nfrom src.app.core import UserRole\n\n@pytest.fixture\ndef admin_user(session):\n    user = session.query(User).filter_by(username=\"admin\").first()\n    if user:\n        return user\n\n@pytest.fixture\ndef admin_token(admin_user):\n    return create_access_token(admin_user)\n# /src/app/tests/conftest.py\n",
            "README_tests_v3.0.md": "# TESTING v3.0 ‚Äî DemeArizOil\n\nObjetivo:\nValidar el sistema como un todo (security + business logic).\n\nPrincipios:\n- Tests de flujo, no CRUD\n- BD real aislada por test\n- JWT real\n- Sin mocks de dominio\n\nFuente de verdad:\n- Si pytest pasa, v3.0 es correcta\n",
            "test_000_health.py": "# /src/app/tests/test_000_health.py\n\"\"\"\nTest de salud b√°sico ‚Äî v3.0\n\nVerifica que:\n- La app arranca\n- Existe contexto Flask\n- Responde a una petici√≥n simple\n\"\"\"\n\ndef test_app_health(client):\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    data = response.get_json()\n    assert data[\"status\"] == \"running\"\n# /src/app/tests/test_000_health.py",
            "test_010_auth.py": "# /src/app/tests/test_010_auth.py\n\"\"\"\nAuth b√°sico ‚Äî v3.0\n\nValida:\n- Login correcto\n- Token JWT v√°lido\n- Endpoint /auth/me\n\"\"\"\n\ndef test_auth_login_and_me(client, admin_user):\n    # LOGIN\n    response = client.post(\n        \"/api/auth/login\",\n        json={\n            \"username\": \"admin\",\n            \"password\": \"admin123\"\n        }\n    )\n    assert response.status_code == 200\n\n    data = response.get_json()\n    assert \"access_token\" in data\n\n    token = data[\"access_token\"]\n\n    # AUTH ME\n    response = client.get(\n        \"/api/auth/me\",\n        headers={\n            \"Authorization\": f\"Bearer {token}\"\n        }\n    )\n    assert response.status_code == 200\n\n    me = response.get_json()\n    assert me[\"username\"] == \"admin\"\n    assert me[\"rol\"] == \"ADMIN\"\n# /src/app/tests/test_010_auth.py",
            "test_100_full_flow_basic.py": "# /src/app/tests/test_100_full_flow_basic.py\n\"\"\"\ntest_100_full_flow_basic ‚Äî v3.0\n\nEscenario:\n- Compra:\n    - 10 ud Aceite Palma 25L (inventariable) ‚Üí 1000 ‚Ç¨\n    - 1 ud Transporte (no inventariable) ‚Üí 1000 ‚Ç¨\n    - Total compra = 2000 ‚Ç¨\n    - Pagado = 1500 ‚Ç¨\n    - Deuda proveedor = -500 ‚Ç¨\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom datetime import date\n\nfrom src.app.core.enum import DocumentStatus\nfrom src.app.core.config.settings import settings\n\nfrom src.app.models.stock_location import StockLocation\nfrom src.app.models.stock_product_location import StockProductLocation\nfrom src.app.models.cash_account import CashAccount\nfrom src.app.models.purchase_note import PurchaseNote\n\n\ndef test_100_full_flow_basic(client, session, admin_token):\n\n    headers = {\n        \"Authorization\": f\"Bearer {admin_token}\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    api = settings.API_PREFIX\n\n    # ============================================================\n    # ARRANGE ‚Äî DATOS BASE\n    # ============================================================\n\n    resp = client.post(\n        f\"{api}/products/\",\n        headers=headers,\n        data=json.dumps({\n            \"name\": \"Aceite Palma 25L\",\n            \"unit_measure\": \"L\",\n            \"is_inventory\": True,\n        }),\n    )\n    assert resp.status_code == 201\n    product_id = resp.get_json()[\"id\"]\n\n    resp = client.post(\n        f\"{api}/products/\",\n        headers=headers,\n        data=json.dumps({\n            \"name\": \"Transporte\",\n            \"unit_measure\": \"ud\",\n            \"is_inventory\": False,\n        }),\n    )\n    assert resp.status_code == 201\n    transport_id = resp.get_json()[\"id\"]\n\n    resp = client.post(\n        f\"{api}/customers/\",\n        headers=headers,\n        data=json.dumps({\n            \"name\": \"Cliente Final\",\n        }),\n    )\n    assert resp.status_code == 201\n    customer_id = resp.get_json()[\"id\"]\n\n    resp = client.post(\n        f\"{api}/suppliers/\",\n        headers=headers,\n        data=json.dumps({\n            \"name\": \"Proveedor Principal\",\n        }),\n    )\n    assert resp.status_code == 201\n    supplier_id = resp.get_json()[\"id\"]\n\n    company_stock = session.query(StockLocation).filter_by(name=settings.DEME_STOCK_LOCATION_NAME).one()\n\n    company_cash = session.query(CashAccount).filter_by(name=settings.DEME_CASH_ACCOUNT_NAME).one()\n    supplier_cash = session.query(CashAccount).filter_by(name=f\"supplier_{supplier_id}_cash\").one()\n    customer_stock = session.query(StockLocation).filter_by(\n        name=settings.CUSTOMER_STOCK_LOCATION_PATTERN.format(id=customer_id)\n    ).one()\n\n    # ============================================================\n    # ACT ‚Äî 1. CREAR PURCHASE NOTE (DRAFT)\n    # ============================================================\n    resp = client.post(\n        f\"{api}/purchase_notes/\",\n        headers=headers,\n        data=json.dumps({\n            \"supplier_id\": supplier_id,\n            \"date\": date.today().isoformat(),\n            \"paid_amount\": 0,\n        }),\n    )\n    assert resp.status_code == 201\n    purchase_id = resp.get_json()[\"id\"]\n\n    # ============================================================\n    # ACT ‚Äî 2. A√ëADIR L√çNEAS\n    # ============================================================\n    resp = client.post(\n        f\"{api}/purchase_notes/{purchase_id}/lines\",\n        headers=headers,\n        data=json.dumps({\n            \"product_id\": product_id,\n            \"quantity\": 10,\n            \"unit_price\": 100,\n            \"total_price\": 1000,\n        }),\n    )\n    assert resp.status_code == 201\n\n    resp = client.post(\n        f\"{api}/purchase_notes/{purchase_id}/lines\",\n        headers=headers,\n        data=json.dumps({\n            \"product_id\": transport_id,\n            \"quantity\": 1,\n            \"unit_price\": 1000,\n            \"total_price\": 1000,\n        }),\n    )\n    assert resp.status_code == 201\n\n    # ============================================================\n    # ACT ‚Äî 3. ACTUALIZAR PAGO\n    # ============================================================\n    resp = client.put(\n        f\"{api}/purchase_notes/{purchase_id}\",\n        headers=headers,\n        data=json.dumps({\n            \"paid_amount\": 1500,\n        }),\n    )\n    assert resp.status_code == 200\n\n    # ============================================================\n    # ACT ‚Äî 4. CONFIRMAR DOCUMENTO\n    # ============================================================\n    resp = client.post(\n        f\"{api}/purchase_notes/{purchase_id}/confirm\",\n        headers=headers,\n    )\n    assert resp.status_code == 200\n    # ============================================================\n    # ASSERT ‚Äî PURCHASE NOTE\n    # ============================================================\n\n    purchase = session.get(PurchaseNote, purchase_id)\n    assert purchase.status == DocumentStatus.CONFIRMED\n    assert float(purchase.total_amount) == 2000\n    assert float(purchase.paid_amount) == 1500\n\n    # ============================================================\n    # ASSERT ‚Äî STOCK (solo inventariable)\n    # ============================================================\n\n    spl = session.query(StockProductLocation).filter_by(\n        stock_location_id=company_stock.id,\n        product_id=product_id,\n    ).first()\n\n    assert spl is not None\n    assert float(spl.quantity) == 10\n\n    # ============================================================\n    # ASSERT ‚Äî CASH\n    # ============================================================\n\n    session.refresh(company_cash)\n    session.refresh(supplier_cash)\n\n    assert float(company_cash.balance) == 500\n    assert float(supplier_cash.balance) == -500\n\n    # ============================================================\n    # ACT ‚Äî 5. MOVIMIENTO STOCK A CLIENTE (5 ud)\n    # ============================================================\n    resp = client.post(\n        f\"{api}/stock_deposit_notes/\",\n        headers=headers,\n        data=json.dumps({\n            \"from_stock_location_id\": company_stock.id,\n            \"to_stock_location_id\": customer_stock.id,\n            \"product_id\": product_id,\n            \"quantity\": 5,\n        }),\n    )\n    assert resp.status_code == 201\n    deposit_id = resp.get_json()[\"id\"]\n\n    resp = client.post(\n        f\"{api}/stock_deposit_notes/{deposit_id}/confirm\",\n        headers=headers,\n    )\n    assert resp.status_code == 200\n\n    session.expire_all()\n\n    spl_company = session.query(StockProductLocation).filter_by(\n        stock_location_id=company_stock.id,\n        product_id=product_id,\n    ).first()\n    spl_customer = session.query(StockProductLocation).filter_by(\n        stock_location_id=customer_stock.id,\n        product_id=product_id,\n    ).first()\n\n    assert spl_company is not None\n    assert spl_customer is not None\n    assert float(spl_company.quantity) == 5\n    assert float(spl_customer.quantity) == 5\n\n    # ============================================================\n    # ACT ‚Äî 6. VENTA 7 ud (5 cliente + 2 DEME)\n    # ============================================================\n    resp = client.post(\n        f\"{api}/sales_notes/\",\n        headers=headers,\n        data=json.dumps({\n            \"customer_id\": customer_id,\n            \"date\": date.today().isoformat(),\n            \"paid_amount\": 0,\n        }),\n    )\n    assert resp.status_code == 201\n    sale_id = resp.get_json()[\"id\"]\n\n    resp = client.post(\n        f\"{api}/sales_notes/{sale_id}/lines\",\n        headers=headers,\n        data=json.dumps({\n            \"product_id\": product_id,\n            \"quantity\": 7,\n            \"unit_price\": 300,\n            \"total_price\": 2100,\n        }),\n    )\n    assert resp.status_code == 201\n\n    resp = client.put(\n        f\"{api}/sales_notes/{sale_id}\",\n        headers=headers,\n        data=json.dumps({\n            \"paid_amount\": 2100,\n        }),\n    )\n    assert resp.status_code == 200\n\n    resp = client.post(\n        f\"{api}/sales_notes/{sale_id}/confirm\",\n        headers=headers,\n    )\n    assert resp.status_code == 200\n\n    session.expire_all()\n\n    spl_company = session.query(StockProductLocation).filter_by(\n        stock_location_id=company_stock.id,\n        product_id=product_id,\n    ).first()\n    spl_customer = session.query(StockProductLocation).filter_by(\n        stock_location_id=customer_stock.id,\n        product_id=product_id,\n    ).first()\n\n    assert spl_company is not None\n    assert spl_customer is not None\n    assert float(spl_company.quantity) == 3\n    assert float(spl_customer.quantity) == 0\n\n    session.refresh(company_cash)\n    assert float(company_cash.balance) == 2600\n\n    # ============================================================\n    # ACT ‚Äî 7. PAGO DE DEUDA AL PROVEEDOR (500)\n    # ============================================================\n    resp = client.post(\n        f\"{api}/cash_transfer_notes/\",\n        headers=headers,\n        data=json.dumps({\n            \"from_cash_account_id\": company_cash.id,\n            \"to_cash_account_id\": supplier_cash.id,\n            \"amount\": 500,\n        }),\n    )\n    assert resp.status_code == 201\n    transfer_id = resp.get_json()[\"id\"]\n\n    resp = client.post(\n        f\"{api}/cash_transfer_notes/{transfer_id}/confirm\",\n        headers=headers,\n    )\n    assert resp.status_code == 200\n\n    session.refresh(company_cash)\n    session.refresh(supplier_cash)\n\n    assert float(company_cash.balance) == 2100\n    assert float(supplier_cash.balance) == 0\n\n# /src/app/tests/test_100_full_flow_basic.py\n",
            "test_900_api_smoke.py": "# /src/app/tests/test_900_api_smoke.py\n\"\"\"\nSmoke suite CRUD ‚Äî v3.0\n\nValida endpoints CRUD b√°sicos por recurso con payloads m√≠nimos.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nfrom datetime import date\nfrom uuid import uuid4\n\nfrom src.app.core.config.settings import settings\nfrom src.app.models.cash_account import CashAccount\nfrom src.app.models.stock_location import StockLocation\n\n\ndef _headers(admin_token: str) -> dict[str, str]:\n    return {\n        \"Authorization\": f\"Bearer {admin_token}\",\n        \"Content-Type\": \"application/json\",\n    }\n\n\ndef _post(client, api: str, path: str, headers: dict[str, str], payload: dict):\n    return client.post(f\"{api}{path}\", headers=headers, data=json.dumps(payload))\n\n\ndef _put(client, api: str, path: str, headers: dict[str, str], payload: dict):\n    return client.put(f\"{api}{path}\", headers=headers, data=json.dumps(payload))\n\n\ndef _get(client, api: str, path: str, headers: dict[str, str]):\n    return client.get(f\"{api}{path}\", headers=headers)\n\n\ndef _delete(client, api: str, path: str, headers: dict[str, str]):\n    return client.delete(f\"{api}{path}\", headers=headers)\n\n\ndef _restore(client, api: str, path: str, headers: dict[str, str]):\n    return client.post(f\"{api}{path}\", headers=headers)\n\n\ndef test_900_api_smoke_crud(client, session, admin_token):\n    headers = _headers(admin_token)\n    api = settings.API_PREFIX\n    suffix = uuid4().hex[:8]\n\n    # USERS\n    resp = _post(client, api, \"/users/\", headers, {\n        \"username\": f\"smoke_user_{suffix}\",\n        \"password\": \"pass1234\",\n        \"rol\": \"ADMIN\",\n        \"email\": f\"smoke_{suffix}@example.com\",\n    })\n    assert resp.status_code == 201\n    user_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/users/{user_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/users/{user_id}\", headers, {\n        \"email\": f\"smoke_{suffix}_updated@example.com\",\n    }).status_code == 200\n    assert _delete(client, api, f\"/users/{user_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/users/{user_id}/restore\", headers).status_code == 200\n\n    # PRODUCTS\n    resp = _post(client, api, \"/products/\", headers, {\n        \"name\": f\"Smoke Product {suffix}\",\n        \"unit_measure\": \"ud\",\n        \"is_inventory\": True,\n    })\n    assert resp.status_code == 201\n    product_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/products/{product_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/products/{product_id}\", headers, {\n        \"name\": f\"Smoke Product {suffix} v2\",\n    }).status_code == 200\n    assert _delete(client, api, f\"/products/{product_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/products/{product_id}/restore\", headers).status_code == 200\n\n    # CUSTOMERS\n    resp = _post(client, api, \"/customers/\", headers, {\n        \"name\": f\"Smoke Customer {suffix}\",\n    })\n    assert resp.status_code == 201\n    customer_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/customers/{customer_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/customers/{customer_id}\", headers, {\n        \"name\": f\"Smoke Customer {suffix} v2\",\n    }).status_code == 200\n    assert _delete(client, api, f\"/customers/{customer_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/customers/{customer_id}/restore\", headers).status_code == 200\n\n    # SUPPLIERS\n    resp = _post(client, api, \"/suppliers/\", headers, {\n        \"name\": f\"Smoke Supplier {suffix}\",\n    })\n    assert resp.status_code == 201\n    supplier_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/suppliers/{supplier_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/suppliers/{supplier_id}\", headers, {\n        \"name\": f\"Smoke Supplier {suffix} v2\",\n    }).status_code == 200\n    assert _delete(client, api, f\"/suppliers/{supplier_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/suppliers/{supplier_id}/restore\", headers).status_code == 200\n\n    # STOCK LOCATIONS\n    resp = _post(client, api, \"/stock_locations/\", headers, {\n        \"name\": f\"smoke_loc_{suffix}\",\n    })\n    assert resp.status_code == 201\n    location_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/stock_locations/{location_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/stock_locations/{location_id}\", headers, {\n        \"name\": f\"smoke_loc_{suffix}_v2\",\n    }).status_code == 200\n    assert _delete(client, api, f\"/stock_locations/{location_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/stock_locations/{location_id}/restore\", headers).status_code == 200\n\n    # STOCK PRODUCT LOCATIONS\n    resp = _post(client, api, \"/stock_product_locations/\", headers, {\n        \"product_id\": product_id,\n        \"stock_location_id\": location_id,\n        \"quantity\": 0,\n    })\n    assert resp.status_code == 201\n    row_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/stock_product_locations/{row_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/stock_product_locations/{row_id}\", headers, {\n        \"quantity\": 0,\n    }).status_code == 200\n    assert _delete(client, api, f\"/stock_product_locations/{row_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/stock_product_locations/{row_id}/restore\", headers).status_code == 200\n\n    # CASH ACCOUNTS\n    resp = _post(client, api, \"/cash_accounts/\", headers, {\n        \"name\": f\"smoke_cash_{suffix}\",\n        \"balance\": 0,\n    })\n    assert resp.status_code == 201\n    cash_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/cash_accounts/{cash_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/cash_accounts/{cash_id}\", headers, {\n        \"name\": f\"smoke_cash_{suffix}_v2\",\n    }).status_code == 200\n    assert _delete(client, api, f\"/cash_accounts/{cash_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/cash_accounts/{cash_id}/restore\", headers).status_code == 200\n\n    # PURCHASE NOTES + LINES\n    resp = _post(client, api, \"/purchase_notes/\", headers, {\n        \"supplier_id\": supplier_id,\n        \"date\": date.today().isoformat(),\n        \"paid_amount\": 0,\n    })\n    assert resp.status_code == 201\n    purchase_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/purchase_notes/{purchase_id}\", headers).status_code == 200\n    resp = _post(client, api, f\"/purchase_notes/{purchase_id}/lines\", headers, {\n        \"product_id\": product_id,\n        \"quantity\": 1,\n        \"unit_price\": 10,\n        \"total_price\": 10,\n    })\n    assert resp.status_code == 201\n    purchase_line_id = resp.get_json()[\"id\"]\n    assert _delete(client, api, f\"/purchase_notes/lines/{purchase_line_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/purchase_notes/{purchase_id}\", headers, {\n        \"paid_amount\": 0,\n    }).status_code == 200\n    assert _delete(client, api, f\"/purchase_notes/{purchase_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/purchase_notes/{purchase_id}/restore\", headers).status_code == 200\n\n    # SALES NOTES + LINES\n    resp = _post(client, api, \"/sales_notes/\", headers, {\n        \"customer_id\": customer_id,\n        \"date\": date.today().isoformat(),\n        \"paid_amount\": 0,\n    })\n    assert resp.status_code == 201\n    sale_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/sales_notes/{sale_id}\", headers).status_code == 200\n    resp = _post(client, api, f\"/sales_notes/{sale_id}/lines\", headers, {\n        \"product_id\": product_id,\n        \"quantity\": 1,\n        \"unit_price\": 10,\n        \"total_price\": 10,\n    })\n    assert resp.status_code == 201\n    sales_line_id = resp.get_json()[\"id\"]\n    assert _delete(client, api, f\"/sales_notes/lines/{sales_line_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/sales_notes/{sale_id}\", headers, {\n        \"paid_amount\": 10,\n    }).status_code == 200\n    assert _delete(client, api, f\"/sales_notes/{sale_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/sales_notes/{sale_id}/restore\", headers).status_code == 200\n\n    # STOCK DEPOSIT NOTES\n    resp = _post(client, api, \"/stock_deposit_notes/\", headers, {\n        \"from_stock_location_id\": session.query(StockLocation)\n        .filter_by(name=settings.DEME_STOCK_LOCATION_NAME)\n        .one().id,\n        \"to_stock_location_id\": location_id,\n        \"product_id\": product_id,\n        \"quantity\": 1,\n    })\n    assert resp.status_code == 201\n    deposit_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/stock_deposit_notes/{deposit_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/stock_deposit_notes/{deposit_id}\", headers, {\n        \"notes\": \"smoke\",\n    }).status_code == 200\n    assert _delete(client, api, f\"/stock_deposit_notes/{deposit_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/stock_deposit_notes/{deposit_id}/restore\", headers).status_code == 200\n\n    # CASH TRANSFER NOTES\n    company_cash_id = session.query(CashAccount).filter_by(\n        name=settings.DEME_CASH_ACCOUNT_NAME\n    ).one().id\n    resp = _post(client, api, \"/cash_transfer_notes/\", headers, {\n        \"from_cash_account_id\": company_cash_id,\n        \"to_cash_account_id\": cash_id,\n        \"amount\": 1,\n    })\n    assert resp.status_code == 201\n    transfer_id = resp.get_json()[\"id\"]\n    assert _get(client, api, f\"/cash_transfer_notes/{transfer_id}\", headers).status_code == 200\n    assert _put(client, api, f\"/cash_transfer_notes/{transfer_id}\", headers, {\n        \"notes\": \"smoke\",\n    }).status_code == 200\n    assert _delete(client, api, f\"/cash_transfer_notes/{transfer_id}\", headers).status_code == 200\n    assert _restore(client, api, f\"/cash_transfer_notes/{transfer_id}/restore\", headers).status_code == 200\n"
        }
    }
}